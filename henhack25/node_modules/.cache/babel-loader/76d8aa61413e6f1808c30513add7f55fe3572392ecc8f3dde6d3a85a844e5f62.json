{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { translate as e } from \"../core/libs/gl-matrix-2/math/mat4.js\";\nimport { create as t } from \"../core/libs/gl-matrix-2/factories/mat4f64.js\";\nimport { set as o } from \"../core/libs/gl-matrix-2/math/vec2.js\";\nimport { create as r } from \"../core/libs/gl-matrix-2/factories/vec2f64.js\";\nimport { Laserline as a } from \"../views/3d/webgl-engine/core/shaderLibrary/Laserline.glsl.js\";\nimport { Float2BindUniform as i } from \"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";\nimport { FloatBindUniform as n } from \"../views/3d/webgl-engine/core/shaderModules/FloatBindUniform.js\";\nimport { FloatPassUniform as s } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as l, If as d } from \"../views/3d/webgl-engine/core/shaderModules/glsl.js\";\nimport { Matrix4BindUniform as c } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4BindUniform.js\";\nimport { Matrix4PassUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { VertexAttribute as v } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { ShaderBuilder as p } from \"../views/webgl/ShaderBuilder.js\";\nfunction w(t) {\n  const r = new p();\n  r.include(a, t);\n  const {\n    vertex: w,\n    fragment: u\n  } = r;\n  w.uniforms.add(new m(\"modelView\", (t, _ref) => {\n    let {\n      camera: o\n    } = _ref;\n    return e(f, o.viewMatrix, t.origin);\n  }), new c(\"proj\", _ref2 => {\n    let {\n      camera: e\n    } = _ref2;\n    return e.projectionMatrix;\n  }), new s(\"glowWidth\", (e, _ref3) => {\n    let {\n      camera: t\n    } = _ref3;\n    return e.glowWidth * t.pixelRatio;\n  }), new i(\"pixelToNDC\", _ref4 => {\n    let {\n      camera: e\n    } = _ref4;\n    return o(g, 2 / e.fullViewport[2], 2 / e.fullViewport[3]);\n  })), r.attributes.add(v.START, \"vec3\"), r.attributes.add(v.END, \"vec3\"), t.spherical && (r.attributes.add(v.START_UP, \"vec3\"), r.attributes.add(v.END_UP, \"vec3\")), r.attributes.add(v.EXTRUDE, \"vec2\"), r.varyings.add(\"uv\", \"vec2\"), r.varyings.add(\"vViewStart\", \"vec3\"), r.varyings.add(\"vViewEnd\", \"vec3\"), r.varyings.add(\"vViewSegmentNormal\", \"vec3\"), r.varyings.add(\"vViewStartNormal\", \"vec3\"), r.varyings.add(\"vViewEndNormal\", \"vec3\");\n  const h = !t.spherical;\n  return w.main.add(l`\n    vec3 pos = mix(start, end, extrude.x);\n\n    vec4 viewPos = modelView * vec4(pos, 1);\n    vec4 projPos = proj * viewPos;\n    vec2 ndcPos = projPos.xy / projPos.w;\n\n    // in planar we hardcode the up vectors to be Z-up */\n    ${d(h, l`vec3 startUp = vec3(0, 0, 1);`)}\n    ${d(h, l`vec3 endUp = vec3(0, 0, 1);`)}\n\n    // up vector corresponding to the location of the vertex, selecting either startUp or endUp */\n    vec3 up = extrude.y * mix(startUp, endUp, extrude.x);\n    vec3 viewUp = (modelView * vec4(up, 0)).xyz;\n\n    vec4 projPosUp = proj * vec4(viewPos.xyz + viewUp, 1);\n    vec2 projUp = normalize(projPosUp.xy / projPosUp.w - ndcPos);\n\n    // extrude ndcPos along projUp to the edge of the screen\n    vec2 lxy = abs(sign(projUp) - ndcPos);\n    ndcPos += length(lxy) * projUp;\n\n    vViewStart = (modelView * vec4(start, 1)).xyz;\n    vViewEnd = (modelView * vec4(end, 1)).xyz;\n\n    vec3 viewStartEndDir = vViewEnd - vViewStart;\n\n    vec3 viewStartUp = (modelView * vec4(startUp, 0)).xyz;\n\n    // the normal of the plane that aligns with the segment and the up vector\n    vViewSegmentNormal = normalize(cross(viewStartUp, viewStartEndDir));\n\n    // the normal orthogonal to the segment normal and the start up vector\n    vViewStartNormal = -normalize(cross(vViewSegmentNormal, viewStartUp));\n\n    // the normal orthogonal to the segment normal and the end up vector\n    vec3 viewEndUp = (modelView * vec4(endUp, 0)).xyz;\n    vViewEndNormal = normalize(cross(vViewSegmentNormal, viewEndUp));\n\n    // Add enough padding in the X screen space direction for \"glow\"\n    float xPaddingPixels = sign(dot(vViewSegmentNormal, viewPos.xyz)) * (extrude.x * 2.0 - 1.0) * glowWidth;\n    ndcPos.x += xPaddingPixels * pixelToNDC.x;\n\n    // uv is used to read back depth to reconstruct the position at the fragment\n    uv = ndcPos * 0.5 + 0.5;\n\n    gl_Position = vec4(ndcPos, 0, 1);\n  `), u.uniforms.add(new n(\"perScreenPixelRatio\", e => e.camera.perScreenPixelRatio)), u.code.add(l`float planeDistance(vec3 planeNormal, vec3 planeOrigin, vec3 pos) {\nreturn dot(planeNormal, pos - planeOrigin);\n}\nfloat segmentDistancePixels(vec3 segmentNormal, vec3 startNormal, vec3 endNormal, vec3 pos, vec3 start, vec3 end) {\nfloat distSegmentPlane = planeDistance(segmentNormal, start, pos);\nfloat distStartPlane = planeDistance(startNormal, start, pos);\nfloat distEndPlane = planeDistance(endNormal, end, pos);\nfloat dist = max(max(distStartPlane, distEndPlane), abs(distSegmentPlane));\nfloat width = fwidth(distSegmentPlane);\nfloat maxPixelDistance = length(pos) * perScreenPixelRatio * 2.0;\nfloat pixelDist = dist / min(width, maxPixelDistance);\nreturn abs(pixelDist);\n}`), u.main.add(l`fragColor = vec4(0.0);\nvec3 dEndStart = vViewEnd - vViewStart;\nif (dot(dEndStart, dEndStart) < 1e-5) {\nreturn;\n}\nvec3 pos;\nvec3 normal;\nfloat angleCutoffAdjust;\nfloat depthDiscontinuityAlpha;\nif (!laserlineReconstructFromDepth(pos, normal, angleCutoffAdjust, depthDiscontinuityAlpha)) {\nreturn;\n}\nfloat distance = segmentDistancePixels(\nvViewSegmentNormal,\nvViewStartNormal,\nvViewEndNormal,\npos,\nvViewStart,\nvViewEnd\n);\nvec4 color = laserlineProfile(distance);\nfloat alpha = (1.0 - smoothstep(0.995 - angleCutoffAdjust, 0.999 - angleCutoffAdjust, abs(dot(normal, vViewSegmentNormal))));\nfragColor = laserlineOutput(color * alpha * depthDiscontinuityAlpha);`), r;\n}\nconst g = r(),\n  f = t(),\n  u = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    build: w\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { u as L, w as b };","map":{"version":3,"names":["translate","e","create","t","set","o","r","Laserline","a","Float2BindUniform","i","FloatBindUniform","n","FloatPassUniform","s","glsl","l","If","d","Matrix4BindUniform","c","Matrix4PassUniform","m","VertexAttribute","v","ShaderBuilder","p","w","include","vertex","fragment","u","uniforms","add","_ref","camera","f","viewMatrix","origin","_ref2","projectionMatrix","_ref3","glowWidth","pixelRatio","_ref4","g","fullViewport","attributes","START","END","spherical","START_UP","END_UP","EXTRUDE","varyings","h","main","perScreenPixelRatio","code","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value","L","b"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/chunks/LaserlinePath.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{translate as e}from\"../core/libs/gl-matrix-2/math/mat4.js\";import{create as t}from\"../core/libs/gl-matrix-2/factories/mat4f64.js\";import{set as o}from\"../core/libs/gl-matrix-2/math/vec2.js\";import{create as r}from\"../core/libs/gl-matrix-2/factories/vec2f64.js\";import{Laserline as a}from\"../views/3d/webgl-engine/core/shaderLibrary/Laserline.glsl.js\";import{Float2BindUniform as i}from\"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";import{FloatBindUniform as n}from\"../views/3d/webgl-engine/core/shaderModules/FloatBindUniform.js\";import{FloatPassUniform as s}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as l,If as d}from\"../views/3d/webgl-engine/core/shaderModules/glsl.js\";import{Matrix4BindUniform as c}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4BindUniform.js\";import{Matrix4PassUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{VertexAttribute as v}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{ShaderBuilder as p}from\"../views/webgl/ShaderBuilder.js\";function w(t){const r=new p;r.include(a,t);const{vertex:w,fragment:u}=r;w.uniforms.add(new m(\"modelView\",((t,{camera:o})=>e(f,o.viewMatrix,t.origin))),new c(\"proj\",(({camera:e})=>e.projectionMatrix)),new s(\"glowWidth\",((e,{camera:t})=>e.glowWidth*t.pixelRatio)),new i(\"pixelToNDC\",(({camera:e})=>o(g,2/e.fullViewport[2],2/e.fullViewport[3])))),r.attributes.add(v.START,\"vec3\"),r.attributes.add(v.END,\"vec3\"),t.spherical&&(r.attributes.add(v.START_UP,\"vec3\"),r.attributes.add(v.END_UP,\"vec3\")),r.attributes.add(v.EXTRUDE,\"vec2\"),r.varyings.add(\"uv\",\"vec2\"),r.varyings.add(\"vViewStart\",\"vec3\"),r.varyings.add(\"vViewEnd\",\"vec3\"),r.varyings.add(\"vViewSegmentNormal\",\"vec3\"),r.varyings.add(\"vViewStartNormal\",\"vec3\"),r.varyings.add(\"vViewEndNormal\",\"vec3\");const h=!t.spherical;return w.main.add(l`\n    vec3 pos = mix(start, end, extrude.x);\n\n    vec4 viewPos = modelView * vec4(pos, 1);\n    vec4 projPos = proj * viewPos;\n    vec2 ndcPos = projPos.xy / projPos.w;\n\n    // in planar we hardcode the up vectors to be Z-up */\n    ${d(h,l`vec3 startUp = vec3(0, 0, 1);`)}\n    ${d(h,l`vec3 endUp = vec3(0, 0, 1);`)}\n\n    // up vector corresponding to the location of the vertex, selecting either startUp or endUp */\n    vec3 up = extrude.y * mix(startUp, endUp, extrude.x);\n    vec3 viewUp = (modelView * vec4(up, 0)).xyz;\n\n    vec4 projPosUp = proj * vec4(viewPos.xyz + viewUp, 1);\n    vec2 projUp = normalize(projPosUp.xy / projPosUp.w - ndcPos);\n\n    // extrude ndcPos along projUp to the edge of the screen\n    vec2 lxy = abs(sign(projUp) - ndcPos);\n    ndcPos += length(lxy) * projUp;\n\n    vViewStart = (modelView * vec4(start, 1)).xyz;\n    vViewEnd = (modelView * vec4(end, 1)).xyz;\n\n    vec3 viewStartEndDir = vViewEnd - vViewStart;\n\n    vec3 viewStartUp = (modelView * vec4(startUp, 0)).xyz;\n\n    // the normal of the plane that aligns with the segment and the up vector\n    vViewSegmentNormal = normalize(cross(viewStartUp, viewStartEndDir));\n\n    // the normal orthogonal to the segment normal and the start up vector\n    vViewStartNormal = -normalize(cross(vViewSegmentNormal, viewStartUp));\n\n    // the normal orthogonal to the segment normal and the end up vector\n    vec3 viewEndUp = (modelView * vec4(endUp, 0)).xyz;\n    vViewEndNormal = normalize(cross(vViewSegmentNormal, viewEndUp));\n\n    // Add enough padding in the X screen space direction for \"glow\"\n    float xPaddingPixels = sign(dot(vViewSegmentNormal, viewPos.xyz)) * (extrude.x * 2.0 - 1.0) * glowWidth;\n    ndcPos.x += xPaddingPixels * pixelToNDC.x;\n\n    // uv is used to read back depth to reconstruct the position at the fragment\n    uv = ndcPos * 0.5 + 0.5;\n\n    gl_Position = vec4(ndcPos, 0, 1);\n  `),u.uniforms.add(new n(\"perScreenPixelRatio\",(e=>e.camera.perScreenPixelRatio))),u.code.add(l`float planeDistance(vec3 planeNormal, vec3 planeOrigin, vec3 pos) {\nreturn dot(planeNormal, pos - planeOrigin);\n}\nfloat segmentDistancePixels(vec3 segmentNormal, vec3 startNormal, vec3 endNormal, vec3 pos, vec3 start, vec3 end) {\nfloat distSegmentPlane = planeDistance(segmentNormal, start, pos);\nfloat distStartPlane = planeDistance(startNormal, start, pos);\nfloat distEndPlane = planeDistance(endNormal, end, pos);\nfloat dist = max(max(distStartPlane, distEndPlane), abs(distSegmentPlane));\nfloat width = fwidth(distSegmentPlane);\nfloat maxPixelDistance = length(pos) * perScreenPixelRatio * 2.0;\nfloat pixelDist = dist / min(width, maxPixelDistance);\nreturn abs(pixelDist);\n}`),u.main.add(l`fragColor = vec4(0.0);\nvec3 dEndStart = vViewEnd - vViewStart;\nif (dot(dEndStart, dEndStart) < 1e-5) {\nreturn;\n}\nvec3 pos;\nvec3 normal;\nfloat angleCutoffAdjust;\nfloat depthDiscontinuityAlpha;\nif (!laserlineReconstructFromDepth(pos, normal, angleCutoffAdjust, depthDiscontinuityAlpha)) {\nreturn;\n}\nfloat distance = segmentDistancePixels(\nvViewSegmentNormal,\nvViewStartNormal,\nvViewEndNormal,\npos,\nvViewStart,\nvViewEnd\n);\nvec4 color = laserlineProfile(distance);\nfloat alpha = (1.0 - smoothstep(0.995 - angleCutoffAdjust, 0.999 - angleCutoffAdjust, abs(dot(normal, vViewSegmentNormal))));\nfragColor = laserlineOutput(color * alpha * depthDiscontinuityAlpha);`),r}const g=r(),f=t(),u=Object.freeze(Object.defineProperty({__proto__:null,build:w},Symbol.toStringTag,{value:\"Module\"}));export{u as L,w as b};\n"],"mappings":"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ACjB,CAAC;AAC51D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,CAAC,CAACqC,CAAC,EAACvC,CAAC,+BAA+B,CAAC;AAC3C,MAAME,CAAC,CAACqC,CAAC,EAACvC,CAAC,6BAA6B,CAAC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC,EAACe,CAAC,CAACC,QAAQ,CAACC,GAAG,CAAC,IAAIrB,CAAC,CAAC,qBAAqB,EAAEX,CAAC,IAAEA,CAAC,CAACkC,MAAM,CAACsB,mBAAoB,CAAC,CAAC,EAAC1B,CAAC,CAAC2B,IAAI,CAACzB,GAAG,CAACjB,CAAC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACe,CAAC,CAACyB,IAAI,CAACvB,GAAG,CAACjB,CAAC;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,CAAC,EAACV,CAAC;AAAA;AAAC,MAAMuC,CAAC,GAACvC,CAAC,CAAC,CAAC;EAAC8B,CAAC,GAACjC,CAAC,CAAC,CAAC;EAAC4B,CAAC,GAAC4B,MAAM,CAACC,MAAM,CAACD,MAAM,CAACE,cAAc,CAAC;IAACC,SAAS,EAAC,IAAI;IAACC,KAAK,EAACpC;EAAC,CAAC,EAACqC,MAAM,CAACC,WAAW,EAAC;IAACC,KAAK,EAAC;EAAQ,CAAC,CAAC,CAAC;AAAC,SAAOnC,CAAC,IAAIoC,CAAC,EAACxC,CAAC,IAAIyC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}