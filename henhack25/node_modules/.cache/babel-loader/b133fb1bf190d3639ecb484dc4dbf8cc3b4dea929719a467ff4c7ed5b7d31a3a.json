{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { ContextRequestEvent } from '../context-request-event.js';\n/**\n * A ReactiveController which adds context consuming behavior to a custom\n * element by dispatching `context-request` events.\n *\n * When the host element is connected to the document it will emit a\n * `context-request` event with its context key. When the context request\n * is satisfied the controller will invoke the callback, if present, and\n * trigger a host update so it can respond to the new value.\n *\n * It will also call the dispose method given by the provider when the\n * host element is disconnected.\n */\nexport class ContextConsumer {\n  constructor(host, contextOrOptions, callback, subscribe) {\n    this.subscribe = false;\n    this.provided = false;\n    this.value = undefined;\n    // This function must have stable identity to properly dedupe in ContextRoot\n    // if this element connects multiple times.\n    this._callback = (value, unsubscribe) => {\n      // some providers will pass an unsubscribe function indicating they may provide future values\n      if (this.unsubscribe) {\n        // if the unsubscribe function changes this implies we have changed provider\n        if (this.unsubscribe !== unsubscribe) {\n          // cleanup the old provider\n          this.provided = false;\n          this.unsubscribe();\n        }\n        // if we don't support subscription, immediately unsubscribe\n        if (!this.subscribe) {\n          this.unsubscribe();\n        }\n      }\n      // store the value so that it can be retrieved from the controller\n      this.value = value;\n      // schedule an update in case this value is used in a template\n      this.host.requestUpdate();\n      // only invoke callback if we are either expecting updates or have not yet\n      // been provided a value\n      if (!this.provided || this.subscribe) {\n        this.provided = true;\n        if (this.callback) {\n          this.callback(value, unsubscribe);\n        }\n      }\n      this.unsubscribe = unsubscribe;\n    };\n    this.host = host;\n    // This is a potentially fragile duck-type. It means a context object can't\n    // have a property name context and be used in positional argument form.\n    if (contextOrOptions.context !== undefined) {\n      const options = contextOrOptions;\n      this.context = options.context;\n      this.callback = options.callback;\n      this.subscribe = options.subscribe ?? false;\n    } else {\n      this.context = contextOrOptions;\n      this.callback = callback;\n      this.subscribe = subscribe ?? false;\n    }\n    this.host.addController(this);\n  }\n  hostConnected() {\n    this.dispatchRequest();\n  }\n  hostDisconnected() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n      this.unsubscribe = undefined;\n    }\n  }\n  dispatchRequest() {\n    this.host.dispatchEvent(new ContextRequestEvent(this.context, this.host, this._callback, this.subscribe));\n  }\n}","map":{"version":3,"names":["ContextRequestEvent","ContextConsumer","constructor","host","contextOrOptions","callback","subscribe","provided","value","undefined","_callback","unsubscribe","requestUpdate","context","options","addController","hostConnected","dispatchRequest","hostDisconnected","dispatchEvent"],"sources":["C:\\Users\\nolan\\tasks\\HenHacks2025\\henhack25\\node_modules\\@lit\\context\\src\\lib\\controllers\\context-consumer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  ContextCallback,\n  ContextRequestEvent,\n} from '../context-request-event.js';\nimport type {Context, ContextType} from '../create-context.js';\nimport type {\n  ReactiveController,\n  ReactiveControllerHost,\n} from '@lit/reactive-element';\n\nexport interface Options<C extends Context<unknown, unknown>> {\n  context: C;\n  callback?: (value: ContextType<C>, dispose?: () => void) => void;\n  subscribe?: boolean;\n}\n\n/**\n * A ReactiveController which adds context consuming behavior to a custom\n * element by dispatching `context-request` events.\n *\n * When the host element is connected to the document it will emit a\n * `context-request` event with its context key. When the context request\n * is satisfied the controller will invoke the callback, if present, and\n * trigger a host update so it can respond to the new value.\n *\n * It will also call the dispose method given by the provider when the\n * host element is disconnected.\n */\nexport class ContextConsumer<\n  C extends Context<unknown, unknown>,\n  HostElement extends ReactiveControllerHost & HTMLElement,\n> implements ReactiveController\n{\n  protected host: HostElement;\n  private context: C;\n  private callback?: (value: ContextType<C>, dispose?: () => void) => void;\n  private subscribe = false;\n\n  private provided = false;\n\n  value?: ContextType<C> = undefined;\n\n  constructor(host: HostElement, options: Options<C>);\n  /** @deprecated Use new ContextConsumer(host, options) */\n  constructor(\n    host: HostElement,\n    context: C,\n    callback?: (value: ContextType<C>, dispose?: () => void) => void,\n    subscribe?: boolean\n  );\n  constructor(\n    host: HostElement,\n    contextOrOptions: C | Options<C>,\n    callback?: (value: ContextType<C>, dispose?: () => void) => void,\n    subscribe?: boolean\n  ) {\n    this.host = host;\n    // This is a potentially fragile duck-type. It means a context object can't\n    // have a property name context and be used in positional argument form.\n    if ((contextOrOptions as Options<C>).context !== undefined) {\n      const options = contextOrOptions as Options<C>;\n      this.context = options.context;\n      this.callback = options.callback;\n      this.subscribe = options.subscribe ?? false;\n    } else {\n      this.context = contextOrOptions as C;\n      this.callback = callback;\n      this.subscribe = subscribe ?? false;\n    }\n    this.host.addController(this);\n  }\n\n  private unsubscribe?: () => void;\n\n  hostConnected(): void {\n    this.dispatchRequest();\n  }\n\n  hostDisconnected(): void {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n      this.unsubscribe = undefined;\n    }\n  }\n\n  private dispatchRequest() {\n    this.host.dispatchEvent(\n      new ContextRequestEvent(\n        this.context,\n        this.host,\n        this._callback,\n        this.subscribe\n      )\n    );\n  }\n\n  // This function must have stable identity to properly dedupe in ContextRoot\n  // if this element connects multiple times.\n  private _callback: ContextCallback<ContextType<C>> = (value, unsubscribe) => {\n    // some providers will pass an unsubscribe function indicating they may provide future values\n    if (this.unsubscribe) {\n      // if the unsubscribe function changes this implies we have changed provider\n      if (this.unsubscribe !== unsubscribe) {\n        // cleanup the old provider\n        this.provided = false;\n        this.unsubscribe();\n      }\n      // if we don't support subscription, immediately unsubscribe\n      if (!this.subscribe) {\n        this.unsubscribe();\n      }\n    }\n\n    // store the value so that it can be retrieved from the controller\n    this.value = value;\n    // schedule an update in case this value is used in a template\n    this.host.requestUpdate();\n\n    // only invoke callback if we are either expecting updates or have not yet\n    // been provided a value\n    if (!this.provided || this.subscribe) {\n      this.provided = true;\n      if (this.callback) {\n        this.callback(value, unsubscribe);\n      }\n    }\n\n    this.unsubscribe = unsubscribe;\n  };\n}\n"],"mappings":"AAAA;;;;;AAMA,SAEEA,mBAAmB,QACd,6BAA6B;AAapC;;;;;;;;;;;;AAYA,OAAM,MAAOC,eAAe;EAsB1BC,YACEC,IAAiB,EACjBC,gBAAgC,EAChCC,QAAgE,EAChEC,SAAmB;IAlBb,KAAAA,SAAS,GAAG,KAAK;IAEjB,KAAAC,QAAQ,GAAG,KAAK;IAExB,KAAAC,KAAK,GAAoBC,SAAS;IAwDlC;IACA;IACQ,KAAAC,SAAS,GAAoC,CAACF,KAAK,EAAEG,WAAW,KAAI;MAC1E;MACA,IAAI,IAAI,CAACA,WAAW,EAAE;QACpB;QACA,IAAI,IAAI,CAACA,WAAW,KAAKA,WAAW,EAAE;UACpC;UACA,IAAI,CAACJ,QAAQ,GAAG,KAAK;UACrB,IAAI,CAACI,WAAW,EAAE;QACpB;QACA;QACA,IAAI,CAAC,IAAI,CAACL,SAAS,EAAE;UACnB,IAAI,CAACK,WAAW,EAAE;QACpB;MACF;MAEA;MACA,IAAI,CAACH,KAAK,GAAGA,KAAK;MAClB;MACA,IAAI,CAACL,IAAI,CAACS,aAAa,EAAE;MAEzB;MACA;MACA,IAAI,CAAC,IAAI,CAACL,QAAQ,IAAI,IAAI,CAACD,SAAS,EAAE;QACpC,IAAI,CAACC,QAAQ,GAAG,IAAI;QACpB,IAAI,IAAI,CAACF,QAAQ,EAAE;UACjB,IAAI,CAACA,QAAQ,CAACG,KAAK,EAAEG,WAAW,CAAC;QACnC;MACF;MAEA,IAAI,CAACA,WAAW,GAAGA,WAAW;IAChC,CAAC;IAxEC,IAAI,CAACR,IAAI,GAAGA,IAAI;IAChB;IACA;IACA,IAAKC,gBAA+B,CAACS,OAAO,KAAKJ,SAAS,EAAE;MAC1D,MAAMK,OAAO,GAAGV,gBAA8B;MAC9C,IAAI,CAACS,OAAO,GAAGC,OAAO,CAACD,OAAO;MAC9B,IAAI,CAACR,QAAQ,GAAGS,OAAO,CAACT,QAAQ;MAChC,IAAI,CAACC,SAAS,GAAGQ,OAAO,CAACR,SAAS,IAAI,KAAK;IAC7C,CAAC,MAAM;MACL,IAAI,CAACO,OAAO,GAAGT,gBAAqB;MACpC,IAAI,CAACC,QAAQ,GAAGA,QAAQ;MACxB,IAAI,CAACC,SAAS,GAAGA,SAAS,IAAI,KAAK;IACrC;IACA,IAAI,CAACH,IAAI,CAACY,aAAa,CAAC,IAAI,CAAC;EAC/B;EAIAC,aAAaA,CAAA;IACX,IAAI,CAACC,eAAe,EAAE;EACxB;EAEAC,gBAAgBA,CAAA;IACd,IAAI,IAAI,CAACP,WAAW,EAAE;MACpB,IAAI,CAACA,WAAW,EAAE;MAClB,IAAI,CAACA,WAAW,GAAGF,SAAS;IAC9B;EACF;EAEQQ,eAAeA,CAAA;IACrB,IAAI,CAACd,IAAI,CAACgB,aAAa,CACrB,IAAInB,mBAAmB,CACrB,IAAI,CAACa,OAAO,EACZ,IAAI,CAACV,IAAI,EACT,IAAI,CAACO,SAAS,EACd,IAAI,CAACJ,SAAS,CACf,CACF;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}