{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { ContextRequestEvent } from '../context-request-event.js';\nimport { ValueNotifier } from '../value-notifier.js';\nexport class ContextProviderEvent extends Event {\n  /**\n   *\n   * @param context the context which this provider can provide\n   * @param contextTarget the original context target of the provider\n   */\n  constructor(context, contextTarget) {\n    super('context-provider', {\n      bubbles: true,\n      composed: true\n    });\n    this.context = context;\n    this.contextTarget = contextTarget;\n  }\n}\n/**\n * A ReactiveController which adds context provider behavior to a\n * custom element.\n *\n * This controller simply listens to the `context-request` event when\n * the host is connected to the DOM and registers the received callbacks\n * against its observable Context implementation.\n *\n * The controller may also be attached to any HTML element in which case it's\n * up to the user to call hostConnected() when attached to the DOM. This is\n * done automatically for any custom elements implementing\n * ReactiveControllerHost.\n */\nexport class ContextProvider extends ValueNotifier {\n  constructor(host, contextOrOptions, initialValue) {\n    super(contextOrOptions.context !== undefined ? contextOrOptions.initialValue : initialValue);\n    this.onContextRequest = ev => {\n      // Only call the callback if the context matches.\n      if (ev.context !== this.context) {\n        return;\n      }\n      // Also, in case an element is a consumer AND a provider\n      // of the same context, we want to avoid the element to self-register.\n      const consumerHost = ev.contextTarget ?? ev.composedPath()[0];\n      if (consumerHost === this.host) {\n        return;\n      }\n      ev.stopPropagation();\n      this.addCallback(ev.callback, consumerHost, ev.subscribe);\n    };\n    /**\n     * When we get a provider request event, that means a child of this element\n     * has just woken up. If it's a provider of our context, then we may need to\n     * re-parent our subscriptions, because is a more specific provider than us\n     * for its subtree.\n     */\n    this.onProviderRequest = ev => {\n      // Ignore events when the context doesn't match.\n      if (ev.context !== this.context) {\n        return;\n      }\n      // Also, in case an element is a consumer AND a provider\n      // of the same context it shouldn't provide to itself.\n      const childProviderHost = ev.contextTarget ?? ev.composedPath()[0];\n      if (childProviderHost === this.host) {\n        return;\n      }\n      // Re-parent all of our subscriptions in case this new child provider\n      // should take them over.\n      const seen = new Set();\n      for (const [callback, {\n        consumerHost\n      }] of this.subscriptions) {\n        // Prevent infinite loops in the case where a one host element\n        // is providing the same context multiple times.\n        //\n        // While normally it's a no-op to attempt to re-parent a subscription\n        // that already has its proper parent, in the case where there's more\n        // than one ValueProvider for the same context on the same hostElement,\n        // they will each call the consumer, and since they will each have their\n        // own dispose function, a well behaved consumer will notice the change\n        // in dispose function and call their old one.\n        //\n        // This will cause the subscriptions to thrash, but worse, without this\n        // set check here, we can end up in an infinite loop, as we add and remove\n        // the same subscriptions onto the end of the map over and over.\n        if (seen.has(callback)) {\n          continue;\n        }\n        seen.add(callback);\n        consumerHost.dispatchEvent(new ContextRequestEvent(this.context, consumerHost, callback, true));\n      }\n      ev.stopPropagation();\n    };\n    this.host = host;\n    if (contextOrOptions.context !== undefined) {\n      this.context = contextOrOptions.context;\n    } else {\n      this.context = contextOrOptions;\n    }\n    this.attachListeners();\n    this.host.addController?.(this);\n  }\n  attachListeners() {\n    this.host.addEventListener('context-request', this.onContextRequest);\n    this.host.addEventListener('context-provider', this.onProviderRequest);\n  }\n  hostConnected() {\n    // emit an event to signal a provider is available for this context\n    this.host.dispatchEvent(new ContextProviderEvent(this.context, this.host));\n  }\n}","map":{"version":3,"names":["ContextRequestEvent","ValueNotifier","ContextProviderEvent","Event","constructor","context","contextTarget","bubbles","composed","ContextProvider","host","contextOrOptions","initialValue","undefined","onContextRequest","ev","consumerHost","composedPath","stopPropagation","addCallback","callback","subscribe","onProviderRequest","childProviderHost","seen","Set","subscriptions","has","add","dispatchEvent","attachListeners","addController","addEventListener","hostConnected"],"sources":["C:\\Users\\nolan\\tasks\\HenHacks2025\\henhack25\\node_modules\\@lit\\context\\src\\lib\\controllers\\context-provider.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextRequestEvent} from '../context-request-event.js';\nimport {ValueNotifier} from '../value-notifier.js';\nimport type {Context, ContextType} from '../create-context.js';\nimport type {\n  ReactiveController,\n  ReactiveControllerHost,\n} from '@lit/reactive-element';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    /**\n     * A 'context-provider' event can be emitted by any element which hosts\n     * a context provider to indicate it is available for use.\n     */\n    'context-provider': ContextProviderEvent<Context<unknown, unknown>>;\n  }\n}\n\nexport class ContextProviderEvent<\n  C extends Context<unknown, unknown>,\n> extends Event {\n  readonly context: C;\n  readonly contextTarget: Element;\n\n  /**\n   *\n   * @param context the context which this provider can provide\n   * @param contextTarget the original context target of the provider\n   */\n  constructor(context: C, contextTarget: Element) {\n    super('context-provider', {bubbles: true, composed: true});\n    this.context = context;\n    this.contextTarget = contextTarget;\n  }\n}\n\nexport interface Options<C extends Context<unknown, unknown>> {\n  context: C;\n  initialValue?: ContextType<C>;\n}\n\ntype ReactiveElementHost = Partial<ReactiveControllerHost> & HTMLElement;\n\n/**\n * A ReactiveController which adds context provider behavior to a\n * custom element.\n *\n * This controller simply listens to the `context-request` event when\n * the host is connected to the DOM and registers the received callbacks\n * against its observable Context implementation.\n *\n * The controller may also be attached to any HTML element in which case it's\n * up to the user to call hostConnected() when attached to the DOM. This is\n * done automatically for any custom elements implementing\n * ReactiveControllerHost.\n */\nexport class ContextProvider<\n    T extends Context<unknown, unknown>,\n    HostElement extends ReactiveElementHost = ReactiveElementHost,\n  >\n  extends ValueNotifier<ContextType<T>>\n  implements ReactiveController\n{\n  protected readonly host: HostElement;\n  private readonly context: T;\n\n  constructor(host: HostElement, options: Options<T>);\n  /** @deprecated Use new ContextProvider(host, options) */\n  constructor(host: HostElement, context: T, initialValue?: ContextType<T>);\n  constructor(\n    host: HostElement,\n    contextOrOptions: T | Options<T>,\n    initialValue?: ContextType<T>\n  ) {\n    super(\n      (contextOrOptions as Options<T>).context !== undefined\n        ? (contextOrOptions as Options<T>).initialValue\n        : initialValue\n    );\n    this.host = host;\n    if ((contextOrOptions as Options<T>).context !== undefined) {\n      this.context = (contextOrOptions as Options<T>).context;\n    } else {\n      this.context = contextOrOptions as T;\n    }\n    this.attachListeners();\n    this.host.addController?.(this);\n  }\n\n  onContextRequest = (\n    ev: ContextRequestEvent<Context<unknown, unknown>>\n  ): void => {\n    // Only call the callback if the context matches.\n    if (ev.context !== this.context) {\n      return;\n    }\n    // Also, in case an element is a consumer AND a provider\n    // of the same context, we want to avoid the element to self-register.\n    const consumerHost = ev.contextTarget ?? ev.composedPath()[0];\n    if (consumerHost === this.host) {\n      return;\n    }\n    ev.stopPropagation();\n    this.addCallback(ev.callback, consumerHost, ev.subscribe);\n  };\n\n  /**\n   * When we get a provider request event, that means a child of this element\n   * has just woken up. If it's a provider of our context, then we may need to\n   * re-parent our subscriptions, because is a more specific provider than us\n   * for its subtree.\n   */\n  onProviderRequest = (\n    ev: ContextProviderEvent<Context<unknown, unknown>>\n  ): void => {\n    // Ignore events when the context doesn't match.\n    if (ev.context !== this.context) {\n      return;\n    }\n    // Also, in case an element is a consumer AND a provider\n    // of the same context it shouldn't provide to itself.\n    const childProviderHost = ev.contextTarget ?? ev.composedPath()[0];\n    if (childProviderHost === this.host) {\n      return;\n    }\n    // Re-parent all of our subscriptions in case this new child provider\n    // should take them over.\n    const seen = new Set<unknown>();\n    for (const [callback, {consumerHost}] of this.subscriptions) {\n      // Prevent infinite loops in the case where a one host element\n      // is providing the same context multiple times.\n      //\n      // While normally it's a no-op to attempt to re-parent a subscription\n      // that already has its proper parent, in the case where there's more\n      // than one ValueProvider for the same context on the same hostElement,\n      // they will each call the consumer, and since they will each have their\n      // own dispose function, a well behaved consumer will notice the change\n      // in dispose function and call their old one.\n      //\n      // This will cause the subscriptions to thrash, but worse, without this\n      // set check here, we can end up in an infinite loop, as we add and remove\n      // the same subscriptions onto the end of the map over and over.\n      if (seen.has(callback)) {\n        continue;\n      }\n      seen.add(callback);\n      consumerHost.dispatchEvent(\n        new ContextRequestEvent(this.context, consumerHost, callback, true)\n      );\n    }\n    ev.stopPropagation();\n  };\n\n  private attachListeners() {\n    this.host.addEventListener('context-request', this.onContextRequest);\n    this.host.addEventListener('context-provider', this.onProviderRequest);\n  }\n\n  hostConnected(): void {\n    // emit an event to signal a provider is available for this context\n    this.host.dispatchEvent(new ContextProviderEvent(this.context, this.host));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}