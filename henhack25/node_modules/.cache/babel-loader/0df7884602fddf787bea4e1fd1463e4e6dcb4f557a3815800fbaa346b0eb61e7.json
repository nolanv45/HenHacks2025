{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { ShaderOutput as e } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";\nimport { SliceDraw as o } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { Transform as r } from \"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";\nimport { ObjectAndLayerIdColor as t } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js\";\nimport { VertexColor as a } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";\nimport { terrainDepthTest as i } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js\";\nimport { VisualVariables as l } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js\";\nimport { ColorConversion as n } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { addProjViewLocalOrigin as c, addCameraPosition as d } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float4PassUniform as s } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatBindUniform as v } from \"../views/3d/webgl-engine/core/shaderModules/FloatBindUniform.js\";\nimport { glsl as g } from \"../views/3d/webgl-engine/core/shaderModules/glsl.js\";\nimport { VertexAttribute as p } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { Style as m } from \"../views/3d/webgl-engine/materials/PatternStyle.js\";\nimport { outputColorHighlightOID as f } from \"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js\";\nimport { ShaderBuilder as u } from \"../views/webgl/ShaderBuilder.js\";\nconst w = .70710678118,\n  b = w,\n  h = .08715574274,\n  y = 10,\n  S = 1;\nfunction j(j) {\n  const C = new u(),\n    {\n      vertex: T,\n      fragment: P,\n      attributes: R,\n      varyings: V\n    } = C,\n    D = j.output === e.Highlight;\n  c(T, j), C.include(r, j), C.include(a, j), C.include(l, j), C.include(t, j), C.fragment.include(o, j), C.include(f, j), C.include(i, j), j.draped ? T.uniforms.add(new v(\"worldToScreenRatio\", e => 1 / e.screenToPCSRatio)) : R.add(p.BOUNDINGRECT, \"mat3\"), R.add(p.POSITION, \"vec3\"), R.add(p.UVMAPSPACE, \"vec4\"), j.vvColor && R.add(p.COLORFEATUREATTRIBUTE, \"float\"), j.hasVertexColors || V.add(\"vColor\", \"vec4\"), V.add(\"vpos\", \"vec3\"), V.add(\"vuv\", \"vec2\"), T.uniforms.add(new s(\"uColor\", e => e.color));\n  const O = j.style === m.ForwardDiagonal || j.style === m.BackwardDiagonal || j.style === m.DiagonalCross;\n  return O && T.code.add(g`\n      const mat2 rotate45 = mat2(${g.float(w)}, ${g.float(-.70710678118)},\n                                 ${g.float(b)}, ${g.float(w)});\n    `), j.draped || (d(T, j), T.uniforms.add(new v(\"worldToScreenPerDistanceRatio\", e => 1 / e.camera.perScreenPixelRatio)), T.code.add(g`vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {\nfloat projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);\nreturn center + halfVector * clamp(projectedLength, -1.0, 1.0);\n}`), T.code.add(g`vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {\nfloat d = dot(planeNormal, planePoint);\nfloat t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);\nreturn rayOrigin + t * rayDir;\n}`), T.code.add(g`\n      float boundingRectDistanceToCamera() {\n        vec3 center = vec3(boundingRect[0][0], boundingRect[0][1], boundingRect[0][2]);\n        vec3 halfU = vec3(boundingRect[1][0], boundingRect[1][1], boundingRect[1][2]);\n        vec3 halfV = vec3(boundingRect[2][0], boundingRect[2][1], boundingRect[2][2]);\n        vec3 n = normalize(cross(halfU, halfV));\n\n        vec3 viewDir = - vec3(view[0][2], view[1][2], view[2][2]);\n\n        float viewAngle = dot(viewDir, n);\n        float minViewAngle = ${g.float(h)};\n\n        if (abs(viewAngle) < minViewAngle) {\n          // view direction is (almost) parallel to plane -> clamp it to min angle\n          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;\n          viewDir = normalize(viewDir + normalComponent * n);\n        }\n\n        // intersect view direction with infinite plane that contains bounding rect\n        vec3 planeProjected = intersectRayPlane(viewDir, cameraPosition, n, center);\n\n        // clip to bounds by projecting to u and v line segments individually\n        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);\n        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);\n\n        // use to calculate the closest point to camera on bounding rect\n        vec3 closestPoint = uProjected + vProjected - center;\n\n        return length(closestPoint - cameraPosition);\n      }\n    `)), T.code.add(g`\n    vec2 scaledUV() {\n      vec2 uv = uvMapSpace.xy ${O ? \" * rotate45\" : \"\"};\n      vec2 uvCellOrigin = uvMapSpace.zw ${O ? \" * rotate45\" : \"\"};\n\n      ${j.draped ? \"\" : g`\n            float distanceToCamera = boundingRectDistanceToCamera();\n            float worldToScreenRatio = worldToScreenPerDistanceRatio / distanceToCamera;\n          `}\n\n      // Logarithmically discretize ratio to avoid jittering\n      float step = 0.1;\n      float discreteWorldToScreenRatio = log(worldToScreenRatio);\n      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;\n      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);\n\n      vec2 uvOffset = mod(uvCellOrigin * discreteWorldToScreenRatio, ${g.float(y)});\n      return uvOffset + (uv * discreteWorldToScreenRatio);\n    }\n  `), T.main.add(g`\n    vuv = scaledUV();\n    vpos = position;\n    forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);\n    forwardNormalizedVertexColor();\n    forwardObjectAndLayerIdColor();\n    ${j.hasVertexColors ? \"vColor *= uColor;\" : j.vvColor ? \"vColor = uColor * interpolateVVColor(colorFeatureAttribute);\" : \"vColor = uColor;\"}\n    gl_Position = transformPosition(proj, view, vpos);\n  `), P.include(n), j.draped && P.uniforms.add(new v(\"texelSize\", e => 1 / e.camera.pixelRatio)), D || (P.code.add(g`\n      const float lineWidth = ${g.float(S)};\n      const float spacing = ${g.float(y)};\n      const float spacingINV = ${g.float(1 / y)};\n\n      float coverage(float p, float txlSize) {\n        p = mod(p, spacing);\n\n        float halfTxlSize = txlSize / 2.0;\n\n        float start = p - halfTxlSize;\n        float end = p + halfTxlSize;\n\n        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;\n        coverage -= min(lineWidth, mod(start, spacing));\n        coverage -= max(lineWidth - mod(end, spacing), 0.0);\n\n        return coverage / txlSize;\n      }\n    `), j.draped || P.code.add(g`const int maxSamples = 5;\nfloat sampleAA(float p) {\nvec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));\nfloat fwidth = dxdy.x + dxdy.y;\nivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));\nvec2 invSamples = 1.0 / vec2(samples);\nfloat accumulator = 0.0;\nfor (int j = 0; j < maxSamples; j++) {\nif(j >= samples.y) {\nbreak;\n}\nfor (int i = 0; i < maxSamples; i++) {\nif(i >= samples.x) {\nbreak;\n}\nvec2 step = vec2(i,j) * invSamples - 0.5;\naccumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);\n}\n}\naccumulator /= float(samples.x * samples.y);\nreturn accumulator;\n}`)), P.main.add(g`\n    discardBySlice(vpos);\n    discardByTerrainDepth();\n    vec4 color = vColor;\n    ${D ? \"\" : g`color.a *= ${x(j)};`}\n    outputColorHighlightOID(color, vpos);\n  `), C;\n}\nfunction x(e) {\n  function o(o) {\n    return e.draped ? g`coverage(vuv.${o}, texelSize)` : g`sampleAA(vuv.${o})`;\n  }\n  switch (e.style) {\n    case m.ForwardDiagonal:\n    case m.Horizontal:\n      return o(\"y\");\n    case m.BackwardDiagonal:\n    case m.Vertical:\n      return o(\"x\");\n    case m.DiagonalCross:\n    case m.Cross:\n      return g`1.0 - (1.0 - ${o(\"x\")}) * (1.0 - ${o(\"y\")})`;\n    default:\n      return \"0.0\";\n  }\n}\nconst C = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: j\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { C as P, j as b };","map":{"version":3,"names":["ShaderOutput","e","SliceDraw","o","Transform","r","ObjectAndLayerIdColor","t","VertexColor","a","terrainDepthTest","i","VisualVariables","l","ColorConversion","n","addProjViewLocalOrigin","c","addCameraPosition","d","Float4PassUniform","s","FloatBindUniform","v","glsl","g","VertexAttribute","p","Style","m","outputColorHighlightOID","f","ShaderBuilder","u","w","b","h","y","S","j","C","vertex","T","fragment","P","attributes","R","varyings","V","D","output","Highlight","include","draped","uniforms","add","screenToPCSRatio","BOUNDINGRECT","POSITION","UVMAPSPACE","vvColor","COLORFEATUREATTRIBUTE","hasVertexColors","color","O","style","ForwardDiagonal","BackwardDiagonal","DiagonalCross","code","float","camera","perScreenPixelRatio","main","pixelRatio","x","Horizontal","Vertical","Cross","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/chunks/Pattern.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{ShaderOutput as e}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";import{SliceDraw as o}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{Transform as r}from\"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";import{ObjectAndLayerIdColor as t}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js\";import{VertexColor as a}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";import{terrainDepthTest as i}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js\";import{VisualVariables as l}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js\";import{ColorConversion as n}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{addProjViewLocalOrigin as c,addCameraPosition as d}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float4PassUniform as s}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatBindUniform as v}from\"../views/3d/webgl-engine/core/shaderModules/FloatBindUniform.js\";import{glsl as g}from\"../views/3d/webgl-engine/core/shaderModules/glsl.js\";import{VertexAttribute as p}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{Style as m}from\"../views/3d/webgl-engine/materials/PatternStyle.js\";import{outputColorHighlightOID as f}from\"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js\";import{ShaderBuilder as u}from\"../views/webgl/ShaderBuilder.js\";const w=.70710678118,b=w,h=.08715574274,y=10,S=1;function j(j){const C=new u,{vertex:T,fragment:P,attributes:R,varyings:V}=C,D=j.output===e.Highlight;c(T,j),C.include(r,j),C.include(a,j),C.include(l,j),C.include(t,j),C.fragment.include(o,j),C.include(f,j),C.include(i,j),j.draped?T.uniforms.add(new v(\"worldToScreenRatio\",(e=>1/e.screenToPCSRatio))):R.add(p.BOUNDINGRECT,\"mat3\"),R.add(p.POSITION,\"vec3\"),R.add(p.UVMAPSPACE,\"vec4\"),j.vvColor&&R.add(p.COLORFEATUREATTRIBUTE,\"float\"),j.hasVertexColors||V.add(\"vColor\",\"vec4\"),V.add(\"vpos\",\"vec3\"),V.add(\"vuv\",\"vec2\"),T.uniforms.add(new s(\"uColor\",(e=>e.color)));const O=j.style===m.ForwardDiagonal||j.style===m.BackwardDiagonal||j.style===m.DiagonalCross;return O&&T.code.add(g`\n      const mat2 rotate45 = mat2(${g.float(w)}, ${g.float(-.70710678118)},\n                                 ${g.float(b)}, ${g.float(w)});\n    `),j.draped||(d(T,j),T.uniforms.add(new v(\"worldToScreenPerDistanceRatio\",(e=>1/e.camera.perScreenPixelRatio))),T.code.add(g`vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {\nfloat projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);\nreturn center + halfVector * clamp(projectedLength, -1.0, 1.0);\n}`),T.code.add(g`vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {\nfloat d = dot(planeNormal, planePoint);\nfloat t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);\nreturn rayOrigin + t * rayDir;\n}`),T.code.add(g`\n      float boundingRectDistanceToCamera() {\n        vec3 center = vec3(boundingRect[0][0], boundingRect[0][1], boundingRect[0][2]);\n        vec3 halfU = vec3(boundingRect[1][0], boundingRect[1][1], boundingRect[1][2]);\n        vec3 halfV = vec3(boundingRect[2][0], boundingRect[2][1], boundingRect[2][2]);\n        vec3 n = normalize(cross(halfU, halfV));\n\n        vec3 viewDir = - vec3(view[0][2], view[1][2], view[2][2]);\n\n        float viewAngle = dot(viewDir, n);\n        float minViewAngle = ${g.float(h)};\n\n        if (abs(viewAngle) < minViewAngle) {\n          // view direction is (almost) parallel to plane -> clamp it to min angle\n          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;\n          viewDir = normalize(viewDir + normalComponent * n);\n        }\n\n        // intersect view direction with infinite plane that contains bounding rect\n        vec3 planeProjected = intersectRayPlane(viewDir, cameraPosition, n, center);\n\n        // clip to bounds by projecting to u and v line segments individually\n        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);\n        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);\n\n        // use to calculate the closest point to camera on bounding rect\n        vec3 closestPoint = uProjected + vProjected - center;\n\n        return length(closestPoint - cameraPosition);\n      }\n    `)),T.code.add(g`\n    vec2 scaledUV() {\n      vec2 uv = uvMapSpace.xy ${O?\" * rotate45\":\"\"};\n      vec2 uvCellOrigin = uvMapSpace.zw ${O?\" * rotate45\":\"\"};\n\n      ${j.draped?\"\":g`\n            float distanceToCamera = boundingRectDistanceToCamera();\n            float worldToScreenRatio = worldToScreenPerDistanceRatio / distanceToCamera;\n          `}\n\n      // Logarithmically discretize ratio to avoid jittering\n      float step = 0.1;\n      float discreteWorldToScreenRatio = log(worldToScreenRatio);\n      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;\n      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);\n\n      vec2 uvOffset = mod(uvCellOrigin * discreteWorldToScreenRatio, ${g.float(y)});\n      return uvOffset + (uv * discreteWorldToScreenRatio);\n    }\n  `),T.main.add(g`\n    vuv = scaledUV();\n    vpos = position;\n    forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);\n    forwardNormalizedVertexColor();\n    forwardObjectAndLayerIdColor();\n    ${j.hasVertexColors?\"vColor *= uColor;\":j.vvColor?\"vColor = uColor * interpolateVVColor(colorFeatureAttribute);\":\"vColor = uColor;\"}\n    gl_Position = transformPosition(proj, view, vpos);\n  `),P.include(n),j.draped&&P.uniforms.add(new v(\"texelSize\",(e=>1/e.camera.pixelRatio))),D||(P.code.add(g`\n      const float lineWidth = ${g.float(S)};\n      const float spacing = ${g.float(y)};\n      const float spacingINV = ${g.float(1/y)};\n\n      float coverage(float p, float txlSize) {\n        p = mod(p, spacing);\n\n        float halfTxlSize = txlSize / 2.0;\n\n        float start = p - halfTxlSize;\n        float end = p + halfTxlSize;\n\n        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;\n        coverage -= min(lineWidth, mod(start, spacing));\n        coverage -= max(lineWidth - mod(end, spacing), 0.0);\n\n        return coverage / txlSize;\n      }\n    `),j.draped||P.code.add(g`const int maxSamples = 5;\nfloat sampleAA(float p) {\nvec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));\nfloat fwidth = dxdy.x + dxdy.y;\nivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));\nvec2 invSamples = 1.0 / vec2(samples);\nfloat accumulator = 0.0;\nfor (int j = 0; j < maxSamples; j++) {\nif(j >= samples.y) {\nbreak;\n}\nfor (int i = 0; i < maxSamples; i++) {\nif(i >= samples.x) {\nbreak;\n}\nvec2 step = vec2(i,j) * invSamples - 0.5;\naccumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);\n}\n}\naccumulator /= float(samples.x * samples.y);\nreturn accumulator;\n}`)),P.main.add(g`\n    discardBySlice(vpos);\n    discardByTerrainDepth();\n    vec4 color = vColor;\n    ${D?\"\":g`color.a *= ${x(j)};`}\n    outputColorHighlightOID(color, vpos);\n  `),C}function x(e){function o(o){return e.draped?g`coverage(vuv.${o}, texelSize)`:g`sampleAA(vuv.${o})`}switch(e.style){case m.ForwardDiagonal:case m.Horizontal:return o(\"y\");case m.BackwardDiagonal:case m.Vertical:return o(\"x\");case m.DiagonalCross:case m.Cross:return g`1.0 - (1.0 - ${o(\"x\")}) * (1.0 - ${o(\"y\")})`;default:return\"0.0\"}}const C=Object.freeze(Object.defineProperty({__proto__:null,build:j},Symbol.toStringTag,{value:\"Module\"}));export{C as P,j as b};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}