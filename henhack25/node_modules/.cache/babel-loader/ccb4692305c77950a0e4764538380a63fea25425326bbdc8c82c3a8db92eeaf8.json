{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { validateLabelingInfo as e } from \"../../../../../../layers/support/labelingInfo.js\";\nimport { getServiceGeometryType as s } from \"../../layerAdapters/geometryUtils.js\";\nimport { createSymbolMeshSchemas as a } from \"./symbols/SymbolSchema.js\";\nasync function l(a, l, r) {\n  const n = l.labelsVisible && l.labelingInfo || [],\n    i = s(l),\n    m = e(n, i);\n  return {\n    type: \"label\",\n    classes: await Promise.all(m.map((e, s) => o(a, e, s, r)))\n  };\n}\nasync function o(e, s, l, o) {\n  const r = await a(s, {\n    path: `${l}`,\n    schemaOptions: e,\n    uniforms: o\n  });\n  return {\n    maxScale: s.maxScale,\n    minScale: s.minScale,\n    expression: s.labelExpressionInfo?.expression ?? s.labelExpression,\n    where: s.where,\n    meshes: r\n  };\n}\nexport { l as createLabelMatcherSchema };","map":{"version":3,"names":["validateLabelingInfo","e","getServiceGeometryType","s","createSymbolMeshSchemas","a","l","r","n","labelsVisible","labelingInfo","i","m","type","classes","Promise","all","map","o","path","schemaOptions","uniforms","maxScale","minScale","expression","labelExpressionInfo","labelExpression","where","meshes","createLabelMatcherSchema"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/views/2d/layers/features/schema/processor/LabelMatcherSchema.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{validateLabelingInfo as e}from\"../../../../../../layers/support/labelingInfo.js\";import{getServiceGeometryType as s}from\"../../layerAdapters/geometryUtils.js\";import{createSymbolMeshSchemas as a}from\"./symbols/SymbolSchema.js\";async function l(a,l,r){const n=l.labelsVisible&&l.labelingInfo||[],i=s(l),m=e(n,i);return{type:\"label\",classes:await Promise.all(m.map(((e,s)=>o(a,e,s,r))))}}async function o(e,s,l,o){const r=await a(s,{path:`${l}`,schemaOptions:e,uniforms:o});return{maxScale:s.maxScale,minScale:s.minScale,expression:s.labelExpressionInfo?.expression??s.labelExpression,where:s.where,meshes:r}}export{l as createLabelMatcherSchema};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,oBAAoB,IAAIC,CAAC,QAAK,kDAAkD;AAAC,SAAOC,sBAAsB,IAAIC,CAAC,QAAK,sCAAsC;AAAC,SAAOC,uBAAuB,IAAIC,CAAC,QAAK,2BAA2B;AAAC,eAAeC,CAACA,CAACD,CAAC,EAACC,CAAC,EAACC,CAAC,EAAC;EAAC,MAAMC,CAAC,GAACF,CAAC,CAACG,aAAa,IAAEH,CAAC,CAACI,YAAY,IAAE,EAAE;IAACC,CAAC,GAACR,CAAC,CAACG,CAAC,CAAC;IAACM,CAAC,GAACX,CAAC,CAACO,CAAC,EAACG,CAAC,CAAC;EAAC,OAAM;IAACE,IAAI,EAAC,OAAO;IAACC,OAAO,EAAC,MAAMC,OAAO,CAACC,GAAG,CAACJ,CAAC,CAACK,GAAG,CAAE,CAAChB,CAAC,EAACE,CAAC,KAAGe,CAAC,CAACb,CAAC,EAACJ,CAAC,EAACE,CAAC,EAACI,CAAC,CAAE,CAAC;EAAC,CAAC;AAAA;AAAC,eAAeW,CAACA,CAACjB,CAAC,EAACE,CAAC,EAACG,CAAC,EAACY,CAAC,EAAC;EAAC,MAAMX,CAAC,GAAC,MAAMF,CAAC,CAACF,CAAC,EAAC;IAACgB,IAAI,EAAC,GAAGb,CAAC,EAAE;IAACc,aAAa,EAACnB,CAAC;IAACoB,QAAQ,EAACH;EAAC,CAAC,CAAC;EAAC,OAAM;IAACI,QAAQ,EAACnB,CAAC,CAACmB,QAAQ;IAACC,QAAQ,EAACpB,CAAC,CAACoB,QAAQ;IAACC,UAAU,EAACrB,CAAC,CAACsB,mBAAmB,EAAED,UAAU,IAAErB,CAAC,CAACuB,eAAe;IAACC,KAAK,EAACxB,CAAC,CAACwB,KAAK;IAACC,MAAM,EAACrB;EAAC,CAAC;AAAA;AAAC,SAAOD,CAAC,IAAIuB,wBAAwB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}