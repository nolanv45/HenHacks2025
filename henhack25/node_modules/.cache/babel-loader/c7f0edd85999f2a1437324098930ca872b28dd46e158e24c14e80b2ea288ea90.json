{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { numericHash as t } from \"../../../../../../core/string.js\";\nimport { FeatureTechniqueInstance as e } from \"./TechniqueInstance.js\";\nimport { castInstanceId as s } from \"./mesh/instanceIdUtils.js\";\nclass n {\n  constructor() {\n    this._instanceById = new Map();\n  }\n  destroy() {\n    this._instanceById.clear();\n  }\n  get size() {\n    return this._instanceById.size;\n  }\n  entries() {\n    return this._instanceById.entries();\n  }\n  updateStart() {\n    this._instanceByIdNext = new Map(), this._shaderCountByMesh = new Map(), this._shaderIndices = new Map();\n  }\n  updateEnd() {\n    if (!this._instanceByIdNext) throw new Error(\"InternalError: Found updateEnd call without corresponding updateStart\");\n    for (const t of this._instanceById.keys()) this._instanceByIdNext.has(t) || this._instanceById.delete(t);\n    for (const [t, e] of this._instanceByIdNext.entries()) {\n      const s = this._instanceById.get(t);\n      s ? s.setInput(e.getInput()) : this._instanceById.set(t, e);\n    }\n    this._instanceByIdNext = null, this._shaderCountByMesh = null, this._shaderIndices = null;\n  }\n  values() {\n    return this._instanceById.values();\n  }\n  ensureInstance(n, i) {\n    let r;\n    if (\"object\" == typeof i && \"optionalAttributes\" in i && \"uniforms\" in i) {\n      const t = `${n.type}.${JSON.stringify(i.optionalAttributes)}`,\n        e = t + `.${JSON.stringify(i.uniforms)}`;\n      let s = 0;\n      null != this._instanceByIdNext && (this._shaderIndices.has(e) ? s = this._shaderIndices.get(e) : (s = this._shaderCountByMesh.get(t) ?? 0, this._shaderCountByMesh.set(t, s + 1), this._shaderIndices.set(e, s))), r = t + `.${s}`;\n    } else r = `${n.type}.${JSON.stringify(i)}`;\n    const a = t(r);\n    if (this._instanceByIdNext) {\n      const t = new e(s(a), n, i);\n      return this._instanceByIdNext.set(a, t), t;\n    }\n    if (!this._instanceById.has(a)) {\n      const t = new e(s(a), n, i);\n      this._instanceById.set(a, t);\n    }\n    return this._instanceById.get(a);\n  }\n  getInstance(t) {\n    const e = this._instanceById.get(t);\n    if (null == e) throw new Error(`InternalError: Unable to get instance for ${t}`);\n    return e;\n  }\n}\nexport { n as default };","map":{"version":3,"names":["numericHash","t","FeatureTechniqueInstance","e","castInstanceId","s","n","constructor","_instanceById","Map","destroy","clear","size","entries","updateStart","_instanceByIdNext","_shaderCountByMesh","_shaderIndices","updateEnd","Error","keys","has","delete","get","setInput","getInput","set","values","ensureInstance","i","r","type","JSON","stringify","optionalAttributes","uniforms","a","getInstance","default"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/FeatureInstanceStore.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{numericHash as t}from\"../../../../../../core/string.js\";import{FeatureTechniqueInstance as e}from\"./TechniqueInstance.js\";import{castInstanceId as s}from\"./mesh/instanceIdUtils.js\";class n{constructor(){this._instanceById=new Map}destroy(){this._instanceById.clear()}get size(){return this._instanceById.size}entries(){return this._instanceById.entries()}updateStart(){this._instanceByIdNext=new Map,this._shaderCountByMesh=new Map,this._shaderIndices=new Map}updateEnd(){if(!this._instanceByIdNext)throw new Error(\"InternalError: Found updateEnd call without corresponding updateStart\");for(const t of this._instanceById.keys())this._instanceByIdNext.has(t)||this._instanceById.delete(t);for(const[t,e]of this._instanceByIdNext.entries()){const s=this._instanceById.get(t);s?s.setInput(e.getInput()):this._instanceById.set(t,e)}this._instanceByIdNext=null,this._shaderCountByMesh=null,this._shaderIndices=null}values(){return this._instanceById.values()}ensureInstance(n,i){let r;if(\"object\"==typeof i&&\"optionalAttributes\"in i&&\"uniforms\"in i){const t=`${n.type}.${JSON.stringify(i.optionalAttributes)}`,e=t+`.${JSON.stringify(i.uniforms)}`;let s=0;null!=this._instanceByIdNext&&(this._shaderIndices.has(e)?s=this._shaderIndices.get(e):(s=this._shaderCountByMesh.get(t)??0,this._shaderCountByMesh.set(t,s+1),this._shaderIndices.set(e,s))),r=t+`.${s}`}else r=`${n.type}.${JSON.stringify(i)}`;const a=t(r);if(this._instanceByIdNext){const t=new e(s(a),n,i);return this._instanceByIdNext.set(a,t),t}if(!this._instanceById.has(a)){const t=new e(s(a),n,i);this._instanceById.set(a,t)}return this._instanceById.get(a)}getInstance(t){const e=this._instanceById.get(t);if(null==e)throw new Error(`InternalError: Unable to get instance for ${t}`);return e}}export{n as default};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}