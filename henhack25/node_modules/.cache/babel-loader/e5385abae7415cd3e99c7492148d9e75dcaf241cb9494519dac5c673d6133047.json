{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/**\n * A simple class which stores a value, and triggers registered callbacks when\n * the value is changed via its setter.\n *\n * An implementor might use other observable patterns such as MobX or Redux to\n * get behavior like this. But this is a pretty minimal approach that will\n * likely work for a number of use cases.\n */\nexport class ValueNotifier {\n  get value() {\n    return this._value;\n  }\n  set value(v) {\n    this.setValue(v);\n  }\n  setValue(v, force = false) {\n    const update = force || !Object.is(v, this._value);\n    this._value = v;\n    if (update) {\n      this.updateObservers();\n    }\n  }\n  constructor(defaultValue) {\n    this.subscriptions = new Map();\n    this.updateObservers = () => {\n      for (const [callback, {\n        disposer\n      }] of this.subscriptions) {\n        callback(this._value, disposer);\n      }\n    };\n    if (defaultValue !== undefined) {\n      this.value = defaultValue;\n    }\n  }\n  addCallback(callback, consumerHost, subscribe) {\n    if (!subscribe) {\n      // just call the callback once and we're done\n      callback(this.value);\n      return;\n    }\n    if (!this.subscriptions.has(callback)) {\n      this.subscriptions.set(callback, {\n        disposer: () => {\n          this.subscriptions.delete(callback);\n        },\n        consumerHost\n      });\n    }\n    const {\n      disposer\n    } = this.subscriptions.get(callback);\n    callback(this.value, disposer);\n  }\n  clearCallbacks() {\n    this.subscriptions.clear();\n  }\n}","map":{"version":3,"names":["ValueNotifier","value","_value","v","setValue","force","update","Object","is","updateObservers","constructor","defaultValue","subscriptions","Map","callback","disposer","undefined","addCallback","consumerHost","subscribe","has","set","delete","get","clearCallbacks","clear"],"sources":["C:\\Users\\nolan\\tasks\\HenHacks2025\\henhack25\\node_modules\\@lit\\context\\src\\lib\\value-notifier.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextCallback} from './context-request-event.js';\n\n/**\n * A disposer function\n */\ntype Disposer = () => void;\n\ninterface CallbackInfo {\n  disposer: Disposer;\n  consumerHost: Element;\n}\n\n/**\n * A simple class which stores a value, and triggers registered callbacks when\n * the value is changed via its setter.\n *\n * An implementor might use other observable patterns such as MobX or Redux to\n * get behavior like this. But this is a pretty minimal approach that will\n * likely work for a number of use cases.\n */\nexport class ValueNotifier<T> {\n  protected readonly subscriptions = new Map<\n    ContextCallback<T>,\n    CallbackInfo\n  >();\n  private _value!: T;\n  get value(): T {\n    return this._value;\n  }\n  set value(v: T) {\n    this.setValue(v);\n  }\n\n  setValue(v: T, force = false) {\n    const update = force || !Object.is(v, this._value);\n    this._value = v;\n    if (update) {\n      this.updateObservers();\n    }\n  }\n\n  constructor(defaultValue?: T) {\n    if (defaultValue !== undefined) {\n      this.value = defaultValue;\n    }\n  }\n\n  updateObservers = (): void => {\n    for (const [callback, {disposer}] of this.subscriptions) {\n      callback(this._value, disposer);\n    }\n  };\n\n  addCallback(\n    callback: ContextCallback<T>,\n    consumerHost: Element,\n    subscribe?: boolean\n  ): void {\n    if (!subscribe) {\n      // just call the callback once and we're done\n      callback(this.value);\n      return;\n    }\n    if (!this.subscriptions.has(callback)) {\n      this.subscriptions.set(callback, {\n        disposer: () => {\n          this.subscriptions.delete(callback);\n        },\n        consumerHost,\n      });\n    }\n    const {disposer} = this.subscriptions.get(callback)!;\n    callback(this.value, disposer);\n  }\n\n  clearCallbacks(): void {\n    this.subscriptions.clear();\n  }\n}\n"],"mappings":"AAAA;;;;;AAkBA;;;;;;;;AAQA,OAAM,MAAOA,aAAa;EAMxB,IAAIC,KAAKA,CAAA;IACP,OAAO,IAAI,CAACC,MAAM;EACpB;EACA,IAAID,KAAKA,CAACE,CAAI;IACZ,IAAI,CAACC,QAAQ,CAACD,CAAC,CAAC;EAClB;EAEAC,QAAQA,CAACD,CAAI,EAAEE,KAAK,GAAG,KAAK;IAC1B,MAAMC,MAAM,GAAGD,KAAK,IAAI,CAACE,MAAM,CAACC,EAAE,CAACL,CAAC,EAAE,IAAI,CAACD,MAAM,CAAC;IAClD,IAAI,CAACA,MAAM,GAAGC,CAAC;IACf,IAAIG,MAAM,EAAE;MACV,IAAI,CAACG,eAAe,EAAE;IACxB;EACF;EAEAC,YAAYC,YAAgB;IApBT,KAAAC,aAAa,GAAG,IAAIC,GAAG,EAGvC;IAuBH,KAAAJ,eAAe,GAAG,MAAW;MAC3B,KAAK,MAAM,CAACK,QAAQ,EAAE;QAACC;MAAQ,CAAC,CAAC,IAAI,IAAI,CAACH,aAAa,EAAE;QACvDE,QAAQ,CAAC,IAAI,CAACZ,MAAM,EAAEa,QAAQ,CAAC;MACjC;IACF,CAAC;IATC,IAAIJ,YAAY,KAAKK,SAAS,EAAE;MAC9B,IAAI,CAACf,KAAK,GAAGU,YAAY;IAC3B;EACF;EAQAM,WAAWA,CACTH,QAA4B,EAC5BI,YAAqB,EACrBC,SAAmB;IAEnB,IAAI,CAACA,SAAS,EAAE;MACd;MACAL,QAAQ,CAAC,IAAI,CAACb,KAAK,CAAC;MACpB;IACF;IACA,IAAI,CAAC,IAAI,CAACW,aAAa,CAACQ,GAAG,CAACN,QAAQ,CAAC,EAAE;MACrC,IAAI,CAACF,aAAa,CAACS,GAAG,CAACP,QAAQ,EAAE;QAC/BC,QAAQ,EAAEA,CAAA,KAAK;UACb,IAAI,CAACH,aAAa,CAACU,MAAM,CAACR,QAAQ,CAAC;QACrC,CAAC;QACDI;OACD,CAAC;IACJ;IACA,MAAM;MAACH;IAAQ,CAAC,GAAG,IAAI,CAACH,aAAa,CAACW,GAAG,CAACT,QAAQ,CAAE;IACpDA,QAAQ,CAAC,IAAI,CAACb,KAAK,EAAEc,QAAQ,CAAC;EAChC;EAEAS,cAAcA,CAAA;IACZ,IAAI,CAACZ,aAAa,CAACa,KAAK,EAAE;EAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}