{"ast":null,"code":"import { isContainingBlock } from '@floating-ui/utils/dom';\nfunction offsetParent(element) {\n  return offsetParentPolyfill(element);\n}\nfunction offsetTop(element) {\n  return offsetTopLeftPolyfill(element, 'offsetTop');\n}\nfunction offsetLeft(element) {\n  return offsetTopLeftPolyfill(element, 'offsetLeft');\n}\nfunction flatTreeParent(element) {\n  if (element.assignedSlot) {\n    return element.assignedSlot;\n  }\n  if (element.parentNode instanceof ShadowRoot) {\n    return element.parentNode.host;\n  }\n  return element.parentNode;\n}\nfunction ancestorTreeScopes(element) {\n  const scopes = new Set();\n  let currentScope = element.getRootNode();\n  while (currentScope) {\n    scopes.add(currentScope);\n    currentScope = currentScope.parentNode ? currentScope.parentNode.getRootNode() : null;\n  }\n  return scopes;\n}\nfunction offsetParentPolyfill(element) {\n  // Do an initial walk to check for display:none ancestors.\n  for (let ancestor = element; ancestor; ancestor = flatTreeParent(ancestor)) {\n    if (!(ancestor instanceof Element)) {\n      continue;\n    }\n    if (getComputedStyle(ancestor).display === 'none') {\n      return null;\n    }\n  }\n  for (let ancestor = flatTreeParent(element); ancestor; ancestor = flatTreeParent(ancestor)) {\n    if (!(ancestor instanceof Element)) {\n      continue;\n    }\n    const style = getComputedStyle(ancestor);\n    // Display:contents nodes aren't in the layout tree, so they should be skipped.\n    if (style.display === 'contents') {\n      continue;\n    }\n    if (style.position !== 'static' || isContainingBlock(style)) {\n      return ancestor;\n    }\n    if (ancestor.tagName === 'BODY') {\n      return ancestor;\n    }\n  }\n  return null;\n}\nfunction offsetTopLeftPolyfill(element, offsetTopOrLeft) {\n  let value = element[offsetTopOrLeft];\n  let nextOffsetParent = offsetParentPolyfill(element);\n  const scopes = ancestorTreeScopes(element);\n  while (nextOffsetParent && !scopes.has(nextOffsetParent.getRootNode())) {\n    value -= nextOffsetParent[offsetTopOrLeft];\n    nextOffsetParent = offsetParentPolyfill(nextOffsetParent);\n  }\n  return value;\n}\nexport { offsetLeft, offsetParent, offsetTop };","map":{"version":3,"names":["isContainingBlock","offsetParent","element","offsetParentPolyfill","offsetTop","offsetTopLeftPolyfill","offsetLeft","flatTreeParent","assignedSlot","parentNode","ShadowRoot","host","ancestorTreeScopes","scopes","Set","currentScope","getRootNode","add","ancestor","Element","getComputedStyle","display","style","position","tagName","offsetTopOrLeft","value","nextOffsetParent","has"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/composed-offset-position/dist/composed-offset-position.browser.mjs"],"sourcesContent":["import { isContainingBlock } from '@floating-ui/utils/dom';\n\nfunction offsetParent(element) {\n    return offsetParentPolyfill(element);\n}\nfunction offsetTop(element) {\n    return offsetTopLeftPolyfill(element, 'offsetTop');\n}\nfunction offsetLeft(element) {\n    return offsetTopLeftPolyfill(element, 'offsetLeft');\n}\nfunction flatTreeParent(element) {\n    if (element.assignedSlot) {\n        return element.assignedSlot;\n    }\n    if (element.parentNode instanceof ShadowRoot) {\n        return element.parentNode.host;\n    }\n    return element.parentNode;\n}\nfunction ancestorTreeScopes(element) {\n    const scopes = new Set();\n    let currentScope = element.getRootNode();\n    while (currentScope) {\n        scopes.add(currentScope);\n        currentScope = currentScope.parentNode\n            ? currentScope.parentNode.getRootNode()\n            : null;\n    }\n    return scopes;\n}\nfunction offsetParentPolyfill(element) {\n    // Do an initial walk to check for display:none ancestors.\n    for (let ancestor = element; ancestor; ancestor = flatTreeParent(ancestor)) {\n        if (!(ancestor instanceof Element)) {\n            continue;\n        }\n        if (getComputedStyle(ancestor).display === 'none') {\n            return null;\n        }\n    }\n    for (let ancestor = flatTreeParent(element); ancestor; ancestor = flatTreeParent(ancestor)) {\n        if (!(ancestor instanceof Element)) {\n            continue;\n        }\n        const style = getComputedStyle(ancestor);\n        // Display:contents nodes aren't in the layout tree, so they should be skipped.\n        if (style.display === 'contents') {\n            continue;\n        }\n        if (style.position !== 'static' || isContainingBlock(style)) {\n            return ancestor;\n        }\n        if (ancestor.tagName === 'BODY') {\n            return ancestor;\n        }\n    }\n    return null;\n}\nfunction offsetTopLeftPolyfill(element, offsetTopOrLeft) {\n    let value = element[offsetTopOrLeft];\n    let nextOffsetParent = offsetParentPolyfill(element);\n    const scopes = ancestorTreeScopes(element);\n    while (nextOffsetParent && !scopes.has(nextOffsetParent.getRootNode())) {\n        value -= nextOffsetParent[offsetTopOrLeft];\n        nextOffsetParent = offsetParentPolyfill(nextOffsetParent);\n    }\n    return value;\n}\n\nexport { offsetLeft, offsetParent, offsetTop };\n"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,wBAAwB;AAE1D,SAASC,YAAYA,CAACC,OAAO,EAAE;EAC3B,OAAOC,oBAAoB,CAACD,OAAO,CAAC;AACxC;AACA,SAASE,SAASA,CAACF,OAAO,EAAE;EACxB,OAAOG,qBAAqB,CAACH,OAAO,EAAE,WAAW,CAAC;AACtD;AACA,SAASI,UAAUA,CAACJ,OAAO,EAAE;EACzB,OAAOG,qBAAqB,CAACH,OAAO,EAAE,YAAY,CAAC;AACvD;AACA,SAASK,cAAcA,CAACL,OAAO,EAAE;EAC7B,IAAIA,OAAO,CAACM,YAAY,EAAE;IACtB,OAAON,OAAO,CAACM,YAAY;EAC/B;EACA,IAAIN,OAAO,CAACO,UAAU,YAAYC,UAAU,EAAE;IAC1C,OAAOR,OAAO,CAACO,UAAU,CAACE,IAAI;EAClC;EACA,OAAOT,OAAO,CAACO,UAAU;AAC7B;AACA,SAASG,kBAAkBA,CAACV,OAAO,EAAE;EACjC,MAAMW,MAAM,GAAG,IAAIC,GAAG,CAAC,CAAC;EACxB,IAAIC,YAAY,GAAGb,OAAO,CAACc,WAAW,CAAC,CAAC;EACxC,OAAOD,YAAY,EAAE;IACjBF,MAAM,CAACI,GAAG,CAACF,YAAY,CAAC;IACxBA,YAAY,GAAGA,YAAY,CAACN,UAAU,GAChCM,YAAY,CAACN,UAAU,CAACO,WAAW,CAAC,CAAC,GACrC,IAAI;EACd;EACA,OAAOH,MAAM;AACjB;AACA,SAASV,oBAAoBA,CAACD,OAAO,EAAE;EACnC;EACA,KAAK,IAAIgB,QAAQ,GAAGhB,OAAO,EAAEgB,QAAQ,EAAEA,QAAQ,GAAGX,cAAc,CAACW,QAAQ,CAAC,EAAE;IACxE,IAAI,EAAEA,QAAQ,YAAYC,OAAO,CAAC,EAAE;MAChC;IACJ;IACA,IAAIC,gBAAgB,CAACF,QAAQ,CAAC,CAACG,OAAO,KAAK,MAAM,EAAE;MAC/C,OAAO,IAAI;IACf;EACJ;EACA,KAAK,IAAIH,QAAQ,GAAGX,cAAc,CAACL,OAAO,CAAC,EAAEgB,QAAQ,EAAEA,QAAQ,GAAGX,cAAc,CAACW,QAAQ,CAAC,EAAE;IACxF,IAAI,EAAEA,QAAQ,YAAYC,OAAO,CAAC,EAAE;MAChC;IACJ;IACA,MAAMG,KAAK,GAAGF,gBAAgB,CAACF,QAAQ,CAAC;IACxC;IACA,IAAII,KAAK,CAACD,OAAO,KAAK,UAAU,EAAE;MAC9B;IACJ;IACA,IAAIC,KAAK,CAACC,QAAQ,KAAK,QAAQ,IAAIvB,iBAAiB,CAACsB,KAAK,CAAC,EAAE;MACzD,OAAOJ,QAAQ;IACnB;IACA,IAAIA,QAAQ,CAACM,OAAO,KAAK,MAAM,EAAE;MAC7B,OAAON,QAAQ;IACnB;EACJ;EACA,OAAO,IAAI;AACf;AACA,SAASb,qBAAqBA,CAACH,OAAO,EAAEuB,eAAe,EAAE;EACrD,IAAIC,KAAK,GAAGxB,OAAO,CAACuB,eAAe,CAAC;EACpC,IAAIE,gBAAgB,GAAGxB,oBAAoB,CAACD,OAAO,CAAC;EACpD,MAAMW,MAAM,GAAGD,kBAAkB,CAACV,OAAO,CAAC;EAC1C,OAAOyB,gBAAgB,IAAI,CAACd,MAAM,CAACe,GAAG,CAACD,gBAAgB,CAACX,WAAW,CAAC,CAAC,CAAC,EAAE;IACpEU,KAAK,IAAIC,gBAAgB,CAACF,eAAe,CAAC;IAC1CE,gBAAgB,GAAGxB,oBAAoB,CAACwB,gBAAgB,CAAC;EAC7D;EACA,OAAOD,KAAK;AAChB;AAEA,SAASpB,UAAU,EAAEL,YAAY,EAAEG,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}