{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { markerTextureSize as e, markerSymbolSize as r, markerTipThicknessFactor as i } from \"../views/3d/support/engineContent/marker.js\";\nimport { SliceDraw as o } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { RibbonVertexPosition as t } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";\nimport { OutputHighlight as a } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";\nimport { MarkerSizing as n } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MarkerSizing.glsl.js\";\nimport { terrainDepthTest as s } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js\";\nimport { ColorConversion as c } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { RgbaFloatEncoding as l } from \"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";\nimport { addProjViewLocalOrigin as p, addViewNormal as d, addPixelRatio as v } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float2BindUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";\nimport { Float4BindUniform as h } from \"../views/3d/webgl-engine/core/shaderModules/Float4BindUniform.js\";\nimport { Float4PassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatBindUniform as g } from \"../views/3d/webgl-engine/core/shaderModules/FloatBindUniform.js\";\nimport { glsl as u, If as w } from \"../views/3d/webgl-engine/core/shaderModules/glsl.js\";\nimport { Matrix4BindUniform as y } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4BindUniform.js\";\nimport { Texture2DPassUniform as S } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nimport { VertexAttribute as b } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { LineMarkerSpace as x, LineMarkerAnchor as P } from \"../views/3d/webgl-engine/shaders/LineMarkerTechniqueConfiguration.js\";\nimport { outputColorHighlightOID as z } from \"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js\";\nimport { ShaderBuilder as j } from \"../views/webgl/ShaderBuilder.js\";\nfunction L(L) {\n  const k = new j(),\n    {\n      space: M,\n      anchor: C,\n      hasTip: D\n    } = L,\n    O = M === x.World;\n  k.include(t, L), k.include(n, L), k.include(s, L);\n  const {\n    vertex: $,\n    fragment: T\n  } = k;\n  T.include(l), p($, L), k.attributes.add(b.POSITION, \"vec3\"), k.attributes.add(b.PREVPOSITION, \"vec3\"), k.attributes.add(b.UV0, \"vec2\"), k.varyings.add(\"vColor\", \"vec4\"), k.varyings.add(\"vpos\", \"vec3\"), k.varyings.add(\"vUV\", \"vec2\"), k.varyings.add(\"vSize\", \"float\"), D && k.varyings.add(\"vLineWidth\", \"float\"), $.uniforms.add(new m(\"nearFar\", ({\n    camera: e\n  }) => e.nearFar), new h(\"viewport\", ({\n    camera: e\n  }) => e.fullViewport)), $.code.add(u`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`), $.code.add(u`void clip(vec4 pos, inout vec4 prev) {\nfloat vnp = nearFar[0] * 0.99;\nif (prev.z > -nearFar[0]) {\nfloat interpolation = (-vnp - pos.z) / (prev.z - pos.z);\nprev = mix(pos, prev, interpolation);\n}\n}`), O ? (k.attributes.add(b.NORMAL, \"vec3\"), d($), $.constants.add(\"tiltThreshold\", \"float\", .7), $.code.add(u`vec3 perpendicular(vec3 v) {\nvec3 n = (viewNormal * vec4(normal.xyz, 1.0)).xyz;\nvec3 n2 = cross(v, n);\nvec3 forward = vec3(0.0, 0.0, 1.0);\nfloat tiltDot = dot(forward, n);\nreturn abs(tiltDot) < tiltThreshold ? n : n2;\n}`)) : $.code.add(u`vec2 perpendicular(vec2 v) {\nreturn vec2(v.y, -v.x);\n}`);\n  const W = O ? \"vec3\" : \"vec2\";\n  return $.code.add(u`\n      ${W} normalizedSegment(${W} pos, ${W} prev) {\n        ${W} segment = pos - prev;\n        float segmentLen = length(segment);\n\n        // normalize or zero if too short\n        return (segmentLen > 0.001) ? segment / segmentLen : ${O ? \"vec3(0.0, 0.0, 0.0)\" : \"vec2(0.0, 0.0)\"};\n      }\n\n      ${W} displace(${W} pos, ${W} prev, float displacementLen) {\n        ${W} segment = normalizedSegment(pos, prev);\n\n        ${W} displacementDirU = perpendicular(segment);\n        ${W} displacementDirV = segment;\n\n        ${C === P.Tip ? \"pos -= 0.5 * displacementLen * displacementDirV;\" : \"\"}\n\n        return pos + displacementLen * (uv0.x * displacementDirU + uv0.y * displacementDirV);\n      }\n    `), M === x.Screen && ($.uniforms.add(new y(\"inverseProjectionMatrix\", ({\n    camera: e\n  }) => e.inverseProjectionMatrix)), $.code.add(u`vec3 inverseProject(vec4 posScreen) {\nposScreen.xy = (posScreen.xy / viewport.zw) * posScreen.w;\nreturn (inverseProjectionMatrix * posScreen).xyz;\n}`), $.code.add(u`bool rayIntersectPlane(vec3 rayDir, vec3 planeOrigin, vec3 planeNormal, out vec3 intersection) {\nfloat cos = dot(rayDir, planeNormal);\nfloat t = dot(planeOrigin, planeNormal) / cos;\nintersection = t * rayDir;\nreturn abs(cos) > 0.001 && t > 0.0;\n}`), $.uniforms.add(new g(\"perScreenPixelRatio\", ({\n    camera: e\n  }) => e.perScreenPixelRatio)), $.code.add(u`\n      vec4 toFront(vec4 displacedPosScreen, vec3 posLeft, vec3 posRight, vec3 prev, float lineWidth) {\n        // Project displaced position back to camera space\n        vec3 displacedPos = inverseProject(displacedPosScreen);\n\n        // Calculate the plane that we want the marker to lie in. Note that this will always be an approximation since ribbon lines are generally\n        // not planar and we do not know the actual position of the displaced prev vertices (they are offset in screen space, too).\n        vec3 planeNormal = normalize(cross(posLeft - posRight, posLeft - prev));\n        vec3 planeOrigin = posLeft;\n\n        ${w(L.hasCap, \"if(prev.z > posLeft.z) {\\n                vec2 diff = posLeft.xy - posRight.xy;\\n                planeOrigin.xy += perpendicular(diff) / 2.0;\\n             }\")};\n\n        // Move the plane towards the camera by a margin dependent on the line width (approximated in world space). This tolerance corrects for the\n        // non-planarity in most cases, but sharp joins can place the prev vertices at arbitrary positions so markers can still clip.\n        float offset = lineWidth * perScreenPixelRatio;\n        planeOrigin *= (1.0 - offset);\n\n        // Intersect camera ray with the plane and make sure it is within clip space\n        vec3 rayDir = normalize(displacedPos);\n        vec3 intersection;\n        if (rayIntersectPlane(rayDir, planeOrigin, planeNormal, intersection) && intersection.z < -nearFar[0] && intersection.z > -nearFar[1]) {\n          return vec4(intersection.xyz, 1.0);\n        }\n\n        // Fallback: use depth of pos or prev, whichever is closer to the camera\n        float minDepth = planeOrigin.z > prev.z ? length(planeOrigin) : length(prev);\n        displacedPos *= minDepth / length(displacedPos);\n        return vec4(displacedPos.xyz, 1.0);\n      }\n  `)), v($), $.main.add(u`\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      float lineWidth = getLineWidth();\n      float screenMarkerSize = getScreenMarkerSize();\n\n      vec4 pos  = view * vec4(position, 1.0);\n      vec4 prev = view * vec4(prevPosition, 1.0);\n      clip(pos, prev);\n\n      ${O ? u`${w(L.hideOnShortSegments, u`\n                if (areWorldMarkersHidden(pos, prev)) {\n                  // Project out of clip space\n                  gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n                  return;\n                }`)}\n            pos.xyz = displace(pos.xyz, prev.xyz, getWorldMarkerSize(pos));\n            vec4 displacedPosScreen = projectAndScale(pos);` : u`\n            vec4 posScreen = projectAndScale(pos);\n            vec4 prevScreen = projectAndScale(prev);\n            vec4 displacedPosScreen = posScreen;\n\n            displacedPosScreen.xy = displace(posScreen.xy, prevScreen.xy, screenMarkerSize);\n            ${w(M === x.Screen, u`\n                vec2 displacementDirU = perpendicular(normalizedSegment(posScreen.xy, prevScreen.xy));\n\n                // We need three points of the ribbon line in camera space to calculate the plane it lies in\n                // Note that we approximate the third point, since we have no information about the join around prev\n                vec3 lineRight = inverseProject(posScreen + lineWidth * vec4(displacementDirU.xy, 0.0, 0.0));\n                vec3 lineLeft = pos.xyz + (pos.xyz - lineRight);\n\n                pos = toFront(displacedPosScreen, lineLeft, lineRight, prev.xyz, lineWidth);\n                displacedPosScreen = projectAndScale(pos);`)}`}\n      forwardViewPosDepth(pos.xyz);\n      // Convert back into NDC\n      displacedPosScreen.xy = (displacedPosScreen.xy / viewport.zw) * displacedPosScreen.w;\n\n      // Convert texture coordinate into [0,1]\n      vUV = (uv0 + 1.0) / 2.0;\n      ${w(!O, \"vUV *= displacedPosScreen.w;\")}\n      ${w(D, \"vLineWidth = lineWidth;\")}\n\n      vSize = screenMarkerSize;\n      vColor = getColor();\n\n      // Use camera space for slicing\n      vpos = pos.xyz;\n\n      gl_Position = displacedPosScreen;\n    }`), k.fragment.include(o, L), k.include(z, L), T.uniforms.add(new f(\"intrinsicColor\", e => e.color), new S(\"tex\", e => e.markerTexture)), T.include(c), T.constants.add(\"texelSize\", \"float\", 1 / e), T.code.add(u`float markerAlpha(vec2 samplePos) {\nsamplePos += vec2(0.5, -0.5) * texelSize;\nfloat sdf = rgbaTofloat(texture(tex, samplePos)) - 0.5;\nfloat distance = sdf * vSize;\ndistance -= 0.5;\nreturn clamp(0.5 - distance, 0.0, 1.0);\n}`), D && T.constants.add(\"relativeMarkerSize\", \"float\", r / e).constants.add(\"relativeTipLineWidth\", \"float\", i).code.add(u`\n    float tipAlpha(vec2 samplePos) {\n      // Convert coordinates s.t. they are in pixels and relative to the tip of an arrow marker\n      samplePos -= vec2(0.5, 0.5 + 0.5 * relativeMarkerSize);\n      samplePos *= vSize;\n\n      float halfMarkerSize = 0.5 * relativeMarkerSize * vSize;\n      float halfTipLineWidth = 0.5 * max(1.0, relativeTipLineWidth * vLineWidth);\n\n      ${w(O, \"halfTipLineWidth *= fwidth(samplePos.y);\")}\n\n      float distance = max(abs(samplePos.x) - halfMarkerSize, abs(samplePos.y) - halfTipLineWidth);\n      return clamp(0.5 - distance, 0.0, 1.0);\n    }\n  `), k.include(a, L), T.main.add(u`\n    discardBySlice(vpos);\n    discardByTerrainDepth();\n\n    vec4 finalColor = intrinsicColor * vColor;\n\n    // Cancel out perspective correct interpolation if in screen space or draped\n    vec2 samplePos = vUV ${w(!O, \"* gl_FragCoord.w\")};\n    finalColor.a *= ${D ? \"max(markerAlpha(samplePos), tipAlpha(samplePos))\" : \"markerAlpha(samplePos)\"};\n    outputColorHighlightOID(finalColor, vpos);`), k;\n}\nconst k = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: L\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { k as L, L as b };","map":{"version":3,"names":["markerTextureSize","e","markerSymbolSize","r","markerTipThicknessFactor","i","SliceDraw","o","RibbonVertexPosition","t","OutputHighlight","a","MarkerSizing","n","terrainDepthTest","s","ColorConversion","c","RgbaFloatEncoding","l","addProjViewLocalOrigin","p","addViewNormal","d","addPixelRatio","v","Float2BindUniform","m","Float4BindUniform","h","Float4PassUniform","f","FloatBindUniform","g","glsl","u","If","w","Matrix4BindUniform","y","Texture2DPassUniform","S","VertexAttribute","b","LineMarkerSpace","x","LineMarkerAnchor","P","outputColorHighlightOID","z","ShaderBuilder","j","L","k","space","M","anchor","C","hasTip","D","O","World","include","vertex","$","fragment","T","attributes","add","POSITION","PREVPOSITION","UV0","varyings","uniforms","camera","nearFar","fullViewport","code","NORMAL","constants","W","Tip","Screen","inverseProjectionMatrix","perScreenPixelRatio","hasCap","main","hideOnShortSegments","color","markerTexture","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/chunks/LineMarker.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{markerTextureSize as e,markerSymbolSize as r,markerTipThicknessFactor as i}from\"../views/3d/support/engineContent/marker.js\";import{SliceDraw as o}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{RibbonVertexPosition as t}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";import{OutputHighlight as a}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";import{MarkerSizing as n}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MarkerSizing.glsl.js\";import{terrainDepthTest as s}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js\";import{ColorConversion as c}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{RgbaFloatEncoding as l}from\"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";import{addProjViewLocalOrigin as p,addViewNormal as d,addPixelRatio as v}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float2BindUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";import{Float4BindUniform as h}from\"../views/3d/webgl-engine/core/shaderModules/Float4BindUniform.js\";import{Float4PassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatBindUniform as g}from\"../views/3d/webgl-engine/core/shaderModules/FloatBindUniform.js\";import{glsl as u,If as w}from\"../views/3d/webgl-engine/core/shaderModules/glsl.js\";import{Matrix4BindUniform as y}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4BindUniform.js\";import{Texture2DPassUniform as S}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";import{VertexAttribute as b}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{LineMarkerSpace as x,LineMarkerAnchor as P}from\"../views/3d/webgl-engine/shaders/LineMarkerTechniqueConfiguration.js\";import{outputColorHighlightOID as z}from\"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js\";import{ShaderBuilder as j}from\"../views/webgl/ShaderBuilder.js\";function L(L){const k=new j,{space:M,anchor:C,hasTip:D}=L,O=M===x.World;k.include(t,L),k.include(n,L),k.include(s,L);const{vertex:$,fragment:T}=k;T.include(l),p($,L),k.attributes.add(b.POSITION,\"vec3\"),k.attributes.add(b.PREVPOSITION,\"vec3\"),k.attributes.add(b.UV0,\"vec2\"),k.varyings.add(\"vColor\",\"vec4\"),k.varyings.add(\"vpos\",\"vec3\"),k.varyings.add(\"vUV\",\"vec2\"),k.varyings.add(\"vSize\",\"float\"),D&&k.varyings.add(\"vLineWidth\",\"float\"),$.uniforms.add(new m(\"nearFar\",(({camera:e})=>e.nearFar)),new h(\"viewport\",(({camera:e})=>e.fullViewport))),$.code.add(u`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`),$.code.add(u`void clip(vec4 pos, inout vec4 prev) {\nfloat vnp = nearFar[0] * 0.99;\nif (prev.z > -nearFar[0]) {\nfloat interpolation = (-vnp - pos.z) / (prev.z - pos.z);\nprev = mix(pos, prev, interpolation);\n}\n}`),O?(k.attributes.add(b.NORMAL,\"vec3\"),d($),$.constants.add(\"tiltThreshold\",\"float\",.7),$.code.add(u`vec3 perpendicular(vec3 v) {\nvec3 n = (viewNormal * vec4(normal.xyz, 1.0)).xyz;\nvec3 n2 = cross(v, n);\nvec3 forward = vec3(0.0, 0.0, 1.0);\nfloat tiltDot = dot(forward, n);\nreturn abs(tiltDot) < tiltThreshold ? n : n2;\n}`)):$.code.add(u`vec2 perpendicular(vec2 v) {\nreturn vec2(v.y, -v.x);\n}`);const W=O?\"vec3\":\"vec2\";return $.code.add(u`\n      ${W} normalizedSegment(${W} pos, ${W} prev) {\n        ${W} segment = pos - prev;\n        float segmentLen = length(segment);\n\n        // normalize or zero if too short\n        return (segmentLen > 0.001) ? segment / segmentLen : ${O?\"vec3(0.0, 0.0, 0.0)\":\"vec2(0.0, 0.0)\"};\n      }\n\n      ${W} displace(${W} pos, ${W} prev, float displacementLen) {\n        ${W} segment = normalizedSegment(pos, prev);\n\n        ${W} displacementDirU = perpendicular(segment);\n        ${W} displacementDirV = segment;\n\n        ${C===P.Tip?\"pos -= 0.5 * displacementLen * displacementDirV;\":\"\"}\n\n        return pos + displacementLen * (uv0.x * displacementDirU + uv0.y * displacementDirV);\n      }\n    `),M===x.Screen&&($.uniforms.add(new y(\"inverseProjectionMatrix\",(({camera:e})=>e.inverseProjectionMatrix))),$.code.add(u`vec3 inverseProject(vec4 posScreen) {\nposScreen.xy = (posScreen.xy / viewport.zw) * posScreen.w;\nreturn (inverseProjectionMatrix * posScreen).xyz;\n}`),$.code.add(u`bool rayIntersectPlane(vec3 rayDir, vec3 planeOrigin, vec3 planeNormal, out vec3 intersection) {\nfloat cos = dot(rayDir, planeNormal);\nfloat t = dot(planeOrigin, planeNormal) / cos;\nintersection = t * rayDir;\nreturn abs(cos) > 0.001 && t > 0.0;\n}`),$.uniforms.add(new g(\"perScreenPixelRatio\",(({camera:e})=>e.perScreenPixelRatio))),$.code.add(u`\n      vec4 toFront(vec4 displacedPosScreen, vec3 posLeft, vec3 posRight, vec3 prev, float lineWidth) {\n        // Project displaced position back to camera space\n        vec3 displacedPos = inverseProject(displacedPosScreen);\n\n        // Calculate the plane that we want the marker to lie in. Note that this will always be an approximation since ribbon lines are generally\n        // not planar and we do not know the actual position of the displaced prev vertices (they are offset in screen space, too).\n        vec3 planeNormal = normalize(cross(posLeft - posRight, posLeft - prev));\n        vec3 planeOrigin = posLeft;\n\n        ${w(L.hasCap,\"if(prev.z > posLeft.z) {\\n                vec2 diff = posLeft.xy - posRight.xy;\\n                planeOrigin.xy += perpendicular(diff) / 2.0;\\n             }\")};\n\n        // Move the plane towards the camera by a margin dependent on the line width (approximated in world space). This tolerance corrects for the\n        // non-planarity in most cases, but sharp joins can place the prev vertices at arbitrary positions so markers can still clip.\n        float offset = lineWidth * perScreenPixelRatio;\n        planeOrigin *= (1.0 - offset);\n\n        // Intersect camera ray with the plane and make sure it is within clip space\n        vec3 rayDir = normalize(displacedPos);\n        vec3 intersection;\n        if (rayIntersectPlane(rayDir, planeOrigin, planeNormal, intersection) && intersection.z < -nearFar[0] && intersection.z > -nearFar[1]) {\n          return vec4(intersection.xyz, 1.0);\n        }\n\n        // Fallback: use depth of pos or prev, whichever is closer to the camera\n        float minDepth = planeOrigin.z > prev.z ? length(planeOrigin) : length(prev);\n        displacedPos *= minDepth / length(displacedPos);\n        return vec4(displacedPos.xyz, 1.0);\n      }\n  `)),v($),$.main.add(u`\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      float lineWidth = getLineWidth();\n      float screenMarkerSize = getScreenMarkerSize();\n\n      vec4 pos  = view * vec4(position, 1.0);\n      vec4 prev = view * vec4(prevPosition, 1.0);\n      clip(pos, prev);\n\n      ${O?u`${w(L.hideOnShortSegments,u`\n                if (areWorldMarkersHidden(pos, prev)) {\n                  // Project out of clip space\n                  gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n                  return;\n                }`)}\n            pos.xyz = displace(pos.xyz, prev.xyz, getWorldMarkerSize(pos));\n            vec4 displacedPosScreen = projectAndScale(pos);`:u`\n            vec4 posScreen = projectAndScale(pos);\n            vec4 prevScreen = projectAndScale(prev);\n            vec4 displacedPosScreen = posScreen;\n\n            displacedPosScreen.xy = displace(posScreen.xy, prevScreen.xy, screenMarkerSize);\n            ${w(M===x.Screen,u`\n                vec2 displacementDirU = perpendicular(normalizedSegment(posScreen.xy, prevScreen.xy));\n\n                // We need three points of the ribbon line in camera space to calculate the plane it lies in\n                // Note that we approximate the third point, since we have no information about the join around prev\n                vec3 lineRight = inverseProject(posScreen + lineWidth * vec4(displacementDirU.xy, 0.0, 0.0));\n                vec3 lineLeft = pos.xyz + (pos.xyz - lineRight);\n\n                pos = toFront(displacedPosScreen, lineLeft, lineRight, prev.xyz, lineWidth);\n                displacedPosScreen = projectAndScale(pos);`)}`}\n      forwardViewPosDepth(pos.xyz);\n      // Convert back into NDC\n      displacedPosScreen.xy = (displacedPosScreen.xy / viewport.zw) * displacedPosScreen.w;\n\n      // Convert texture coordinate into [0,1]\n      vUV = (uv0 + 1.0) / 2.0;\n      ${w(!O,\"vUV *= displacedPosScreen.w;\")}\n      ${w(D,\"vLineWidth = lineWidth;\")}\n\n      vSize = screenMarkerSize;\n      vColor = getColor();\n\n      // Use camera space for slicing\n      vpos = pos.xyz;\n\n      gl_Position = displacedPosScreen;\n    }`),k.fragment.include(o,L),k.include(z,L),T.uniforms.add(new f(\"intrinsicColor\",(e=>e.color)),new S(\"tex\",(e=>e.markerTexture))),T.include(c),T.constants.add(\"texelSize\",\"float\",1/e),T.code.add(u`float markerAlpha(vec2 samplePos) {\nsamplePos += vec2(0.5, -0.5) * texelSize;\nfloat sdf = rgbaTofloat(texture(tex, samplePos)) - 0.5;\nfloat distance = sdf * vSize;\ndistance -= 0.5;\nreturn clamp(0.5 - distance, 0.0, 1.0);\n}`),D&&T.constants.add(\"relativeMarkerSize\",\"float\",r/e).constants.add(\"relativeTipLineWidth\",\"float\",i).code.add(u`\n    float tipAlpha(vec2 samplePos) {\n      // Convert coordinates s.t. they are in pixels and relative to the tip of an arrow marker\n      samplePos -= vec2(0.5, 0.5 + 0.5 * relativeMarkerSize);\n      samplePos *= vSize;\n\n      float halfMarkerSize = 0.5 * relativeMarkerSize * vSize;\n      float halfTipLineWidth = 0.5 * max(1.0, relativeTipLineWidth * vLineWidth);\n\n      ${w(O,\"halfTipLineWidth *= fwidth(samplePos.y);\")}\n\n      float distance = max(abs(samplePos.x) - halfMarkerSize, abs(samplePos.y) - halfTipLineWidth);\n      return clamp(0.5 - distance, 0.0, 1.0);\n    }\n  `),k.include(a,L),T.main.add(u`\n    discardBySlice(vpos);\n    discardByTerrainDepth();\n\n    vec4 finalColor = intrinsicColor * vColor;\n\n    // Cancel out perspective correct interpolation if in screen space or draped\n    vec2 samplePos = vUV ${w(!O,\"* gl_FragCoord.w\")};\n    finalColor.a *= ${D?\"max(markerAlpha(samplePos), tipAlpha(samplePos))\":\"markerAlpha(samplePos)\"};\n    outputColorHighlightOID(finalColor, vpos);`),k}const k=Object.freeze(Object.defineProperty({__proto__:null,build:L},Symbol.toStringTag,{value:\"Module\"}));export{k as L,L as b};\n"],"mappings":"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EAACpB,CAAC,CAACa,IAAI,CAACT,GAAG,CAACjC,CAAC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAUE,CAAC,CAACe,CAAC,CAACiC,MAAM,EAAC,+JAA+J,CAAC;AACrL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC,CAAC,EAAC5D,CAAC,CAACuC,CAAC,CAAC,EAACA,CAAC,CAACsB,IAAI,CAAClB,GAAG,CAACjC,CAAC;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQyB,CAAC,GAACzB,CAAC,GAAGE,CAAC,CAACe,CAAC,CAACmC,mBAAmB,EAACpD,CAAC;AACvC;AACA;AACA;AACA;AACA,kBAAkB,CAAC;AACnB;AACA,4DAA4D,GAACA,CAAC;AAC9D;AACA;AACA;AACA;AACA;AACA,cAAcE,CAAC,CAACkB,CAAC,KAAGV,CAAC,CAACqC,MAAM,EAAC/C,CAAC;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,CAAC,EAAE;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,QAAQE,CAAC,CAAC,CAACuB,CAAC,EAAC,8BAA8B,CAAC;AAC5C,QAAQvB,CAAC,CAACsB,CAAC,EAAC,yBAAyB,CAAC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,CAAC,EAACN,CAAC,CAACY,QAAQ,CAACH,OAAO,CAACvD,CAAC,EAAC6C,CAAC,CAAC,EAACC,CAAC,CAACS,OAAO,CAACb,CAAC,EAACG,CAAC,CAAC,EAACc,CAAC,CAACO,QAAQ,CAACL,GAAG,CAAC,IAAIrC,CAAC,CAAC,gBAAgB,EAAE9B,CAAC,IAAEA,CAAC,CAACuF,KAAM,CAAC,EAAC,IAAI/C,CAAC,CAAC,KAAK,EAAExC,CAAC,IAAEA,CAAC,CAACwF,aAAc,CAAC,CAAC,EAACvB,CAAC,CAACJ,OAAO,CAAC7C,CAAC,CAAC,EAACiD,CAAC,CAACa,SAAS,CAACX,GAAG,CAAC,WAAW,EAAC,OAAO,EAAC,CAAC,GAACnE,CAAC,CAAC,EAACiE,CAAC,CAACW,IAAI,CAACT,GAAG,CAACjC,CAAC;AACxM;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACwB,CAAC,IAAEO,CAAC,CAACa,SAAS,CAACX,GAAG,CAAC,oBAAoB,EAAC,OAAO,EAACjE,CAAC,GAACF,CAAC,CAAC,CAAC8E,SAAS,CAACX,GAAG,CAAC,sBAAsB,EAAC,OAAO,EAAC/D,CAAC,CAAC,CAACwE,IAAI,CAACT,GAAG,CAACjC,CAAC;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQE,CAAC,CAACuB,CAAC,EAAC,0CAA0C,CAAC;AACvD;AACA;AACA;AACA;AACA,GAAG,CAAC,EAACP,CAAC,CAACS,OAAO,CAACnD,CAAC,EAACyC,CAAC,CAAC,EAACc,CAAC,CAACoB,IAAI,CAAClB,GAAG,CAACjC,CAAC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2BE,CAAC,CAAC,CAACuB,CAAC,EAAC,kBAAkB,CAAC;AACnD,sBAAsBD,CAAC,GAAC,kDAAkD,GAAC,wBAAwB;AACnG,+CAA+C,CAAC,EAACN,CAAC;AAAA;AAAC,MAAMA,CAAC,GAACqC,MAAM,CAACC,MAAM,CAACD,MAAM,CAACE,cAAc,CAAC;EAACC,SAAS,EAAC,IAAI;EAACC,KAAK,EAAC1C;AAAC,CAAC,EAAC2C,MAAM,CAACC,WAAW,EAAC;EAACC,KAAK,EAAC;AAAQ,CAAC,CAAC,CAAC;AAAC,SAAO5C,CAAC,IAAID,CAAC,EAACA,CAAC,IAAIT,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}