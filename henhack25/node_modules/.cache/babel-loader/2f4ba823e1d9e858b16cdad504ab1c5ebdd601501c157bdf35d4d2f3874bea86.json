{"ast":null,"code":"// Derived from https://github.com/xqdoo00o/jszip/blob/master/lib/sjcl.js and https://github.com/bitwiseshiftleft/sjcl\n\n// deno-lint-ignore-file no-this-alias\n\n/*\n * SJCL is open. You can use, modify and redistribute it under a BSD\n * license or under the GNU GPL, version 2.0.\n */\n\n/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Arrays of bits, encoded as arrays of Numbers.\n * @namespace\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nconst bitArray = {\n  /**\n   * Concatenate two bit arrays.\n   * @param {bitArray} a1 The first array.\n   * @param {bitArray} a2 The second array.\n   * @return {bitArray} The concatenation of a1 and a2.\n   */\n  concat(a1, a2) {\n    if (a1.length === 0 || a2.length === 0) {\n      return a1.concat(a2);\n    }\n    const last = a1[a1.length - 1],\n      shift = bitArray.getPartial(last);\n    if (shift === 32) {\n      return a1.concat(a2);\n    } else {\n      return bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));\n    }\n  },\n  /**\n   * Find the length of an array of bits.\n   * @param {bitArray} a The array.\n   * @return {Number} The length of a, in bits.\n   */\n  bitLength(a) {\n    const l = a.length;\n    if (l === 0) {\n      return 0;\n    }\n    const x = a[l - 1];\n    return (l - 1) * 32 + bitArray.getPartial(x);\n  },\n  /**\n   * Truncate an array.\n   * @param {bitArray} a The array.\n   * @param {Number} len The length to truncate to, in bits.\n   * @return {bitArray} A new array, truncated to len bits.\n   */\n  clamp(a, len) {\n    if (a.length * 32 < len) {\n      return a;\n    }\n    a = a.slice(0, Math.ceil(len / 32));\n    const l = a.length;\n    len = len & 31;\n    if (l > 0 && len) {\n      a[l - 1] = bitArray.partial(len, a[l - 1] & 0x80000000 >> len - 1, 1);\n    }\n    return a;\n  },\n  /**\n   * Make a partial word for a bit array.\n   * @param {Number} len The number of bits in the word.\n   * @param {Number} x The bits.\n   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.\n   * @return {Number} The partial word.\n   */\n  partial(len, x, _end) {\n    if (len === 32) {\n      return x;\n    }\n    return (_end ? x | 0 : x << 32 - len) + len * 0x10000000000;\n  },\n  /**\n   * Get the number of bits used by a partial word.\n   * @param {Number} x The partial word.\n   * @return {Number} The number of bits used by the partial word.\n   */\n  getPartial(x) {\n    return Math.round(x / 0x10000000000) || 32;\n  },\n  /** Shift an array right.\n   * @param {bitArray} a The array to shift.\n   * @param {Number} shift The number of bits to shift.\n   * @param {Number} [carry=0] A byte to carry in\n   * @param {bitArray} [out=[]] An array to prepend to the output.\n   * @private\n   */\n  _shiftRight(a, shift, carry, out) {\n    if (out === undefined) {\n      out = [];\n    }\n    for (; shift >= 32; shift -= 32) {\n      out.push(carry);\n      carry = 0;\n    }\n    if (shift === 0) {\n      return out.concat(a);\n    }\n    for (let i = 0; i < a.length; i++) {\n      out.push(carry | a[i] >>> shift);\n      carry = a[i] << 32 - shift;\n    }\n    const last2 = a.length ? a[a.length - 1] : 0;\n    const shift2 = bitArray.getPartial(last2);\n    out.push(bitArray.partial(shift + shift2 & 31, shift + shift2 > 32 ? carry : out.pop(), 1));\n    return out;\n  }\n};\n\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Arrays of bytes\n * @namespace\n */\nconst codec = {\n  bytes: {\n    /** Convert from a bitArray to an array of bytes. */\n    fromBits(arr) {\n      const bl = bitArray.bitLength(arr);\n      const byteLength = bl / 8;\n      const out = new Uint8Array(byteLength);\n      let tmp;\n      for (let i = 0; i < byteLength; i++) {\n        if ((i & 3) === 0) {\n          tmp = arr[i / 4];\n        }\n        out[i] = tmp >>> 24;\n        tmp <<= 8;\n      }\n      return out;\n    },\n    /** Convert from an array of bytes to a bitArray. */\n    toBits(bytes) {\n      const out = [];\n      let i;\n      let tmp = 0;\n      for (i = 0; i < bytes.length; i++) {\n        tmp = tmp << 8 | bytes[i];\n        if ((i & 3) === 3) {\n          out.push(tmp);\n          tmp = 0;\n        }\n      }\n      if (i & 3) {\n        out.push(bitArray.partial(8 * (i & 3), tmp));\n      }\n      return out;\n    }\n  }\n};\nconst hash = {};\n\n/**\n * Context for a SHA-1 operation in progress.\n * @constructor\n */\nhash.sha1 = class {\n  constructor(hash) {\n    const sha1 = this;\n    /**\n     * The hash's block size, in bits.\n     * @constant\n     */\n    sha1.blockSize = 512;\n    /**\n     * The SHA-1 initialization vector.\n     * @private\n     */\n    sha1._init = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];\n    /**\n     * The SHA-1 hash key.\n     * @private\n     */\n    sha1._key = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];\n    if (hash) {\n      sha1._h = hash._h.slice(0);\n      sha1._buffer = hash._buffer.slice(0);\n      sha1._length = hash._length;\n    } else {\n      sha1.reset();\n    }\n  }\n\n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset() {\n    const sha1 = this;\n    sha1._h = sha1._init.slice(0);\n    sha1._buffer = [];\n    sha1._length = 0;\n    return sha1;\n  }\n\n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update(data) {\n    const sha1 = this;\n    if (typeof data === \"string\") {\n      data = codec.utf8String.toBits(data);\n    }\n    const b = sha1._buffer = bitArray.concat(sha1._buffer, data);\n    const ol = sha1._length;\n    const nl = sha1._length = ol + bitArray.bitLength(data);\n    if (nl > 9007199254740991) {\n      throw new Error(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n    const c = new Uint32Array(b);\n    let j = 0;\n    for (let i = sha1.blockSize + ol - (sha1.blockSize + ol & sha1.blockSize - 1); i <= nl; i += sha1.blockSize) {\n      sha1._block(c.subarray(16 * j, 16 * (j + 1)));\n      j += 1;\n    }\n    b.splice(0, 16 * j);\n    return sha1;\n  }\n\n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO\n   */\n  finalize() {\n    const sha1 = this;\n    let b = sha1._buffer;\n    const h = sha1._h;\n\n    // Round out and push the buffer\n    b = bitArray.concat(b, [bitArray.partial(1, 1)]);\n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (let i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(Math.floor(sha1._length / 0x100000000));\n    b.push(sha1._length | 0);\n    while (b.length) {\n      sha1._block(b.splice(0, 16));\n    }\n    sha1.reset();\n    return h;\n  }\n\n  /**\n   * The SHA-1 logical functions f(0), f(1), ..., f(79).\n   * @private\n   */\n  _f(t, b, c, d) {\n    if (t <= 19) {\n      return b & c | ~b & d;\n    } else if (t <= 39) {\n      return b ^ c ^ d;\n    } else if (t <= 59) {\n      return b & c | b & d | c & d;\n    } else if (t <= 79) {\n      return b ^ c ^ d;\n    }\n  }\n\n  /**\n   * Circular left-shift operator.\n   * @private\n   */\n  _S(n, x) {\n    return x << n | x >>> 32 - n;\n  }\n\n  /**\n   * Perform one cycle of SHA-1.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block(words) {\n    const sha1 = this;\n    const h = sha1._h;\n    // When words is passed to _block, it has 16 elements. SHA1 _block\n    // function extends words with new elements (at the end there are 80 elements). \n    // The problem is that if we use Uint32Array instead of Array, \n    // the length of Uint32Array cannot be changed. Thus, we replace words with a \n    // normal Array here.\n    const w = Array(80); // do not use Uint32Array here as the instantiation is slower\n    for (let j = 0; j < 16; j++) {\n      w[j] = words[j];\n    }\n    let a = h[0];\n    let b = h[1];\n    let c = h[2];\n    let d = h[3];\n    let e = h[4];\n    for (let t = 0; t <= 79; t++) {\n      if (t >= 16) {\n        w[t] = sha1._S(1, w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]);\n      }\n      const tmp = sha1._S(5, a) + sha1._f(t, b, c, d) + e + w[t] + sha1._key[Math.floor(t / 20)] | 0;\n      e = d;\n      d = c;\n      c = sha1._S(30, b);\n      b = a;\n      a = tmp;\n    }\n    h[0] = h[0] + a | 0;\n    h[1] = h[1] + b | 0;\n    h[2] = h[2] + c | 0;\n    h[3] = h[3] + d | 0;\n    h[4] = h[4] + e | 0;\n  }\n};\n\n/** @fileOverview Low-level AES implementation.\n *\n * This file contains a low-level implementation of AES, optimized for\n * size and for efficiency on several browsers.  It is based on\n * OpenSSL's aes_core.c, a public-domain implementation by Vincent\n * Rijmen, Antoon Bosselaers and Paulo Barreto.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\nconst cipher = {};\n\n/**\n * Schedule out an AES key for both encryption and decryption.  This\n * is a low-level class.  Use a cipher mode to do bulk encryption.\n *\n * @constructor\n * @param {Array} key The key as an array of 4, 6 or 8 words.\n */\ncipher.aes = class {\n  constructor(key) {\n    /**\n     * The expanded S-box and inverse S-box tables.  These will be computed\n     * on the client so that we don't have to send them down the wire.\n     *\n     * There are two tables, _tables[0] is for encryption and\n     * _tables[1] is for decryption.\n     *\n     * The first 4 sub-tables are the expanded S-box with MixColumns.  The\n     * last (_tables[01][4]) is the S-box itself.\n     *\n     * @private\n     */\n    const aes = this;\n    aes._tables = [[[], [], [], [], []], [[], [], [], [], []]];\n    if (!aes._tables[0][0][0]) {\n      aes._precompute();\n    }\n    const sbox = aes._tables[0][4];\n    const decTable = aes._tables[1];\n    const keyLen = key.length;\n    let i,\n      encKey,\n      decKey,\n      rcon = 1;\n    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n      throw new Error(\"invalid aes key size\");\n    }\n    aes._key = [encKey = key.slice(0), decKey = []];\n\n    // schedule encryption keys\n    for (i = keyLen; i < 4 * keyLen + 28; i++) {\n      let tmp = encKey[i - 1];\n\n      // apply sbox\n      if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {\n        tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];\n\n        // shift rows and add rcon\n        if (i % keyLen === 0) {\n          tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\n          rcon = rcon << 1 ^ (rcon >> 7) * 283;\n        }\n      }\n      encKey[i] = encKey[i - keyLen] ^ tmp;\n    }\n\n    // schedule decryption keys\n    for (let j = 0; i; j++, i--) {\n      const tmp = encKey[j & 3 ? i : i - 4];\n      if (i <= 4 || j < 4) {\n        decKey[j] = tmp;\n      } else {\n        decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];\n      }\n    }\n  }\n  // public\n  /* Something like this might appear here eventually\n  name: \"AES\",\n  blockSize: 4,\n  keySizes: [4,6,8],\n  */\n\n  /**\n   * Encrypt an array of 4 big-endian words.\n   * @param {Array} data The plaintext.\n   * @return {Array} The ciphertext.\n   */\n  encrypt(data) {\n    return this._crypt(data, 0);\n  }\n\n  /**\n   * Decrypt an array of 4 big-endian words.\n   * @param {Array} data The ciphertext.\n   * @return {Array} The plaintext.\n   */\n  decrypt(data) {\n    return this._crypt(data, 1);\n  }\n\n  /**\n   * Expand the S-box tables.\n   *\n   * @private\n   */\n  _precompute() {\n    const encTable = this._tables[0];\n    const decTable = this._tables[1];\n    const sbox = encTable[4];\n    const sboxInv = decTable[4];\n    const d = [];\n    const th = [];\n    let xInv, x2, x4, x8;\n\n    // Compute double and third tables\n    for (let i = 0; i < 256; i++) {\n      th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\n    }\n    for (let x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n      // Compute sbox\n      let s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\n      s = s >> 8 ^ s & 255 ^ 99;\n      sbox[x] = s;\n      sboxInv[s] = x;\n\n      // Compute MixColumns\n      x8 = d[x4 = d[x2 = d[x]]];\n      let tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n      let tEnc = d[s] * 0x101 ^ s * 0x1010100;\n      for (let i = 0; i < 4; i++) {\n        encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n        decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\n      }\n    }\n\n    // Compactify.  Considerable speedup on Firefox.\n    for (let i = 0; i < 5; i++) {\n      encTable[i] = encTable[i].slice(0);\n      decTable[i] = decTable[i].slice(0);\n    }\n  }\n\n  /**\n   * Encryption and decryption core.\n   * @param {Array} input Four words to be encrypted or decrypted.\n   * @param dir The direction, 0 for encrypt and 1 for decrypt.\n   * @return {Array} The four encrypted or decrypted words.\n   * @private\n   */\n  _crypt(input, dir) {\n    if (input.length !== 4) {\n      throw new Error(\"invalid aes block size\");\n    }\n    const key = this._key[dir];\n    const nInnerRounds = key.length / 4 - 2;\n    const out = [0, 0, 0, 0];\n    const table = this._tables[dir];\n\n    // load up the tables\n    const t0 = table[0];\n    const t1 = table[1];\n    const t2 = table[2];\n    const t3 = table[3];\n    const sbox = table[4];\n\n    // state variables a,b,c,d are loaded with pre-whitened data\n    let a = input[0] ^ key[0];\n    let b = input[dir ? 3 : 1] ^ key[1];\n    let c = input[2] ^ key[2];\n    let d = input[dir ? 1 : 3] ^ key[3];\n    let kIndex = 4;\n    let a2, b2, c2;\n\n    // Inner rounds.  Cribbed from OpenSSL.\n    for (let i = 0; i < nInnerRounds; i++) {\n      a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];\n      b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];\n      c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];\n      d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];\n      kIndex += 4;\n      a = a2;\n      b = b2;\n      c = c2;\n    }\n\n    // Last round.\n    for (let i = 0; i < 4; i++) {\n      out[dir ? 3 & -i : i] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];\n      a2 = a;\n      a = b;\n      b = c;\n      c = d;\n      d = a2;\n    }\n    return out;\n  }\n};\n\n/**\n * Random values\n * @namespace\n */\nconst random = {\n  /** \n   * Generate random words with pure js, cryptographically not as strong & safe as native implementation.\n   * @param {TypedArray} typedArray The array to fill.\n   * @return {TypedArray} The random values.\n   */\n  getRandomValues(typedArray) {\n    const words = new Uint32Array(typedArray.buffer);\n    const r = m_w => {\n      let m_z = 0x3ade68b1;\n      const mask = 0xffffffff;\n      return function () {\n        m_z = 0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10) & mask;\n        m_w = 0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10) & mask;\n        const result = ((m_z << 0x10) + m_w & mask) / 0x100000000 + .5;\n        return result * (Math.random() > .5 ? 1 : -1);\n      };\n    };\n    for (let i = 0, rcache; i < typedArray.length; i += 4) {\n      const _r = r((rcache || Math.random()) * 0x100000000);\n      rcache = _r() * 0x3ade67b7;\n      words[i / 4] = _r() * 0x100000000 | 0;\n    }\n    return typedArray;\n  }\n};\n\n/** @fileOverview CTR mode implementation.\n *\n * Special thanks to Roy Nicholson for pointing out a bug in our\n * implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** Brian Gladman's CTR Mode.\n* @constructor\n* @param {Object} _prf The aes instance to generate key.\n* @param {bitArray} _iv The iv for ctr mode, it must be 128 bits.\n*/\n\nconst mode = {};\n\n/**\n * Brian Gladman's CTR Mode.\n * @namespace\n */\nmode.ctrGladman = class {\n  constructor(prf, iv) {\n    this._prf = prf;\n    this._initIv = iv;\n    this._iv = iv;\n  }\n  reset() {\n    this._iv = this._initIv;\n  }\n\n  /** Input some data to calculate.\n   * @param {bitArray} data the data to process, it must be intergral multiple of 128 bits unless it's the last.\n   */\n  update(data) {\n    return this.calculate(this._prf, data, this._iv);\n  }\n  incWord(word) {\n    if ((word >> 24 & 0xff) === 0xff) {\n      //overflow\n      let b1 = word >> 16 & 0xff;\n      let b2 = word >> 8 & 0xff;\n      let b3 = word & 0xff;\n      if (b1 === 0xff) {\n        // overflow b1   \n        b1 = 0;\n        if (b2 === 0xff) {\n          b2 = 0;\n          if (b3 === 0xff) {\n            b3 = 0;\n          } else {\n            ++b3;\n          }\n        } else {\n          ++b2;\n        }\n      } else {\n        ++b1;\n      }\n      word = 0;\n      word += b1 << 16;\n      word += b2 << 8;\n      word += b3;\n    } else {\n      word += 0x01 << 24;\n    }\n    return word;\n  }\n  incCounter(counter) {\n    if ((counter[0] = this.incWord(counter[0])) === 0) {\n      // encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8\n      counter[1] = this.incWord(counter[1]);\n    }\n  }\n  calculate(prf, data, iv) {\n    let l;\n    if (!(l = data.length)) {\n      return [];\n    }\n    const bl = bitArray.bitLength(data);\n    for (let i = 0; i < l; i += 4) {\n      this.incCounter(iv);\n      const e = prf.encrypt(iv);\n      data[i] ^= e[0];\n      data[i + 1] ^= e[1];\n      data[i + 2] ^= e[2];\n      data[i + 3] ^= e[3];\n    }\n    return bitArray.clamp(data, bl);\n  }\n};\nconst misc = {\n  importKey(password) {\n    return new misc.hmacSha1(codec.bytes.toBits(password));\n  },\n  pbkdf2(prf, salt, count, length) {\n    count = count || 10000;\n    if (length < 0 || count < 0) {\n      throw new Error(\"invalid params to pbkdf2\");\n    }\n    const byteLength = (length >> 5) + 1 << 2;\n    let u, ui, i, j, k;\n    const arrayBuffer = new ArrayBuffer(byteLength);\n    const out = new DataView(arrayBuffer);\n    let outLength = 0;\n    const b = bitArray;\n    salt = codec.bytes.toBits(salt);\n    for (k = 1; outLength < (byteLength || 1); k++) {\n      u = ui = prf.encrypt(b.concat(salt, [k]));\n      for (i = 1; i < count; i++) {\n        ui = prf.encrypt(ui);\n        for (j = 0; j < ui.length; j++) {\n          u[j] ^= ui[j];\n        }\n      }\n      for (i = 0; outLength < (byteLength || 1) && i < u.length; i++) {\n        out.setInt32(outLength, u[i]);\n        outLength += 4;\n      }\n    }\n    return arrayBuffer.slice(0, length / 8);\n  }\n};\n\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [Hash=hash.sha1] The hash function to use.\n */\nmisc.hmacSha1 = class {\n  constructor(key) {\n    const hmac = this;\n    const Hash = hmac._hash = hash.sha1;\n    const exKey = [[], []];\n    hmac._baseHash = [new Hash(), new Hash()];\n    const bs = hmac._baseHash[0].blockSize / 32;\n    if (key.length > bs) {\n      key = new Hash().update(key).finalize();\n    }\n    for (let i = 0; i < bs; i++) {\n      exKey[0][i] = key[i] ^ 0x36363636;\n      exKey[1][i] = key[i] ^ 0x5C5C5C5C;\n    }\n    hmac._baseHash[0].update(exKey[0]);\n    hmac._baseHash[1].update(exKey[1]);\n    hmac._resultHash = new Hash(hmac._baseHash[0]);\n  }\n  reset() {\n    const hmac = this;\n    hmac._resultHash = new hmac._hash(hmac._baseHash[0]);\n    hmac._updated = false;\n  }\n  update(data) {\n    const hmac = this;\n    hmac._updated = true;\n    hmac._resultHash.update(data);\n  }\n  digest() {\n    const hmac = this;\n    const w = hmac._resultHash.finalize();\n    const result = new hmac._hash(hmac._baseHash[1]).update(w).finalize();\n    hmac.reset();\n    return result;\n  }\n  encrypt(data) {\n    if (!this._updated) {\n      this.update(data);\n      return this.digest(data);\n    } else {\n      throw new Error(\"encrypt on already updated hmac called!\");\n    }\n  }\n};\nexport { cipher, codec, misc, mode, random };","map":{"version":3,"names":["bitArray","concat","a1","a2","length","last","shift","getPartial","_shiftRight","slice","bitLength","a","l","x","clamp","len","Math","ceil","partial","_end","round","carry","out","undefined","push","i","last2","shift2","pop","codec","bytes","fromBits","arr","bl","byteLength","Uint8Array","tmp","toBits","hash","sha1","constructor","blockSize","_init","_key","_h","_buffer","_length","reset","update","data","utf8String","b","ol","nl","Error","c","Uint32Array","j","_block","subarray","splice","finalize","h","floor","_f","t","d","_S","n","words","w","Array","e","cipher","aes","key","_tables","_precompute","sbox","decTable","keyLen","encKey","decKey","rcon","encrypt","_crypt","decrypt","encTable","sboxInv","th","xInv","x2","x4","x8","s","tDec","tEnc","input","dir","nInnerRounds","table","t0","t1","t2","t3","kIndex","b2","c2","random","getRandomValues","typedArray","buffer","r","m_w","m_z","mask","result","rcache","_r","mode","ctrGladman","prf","iv","_prf","_initIv","_iv","calculate","incWord","word","b1","b3","incCounter","counter","misc","importKey","password","hmacSha1","pbkdf2","salt","count","u","ui","k","arrayBuffer","ArrayBuffer","DataView","outLength","setInt32","hmac","Hash","_hash","exKey","_baseHash","bs","_resultHash","_updated","digest"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@zip.js/zip.js/lib/core/streams/codecs/sjcl.js"],"sourcesContent":["// Derived from https://github.com/xqdoo00o/jszip/blob/master/lib/sjcl.js and https://github.com/bitwiseshiftleft/sjcl\n\n// deno-lint-ignore-file no-this-alias\n\n/*\n * SJCL is open. You can use, modify and redistribute it under a BSD\n * license or under the GNU GPL, version 2.0.\n */\n\n/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Arrays of bits, encoded as arrays of Numbers.\n * @namespace\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nconst bitArray = {\n\t/**\n\t * Concatenate two bit arrays.\n\t * @param {bitArray} a1 The first array.\n\t * @param {bitArray} a2 The second array.\n\t * @return {bitArray} The concatenation of a1 and a2.\n\t */\n\tconcat(a1, a2) {\n\t\tif (a1.length === 0 || a2.length === 0) {\n\t\t\treturn a1.concat(a2);\n\t\t}\n\n\t\tconst last = a1[a1.length - 1], shift = bitArray.getPartial(last);\n\t\tif (shift === 32) {\n\t\t\treturn a1.concat(a2);\n\t\t} else {\n\t\t\treturn bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));\n\t\t}\n\t},\n\n\t/**\n\t * Find the length of an array of bits.\n\t * @param {bitArray} a The array.\n\t * @return {Number} The length of a, in bits.\n\t */\n\tbitLength(a) {\n\t\tconst l = a.length;\n\t\tif (l === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst x = a[l - 1];\n\t\treturn (l - 1) * 32 + bitArray.getPartial(x);\n\t},\n\n\t/**\n\t * Truncate an array.\n\t * @param {bitArray} a The array.\n\t * @param {Number} len The length to truncate to, in bits.\n\t * @return {bitArray} A new array, truncated to len bits.\n\t */\n\tclamp(a, len) {\n\t\tif (a.length * 32 < len) {\n\t\t\treturn a;\n\t\t}\n\t\ta = a.slice(0, Math.ceil(len / 32));\n\t\tconst l = a.length;\n\t\tlen = len & 31;\n\t\tif (l > 0 && len) {\n\t\t\ta[l - 1] = bitArray.partial(len, a[l - 1] & 0x80000000 >> (len - 1), 1);\n\t\t}\n\t\treturn a;\n\t},\n\n\t/**\n\t * Make a partial word for a bit array.\n\t * @param {Number} len The number of bits in the word.\n\t * @param {Number} x The bits.\n\t * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.\n\t * @return {Number} The partial word.\n\t */\n\tpartial(len, x, _end) {\n\t\tif (len === 32) {\n\t\t\treturn x;\n\t\t}\n\t\treturn (_end ? x | 0 : x << (32 - len)) + len * 0x10000000000;\n\t},\n\n\t/**\n\t * Get the number of bits used by a partial word.\n\t * @param {Number} x The partial word.\n\t * @return {Number} The number of bits used by the partial word.\n\t */\n\tgetPartial(x) {\n\t\treturn Math.round(x / 0x10000000000) || 32;\n\t},\n\n\t/** Shift an array right.\n\t * @param {bitArray} a The array to shift.\n\t * @param {Number} shift The number of bits to shift.\n\t * @param {Number} [carry=0] A byte to carry in\n\t * @param {bitArray} [out=[]] An array to prepend to the output.\n\t * @private\n\t */\n\t_shiftRight(a, shift, carry, out) {\n\t\tif (out === undefined) {\n\t\t\tout = [];\n\t\t}\n\n\t\tfor (; shift >= 32; shift -= 32) {\n\t\t\tout.push(carry);\n\t\t\tcarry = 0;\n\t\t}\n\t\tif (shift === 0) {\n\t\t\treturn out.concat(a);\n\t\t}\n\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tout.push(carry | a[i] >>> shift);\n\t\t\tcarry = a[i] << (32 - shift);\n\t\t}\n\t\tconst last2 = a.length ? a[a.length - 1] : 0;\n\t\tconst shift2 = bitArray.getPartial(last2);\n\t\tout.push(bitArray.partial(shift + shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(), 1));\n\t\treturn out;\n\t}\n};\n\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Arrays of bytes\n * @namespace\n */\nconst codec = {\n\tbytes: {\n\t\t/** Convert from a bitArray to an array of bytes. */\n\t\tfromBits(arr) {\n\t\t\tconst bl = bitArray.bitLength(arr);\n\t\t\tconst byteLength = bl / 8;\n\t\t\tconst out = new Uint8Array(byteLength);\n\t\t\tlet tmp;\n\t\t\tfor (let i = 0; i < byteLength; i++) {\n\t\t\t\tif ((i & 3) === 0) {\n\t\t\t\t\ttmp = arr[i / 4];\n\t\t\t\t}\n\t\t\t\tout[i] = tmp >>> 24;\n\t\t\t\ttmp <<= 8;\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\t\t/** Convert from an array of bytes to a bitArray. */\n\t\ttoBits(bytes) {\n\t\t\tconst out = [];\n\t\t\tlet i;\n\t\t\tlet tmp = 0;\n\t\t\tfor (i = 0; i < bytes.length; i++) {\n\t\t\t\ttmp = tmp << 8 | bytes[i];\n\t\t\t\tif ((i & 3) === 3) {\n\t\t\t\t\tout.push(tmp);\n\t\t\t\t\ttmp = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i & 3) {\n\t\t\t\tout.push(bitArray.partial(8 * (i & 3), tmp));\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t}\n};\n\nconst hash = {};\n\n/**\n * Context for a SHA-1 operation in progress.\n * @constructor\n */\nhash.sha1 = class {\n\tconstructor(hash) {\n\t\tconst sha1 = this;\n\t\t/**\n\t\t * The hash's block size, in bits.\n\t\t * @constant\n\t\t */\n\t\tsha1.blockSize = 512;\n\t\t/**\n\t\t * The SHA-1 initialization vector.\n\t\t * @private\n\t\t */\n\t\tsha1._init = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];\n\t\t/**\n\t\t * The SHA-1 hash key.\n\t\t * @private\n\t\t */\n\t\tsha1._key = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];\n\t\tif (hash) {\n\t\t\tsha1._h = hash._h.slice(0);\n\t\t\tsha1._buffer = hash._buffer.slice(0);\n\t\t\tsha1._length = hash._length;\n\t\t} else {\n\t\t\tsha1.reset();\n\t\t}\n\t}\n\n\t/**\n\t * Reset the hash state.\n\t * @return this\n\t */\n\treset() {\n\t\tconst sha1 = this;\n\t\tsha1._h = sha1._init.slice(0);\n\t\tsha1._buffer = [];\n\t\tsha1._length = 0;\n\t\treturn sha1;\n\t}\n\n\t/**\n\t * Input several words to the hash.\n\t * @param {bitArray|String} data the data to hash.\n\t * @return this\n\t */\n\tupdate(data) {\n\t\tconst sha1 = this;\n\t\tif (typeof data === \"string\") {\n\t\t\tdata = codec.utf8String.toBits(data);\n\t\t}\n\t\tconst b = sha1._buffer = bitArray.concat(sha1._buffer, data);\n\t\tconst ol = sha1._length;\n\t\tconst nl = sha1._length = ol + bitArray.bitLength(data);\n\t\tif (nl > 9007199254740991) {\n\t\t\tthrow new Error(\"Cannot hash more than 2^53 - 1 bits\");\n\t\t}\n\t\tconst c = new Uint32Array(b);\n\t\tlet j = 0;\n\t\tfor (let i = sha1.blockSize + ol - ((sha1.blockSize + ol) & (sha1.blockSize - 1)); i <= nl;\n\t\t\ti += sha1.blockSize) {\n\t\t\tsha1._block(c.subarray(16 * j, 16 * (j + 1)));\n\t\t\tj += 1;\n\t\t}\n\t\tb.splice(0, 16 * j);\n\t\treturn sha1;\n\t}\n\n\t/**\n\t * Complete hashing and output the hash value.\n\t * @return {bitArray} The hash value, an array of 5 big-endian words. TODO\n\t */\n\tfinalize() {\n\t\tconst sha1 = this;\n\t\tlet b = sha1._buffer;\n\t\tconst h = sha1._h;\n\n\t\t// Round out and push the buffer\n\t\tb = bitArray.concat(b, [bitArray.partial(1, 1)]);\n\t\t// Round out the buffer to a multiple of 16 words, less the 2 length words.\n\t\tfor (let i = b.length + 2; i & 15; i++) {\n\t\t\tb.push(0);\n\t\t}\n\n\t\t// append the length\n\t\tb.push(Math.floor(sha1._length / 0x100000000));\n\t\tb.push(sha1._length | 0);\n\n\t\twhile (b.length) {\n\t\t\tsha1._block(b.splice(0, 16));\n\t\t}\n\n\t\tsha1.reset();\n\t\treturn h;\n\t}\n\n\t/**\n\t * The SHA-1 logical functions f(0), f(1), ..., f(79).\n\t * @private\n\t */\n\t_f(t, b, c, d) {\n\t\tif (t <= 19) {\n\t\t\treturn (b & c) | (~b & d);\n\t\t} else if (t <= 39) {\n\t\t\treturn b ^ c ^ d;\n\t\t} else if (t <= 59) {\n\t\t\treturn (b & c) | (b & d) | (c & d);\n\t\t} else if (t <= 79) {\n\t\t\treturn b ^ c ^ d;\n\t\t}\n\t}\n\n\t/**\n\t * Circular left-shift operator.\n\t * @private\n\t */\n\t_S(n, x) {\n\t\treturn (x << n) | (x >>> 32 - n);\n\t}\n\n\t/**\n\t * Perform one cycle of SHA-1.\n\t * @param {Uint32Array|bitArray} words one block of words.\n\t * @private\n\t */\n\t_block(words) {\n\t\tconst sha1 = this;\n\t\tconst h = sha1._h;\n\t\t// When words is passed to _block, it has 16 elements. SHA1 _block\n\t\t// function extends words with new elements (at the end there are 80 elements). \n\t\t// The problem is that if we use Uint32Array instead of Array, \n\t\t// the length of Uint32Array cannot be changed. Thus, we replace words with a \n\t\t// normal Array here.\n\t\tconst w = Array(80); // do not use Uint32Array here as the instantiation is slower\n\t\tfor (let j = 0; j < 16; j++) {\n\t\t\tw[j] = words[j];\n\t\t}\n\n\t\tlet a = h[0];\n\t\tlet b = h[1];\n\t\tlet c = h[2];\n\t\tlet d = h[3];\n\t\tlet e = h[4];\n\n\t\tfor (let t = 0; t <= 79; t++) {\n\t\t\tif (t >= 16) {\n\t\t\t\tw[t] = sha1._S(1, w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]);\n\t\t\t}\n\t\t\tconst tmp = (sha1._S(5, a) + sha1._f(t, b, c, d) + e + w[t] +\n\t\t\t\tsha1._key[Math.floor(t / 20)]) | 0;\n\t\t\te = d;\n\t\t\td = c;\n\t\t\tc = sha1._S(30, b);\n\t\t\tb = a;\n\t\t\ta = tmp;\n\t\t}\n\n\t\th[0] = (h[0] + a) | 0;\n\t\th[1] = (h[1] + b) | 0;\n\t\th[2] = (h[2] + c) | 0;\n\t\th[3] = (h[3] + d) | 0;\n\t\th[4] = (h[4] + e) | 0;\n\t}\n};\n\n/** @fileOverview Low-level AES implementation.\n *\n * This file contains a low-level implementation of AES, optimized for\n * size and for efficiency on several browsers.  It is based on\n * OpenSSL's aes_core.c, a public-domain implementation by Vincent\n * Rijmen, Antoon Bosselaers and Paulo Barreto.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\nconst cipher = {};\n\n/**\n * Schedule out an AES key for both encryption and decryption.  This\n * is a low-level class.  Use a cipher mode to do bulk encryption.\n *\n * @constructor\n * @param {Array} key The key as an array of 4, 6 or 8 words.\n */\ncipher.aes = class {\n\tconstructor(key) {\n\t\t/**\n\t\t * The expanded S-box and inverse S-box tables.  These will be computed\n\t\t * on the client so that we don't have to send them down the wire.\n\t\t *\n\t\t * There are two tables, _tables[0] is for encryption and\n\t\t * _tables[1] is for decryption.\n\t\t *\n\t\t * The first 4 sub-tables are the expanded S-box with MixColumns.  The\n\t\t * last (_tables[01][4]) is the S-box itself.\n\t\t *\n\t\t * @private\n\t\t */\n\t\tconst aes = this;\n\t\taes._tables = [[[], [], [], [], []], [[], [], [], [], []]];\n\n\t\tif (!aes._tables[0][0][0]) {\n\t\t\taes._precompute();\n\t\t}\n\n\t\tconst sbox = aes._tables[0][4];\n\t\tconst decTable = aes._tables[1];\n\t\tconst keyLen = key.length;\n\n\t\tlet i, encKey, decKey, rcon = 1;\n\n\t\tif (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n\t\t\tthrow new Error(\"invalid aes key size\");\n\t\t}\n\n\t\taes._key = [encKey = key.slice(0), decKey = []];\n\n\t\t// schedule encryption keys\n\t\tfor (i = keyLen; i < 4 * keyLen + 28; i++) {\n\t\t\tlet tmp = encKey[i - 1];\n\n\t\t\t// apply sbox\n\t\t\tif (i % keyLen === 0 || (keyLen === 8 && i % keyLen === 4)) {\n\t\t\t\ttmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];\n\n\t\t\t\t// shift rows and add rcon\n\t\t\t\tif (i % keyLen === 0) {\n\t\t\t\t\ttmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\n\t\t\t\t\trcon = rcon << 1 ^ (rcon >> 7) * 283;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tencKey[i] = encKey[i - keyLen] ^ tmp;\n\t\t}\n\n\t\t// schedule decryption keys\n\t\tfor (let j = 0; i; j++, i--) {\n\t\t\tconst tmp = encKey[j & 3 ? i : i - 4];\n\t\t\tif (i <= 4 || j < 4) {\n\t\t\t\tdecKey[j] = tmp;\n\t\t\t} else {\n\t\t\t\tdecKey[j] = decTable[0][sbox[tmp >>> 24]] ^\n\t\t\t\t\tdecTable[1][sbox[tmp >> 16 & 255]] ^\n\t\t\t\t\tdecTable[2][sbox[tmp >> 8 & 255]] ^\n\t\t\t\t\tdecTable[3][sbox[tmp & 255]];\n\t\t\t}\n\t\t}\n\t}\n\t// public\n\t/* Something like this might appear here eventually\n\tname: \"AES\",\n\tblockSize: 4,\n\tkeySizes: [4,6,8],\n\t*/\n\n\t/**\n\t * Encrypt an array of 4 big-endian words.\n\t * @param {Array} data The plaintext.\n\t * @return {Array} The ciphertext.\n\t */\n\tencrypt(data) {\n\t\treturn this._crypt(data, 0);\n\t}\n\n\t/**\n\t * Decrypt an array of 4 big-endian words.\n\t * @param {Array} data The ciphertext.\n\t * @return {Array} The plaintext.\n\t */\n\tdecrypt(data) {\n\t\treturn this._crypt(data, 1);\n\t}\n\n\t/**\n\t * Expand the S-box tables.\n\t *\n\t * @private\n\t */\n\t_precompute() {\n\t\tconst encTable = this._tables[0];\n\t\tconst decTable = this._tables[1];\n\t\tconst sbox = encTable[4];\n\t\tconst sboxInv = decTable[4];\n\t\tconst d = [];\n\t\tconst th = [];\n\t\tlet xInv, x2, x4, x8;\n\n\t\t// Compute double and third tables\n\t\tfor (let i = 0; i < 256; i++) {\n\t\t\tth[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\n\t\t}\n\n\t\tfor (let x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n\t\t\t// Compute sbox\n\t\t\tlet s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\n\t\t\ts = s >> 8 ^ s & 255 ^ 99;\n\t\t\tsbox[x] = s;\n\t\t\tsboxInv[s] = x;\n\n\t\t\t// Compute MixColumns\n\t\t\tx8 = d[x4 = d[x2 = d[x]]];\n\t\t\tlet tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n\t\t\tlet tEnc = d[s] * 0x101 ^ s * 0x1010100;\n\n\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\tencTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n\t\t\t\tdecTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\n\t\t\t}\n\t\t}\n\n\t\t// Compactify.  Considerable speedup on Firefox.\n\t\tfor (let i = 0; i < 5; i++) {\n\t\t\tencTable[i] = encTable[i].slice(0);\n\t\t\tdecTable[i] = decTable[i].slice(0);\n\t\t}\n\t}\n\n\t/**\n\t * Encryption and decryption core.\n\t * @param {Array} input Four words to be encrypted or decrypted.\n\t * @param dir The direction, 0 for encrypt and 1 for decrypt.\n\t * @return {Array} The four encrypted or decrypted words.\n\t * @private\n\t */\n\t_crypt(input, dir) {\n\t\tif (input.length !== 4) {\n\t\t\tthrow new Error(\"invalid aes block size\");\n\t\t}\n\n\t\tconst key = this._key[dir];\n\n\t\tconst nInnerRounds = key.length / 4 - 2;\n\t\tconst out = [0, 0, 0, 0];\n\t\tconst table = this._tables[dir];\n\n\t\t// load up the tables\n\t\tconst t0 = table[0];\n\t\tconst t1 = table[1];\n\t\tconst t2 = table[2];\n\t\tconst t3 = table[3];\n\t\tconst sbox = table[4];\n\n\t\t// state variables a,b,c,d are loaded with pre-whitened data\n\t\tlet a = input[0] ^ key[0];\n\t\tlet b = input[dir ? 3 : 1] ^ key[1];\n\t\tlet c = input[2] ^ key[2];\n\t\tlet d = input[dir ? 1 : 3] ^ key[3];\n\t\tlet kIndex = 4;\n\t\tlet a2, b2, c2;\n\n\t\t// Inner rounds.  Cribbed from OpenSSL.\n\t\tfor (let i = 0; i < nInnerRounds; i++) {\n\t\t\ta2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];\n\t\t\tb2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];\n\t\t\tc2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];\n\t\t\td = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];\n\t\t\tkIndex += 4;\n\t\t\ta = a2; b = b2; c = c2;\n\t\t}\n\n\t\t// Last round.\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tout[dir ? 3 & -i : i] =\n\t\t\t\tsbox[a >>> 24] << 24 ^\n\t\t\t\tsbox[b >> 16 & 255] << 16 ^\n\t\t\t\tsbox[c >> 8 & 255] << 8 ^\n\t\t\t\tsbox[d & 255] ^\n\t\t\t\tkey[kIndex++];\n\t\t\ta2 = a; a = b; b = c; c = d; d = a2;\n\t\t}\n\n\t\treturn out;\n\t}\n};\n\n/**\n * Random values\n * @namespace\n */\nconst random = {\n\t/** \n\t * Generate random words with pure js, cryptographically not as strong & safe as native implementation.\n\t * @param {TypedArray} typedArray The array to fill.\n\t * @return {TypedArray} The random values.\n\t */\n\tgetRandomValues(typedArray) {\n\t\tconst words = new Uint32Array(typedArray.buffer);\n\t\tconst r = (m_w) => {\n\t\t\tlet m_z = 0x3ade68b1;\n\t\t\tconst mask = 0xffffffff;\n\t\t\treturn function () {\n\t\t\t\tm_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;\n\t\t\t\tm_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;\n\t\t\t\tconst result = ((((m_z << 0x10) + m_w) & mask) / 0x100000000) + .5;\n\t\t\t\treturn result * (Math.random() > .5 ? 1 : -1);\n\t\t\t};\n\t\t};\n\t\tfor (let i = 0, rcache; i < typedArray.length; i += 4) {\n\t\t\tconst _r = r((rcache || Math.random()) * 0x100000000);\n\t\t\trcache = _r() * 0x3ade67b7;\n\t\t\twords[i / 4] = (_r() * 0x100000000) | 0;\n\t\t}\n\t\treturn typedArray;\n\t}\n};\n\n/** @fileOverview CTR mode implementation.\n *\n * Special thanks to Roy Nicholson for pointing out a bug in our\n * implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** Brian Gladman's CTR Mode.\n* @constructor\n* @param {Object} _prf The aes instance to generate key.\n* @param {bitArray} _iv The iv for ctr mode, it must be 128 bits.\n*/\n\nconst mode = {};\n\n/**\n * Brian Gladman's CTR Mode.\n * @namespace\n */\nmode.ctrGladman = class {\n\tconstructor(prf, iv) {\n\t\tthis._prf = prf;\n\t\tthis._initIv = iv;\n\t\tthis._iv = iv;\n\t}\n\n\treset() {\n\t\tthis._iv = this._initIv;\n\t}\n\n\t/** Input some data to calculate.\n\t * @param {bitArray} data the data to process, it must be intergral multiple of 128 bits unless it's the last.\n\t */\n\tupdate(data) {\n\t\treturn this.calculate(this._prf, data, this._iv);\n\t}\n\n\tincWord(word) {\n\t\tif (((word >> 24) & 0xff) === 0xff) { //overflow\n\t\t\tlet b1 = (word >> 16) & 0xff;\n\t\t\tlet b2 = (word >> 8) & 0xff;\n\t\t\tlet b3 = word & 0xff;\n\n\t\t\tif (b1 === 0xff) { // overflow b1   \n\t\t\t\tb1 = 0;\n\t\t\t\tif (b2 === 0xff) {\n\t\t\t\t\tb2 = 0;\n\t\t\t\t\tif (b3 === 0xff) {\n\t\t\t\t\t\tb3 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t++b3;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t++b2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t++b1;\n\t\t\t}\n\n\t\t\tword = 0;\n\t\t\tword += (b1 << 16);\n\t\t\tword += (b2 << 8);\n\t\t\tword += b3;\n\t\t} else {\n\t\t\tword += (0x01 << 24);\n\t\t}\n\t\treturn word;\n\t}\n\n\tincCounter(counter) {\n\t\tif ((counter[0] = this.incWord(counter[0])) === 0) {\n\t\t\t// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8\n\t\t\tcounter[1] = this.incWord(counter[1]);\n\t\t}\n\t}\n\n\tcalculate(prf, data, iv) {\n\t\tlet l;\n\t\tif (!(l = data.length)) {\n\t\t\treturn [];\n\t\t}\n\t\tconst bl = bitArray.bitLength(data);\n\t\tfor (let i = 0; i < l; i += 4) {\n\t\t\tthis.incCounter(iv);\n\t\t\tconst e = prf.encrypt(iv);\n\t\t\tdata[i] ^= e[0];\n\t\t\tdata[i + 1] ^= e[1];\n\t\t\tdata[i + 2] ^= e[2];\n\t\t\tdata[i + 3] ^= e[3];\n\t\t}\n\t\treturn bitArray.clamp(data, bl);\n\t}\n};\n\nconst misc = {\n\timportKey(password) {\n\t\treturn new misc.hmacSha1(codec.bytes.toBits(password));\n\t},\n\tpbkdf2(prf, salt, count, length) {\n\t\tcount = count || 10000;\n\t\tif (length < 0 || count < 0) {\n\t\t\tthrow new Error(\"invalid params to pbkdf2\");\n\t\t}\n\t\tconst byteLength = ((length >> 5) + 1) << 2;\n\t\tlet u, ui, i, j, k;\n\t\tconst arrayBuffer = new ArrayBuffer(byteLength);\n\t\tconst out = new DataView(arrayBuffer);\n\t\tlet outLength = 0;\n\t\tconst b = bitArray;\n\t\tsalt = codec.bytes.toBits(salt);\n\t\tfor (k = 1; outLength < (byteLength || 1); k++) {\n\t\t\tu = ui = prf.encrypt(b.concat(salt, [k]));\n\t\t\tfor (i = 1; i < count; i++) {\n\t\t\t\tui = prf.encrypt(ui);\n\t\t\t\tfor (j = 0; j < ui.length; j++) {\n\t\t\t\t\tu[j] ^= ui[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; outLength < (byteLength || 1) && i < u.length; i++) {\n\t\t\t\tout.setInt32(outLength, u[i]);\n\t\t\t\toutLength += 4;\n\t\t\t}\n\t\t}\n\t\treturn arrayBuffer.slice(0, length / 8);\n\t}\n};\n\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [Hash=hash.sha1] The hash function to use.\n */\nmisc.hmacSha1 = class {\n\n\tconstructor(key) {\n\t\tconst hmac = this;\n\t\tconst Hash = hmac._hash = hash.sha1;\n\t\tconst exKey = [[], []];\n\t\thmac._baseHash = [new Hash(), new Hash()];\n\t\tconst bs = hmac._baseHash[0].blockSize / 32;\n\n\t\tif (key.length > bs) {\n\t\t\tkey = new Hash().update(key).finalize();\n\t\t}\n\n\t\tfor (let i = 0; i < bs; i++) {\n\t\t\texKey[0][i] = key[i] ^ 0x36363636;\n\t\t\texKey[1][i] = key[i] ^ 0x5C5C5C5C;\n\t\t}\n\n\t\thmac._baseHash[0].update(exKey[0]);\n\t\thmac._baseHash[1].update(exKey[1]);\n\t\thmac._resultHash = new Hash(hmac._baseHash[0]);\n\t}\n\treset() {\n\t\tconst hmac = this;\n\t\thmac._resultHash = new hmac._hash(hmac._baseHash[0]);\n\t\thmac._updated = false;\n\t}\n\n\tupdate(data) {\n\t\tconst hmac = this;\n\t\thmac._updated = true;\n\t\thmac._resultHash.update(data);\n\t}\n\n\tdigest() {\n\t\tconst hmac = this;\n\t\tconst w = hmac._resultHash.finalize();\n\t\tconst result = new (hmac._hash)(hmac._baseHash[1]).update(w).finalize();\n\n\t\thmac.reset();\n\n\t\treturn result;\n\t}\n\n\tencrypt(data) {\n\t\tif (!this._updated) {\n\t\t\tthis.update(data);\n\t\t\treturn this.digest(data);\n\t\t} else {\n\t\t\tthrow new Error(\"encrypt on already updated hmac called!\");\n\t\t}\n\t}\n};\n\nexport {\n\tcipher,\n\tcodec,\n\tmisc,\n\tmode,\n\trandom\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}