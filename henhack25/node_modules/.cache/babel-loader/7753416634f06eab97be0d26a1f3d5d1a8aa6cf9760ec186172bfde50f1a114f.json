{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { RgbaFloatEncoding as e } from \"../util/RgbaFloatEncoding.glsl.js\";\nimport { addCameraPosition as t, addPixelRatio as o } from \"../util/View.glsl.js\";\nimport { Float4PassUniform as r } from \"../../shaderModules/Float4PassUniform.js\";\nimport { FloatBindUniform as i } from \"../../shaderModules/FloatBindUniform.js\";\nimport { FloatPassUniform as l } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as a, If as p } from \"../../shaderModules/glsl.js\";\nimport { Texture2DPassUniform as s } from \"../../shaderModules/Texture2DPassUniform.js\";\nimport { computeLongestPattern as n, computeTextureSize as d } from \"../../../materials/stippleTextureRepository.js\";\nimport { ensureColor4 as c } from \"../../../shaders/ensureColor4.js\";\nfunction f(n, d) {\n  if (!d.stippleEnabled) return void n.fragment.code.add(a`float getStippleAlpha() { return 1.0; }\nvoid discardByStippleAlpha(float stippleAlpha, float threshold) {}\nvec4 blendStipple(vec4 color, float stippleAlpha) { return color; }`);\n  const f = !(d.draped && d.stipplePreferContinuous),\n    {\n      vertex: g,\n      fragment: h\n    } = n;\n  h.include(e), d.draped || (t(g, d), g.uniforms.add(new i(\"worldToScreenPerDistanceRatio\", _ref => {\n    let {\n      camera: e\n    } = _ref;\n    return 1 / e.perScreenPixelRatio;\n  })).code.add(a`float computeWorldToScreenRatio(vec3 segmentCenter) {\nfloat segmentDistanceToCamera = length(segmentCenter - cameraPosition);\nreturn worldToScreenPerDistanceRatio / segmentDistanceToCamera;\n}`)), n.varyings.add(\"vStippleDistance\", \"float\"), n.varyings.add(\"vStippleDistanceLimits\", \"vec2\"), n.varyings.add(\"vStipplePatternStretch\", \"float\"), g.code.add(a`\n    float discretizeWorldToScreenRatio(float worldToScreenRatio) {\n      float step = ${a.float(u)};\n\n      float discreteWorldToScreenRatio = log(worldToScreenRatio);\n      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;\n      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);\n      return discreteWorldToScreenRatio;\n    }\n  `), g.code.add(a`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`), g.code.add(a`\n    if (segmentLengthPseudoScreen >= ${f ? \"patternLength\" : \"1e4\"}) {\n  `), o(g), g.code.add(a`float repetitions = segmentLengthScreen / (patternLength * pixelRatio);\nfloat flooredRepetitions = max(1.0, floor(repetitions + 0.5));\nfloat segmentLengthScreenRounded = flooredRepetitions * patternLength;\nfloat stretch = repetitions / flooredRepetitions;\nvStipplePatternStretch = max(0.75, stretch);\nreturn vec2(0.0, segmentLengthScreenRounded);\n}\nreturn vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);\n}`), h.uniforms.add(new s(\"stipplePatternTexture\", e => e.stippleTexture), new l(\"stipplePatternSDFNormalizer\", e => m(e.stipplePattern)), new l(\"stipplePatternPixelSizeInv\", e => 1 / S(e))), d.stippleOffColorEnabled && h.uniforms.add(new r(\"stippleOffColor\", e => c(e.stippleOffColor))), h.code.add(a`float getStippleSDF(out bool isClamped) {\nfloat stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);\nvec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;\nisClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;\nfloat u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv * vLineSizeInv;\nu = fract(u);\nfloat encodedSDF = rgbaTofloat(texture(stipplePatternTexture, vec2(u, 0.5)));\nfloat sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;\nreturn (sdf - 0.5) * vStipplePatternStretch + 0.5;\n}\nfloat getStippleSDF() {\nbool ignored;\nreturn getStippleSDF(ignored);\n}\nfloat getStippleAlpha() {\nbool isClamped;\nfloat stippleSDF = getStippleSDF(isClamped);\nfloat antiAliasedResult = clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);\nreturn isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;\n}`), h.code.add(a`\n    void discardByStippleAlpha(float stippleAlpha, float threshold) {\n     ${p(!d.stippleOffColorEnabled, \"if (stippleAlpha < threshold) { discard; }\")}\n    }\n\n    vec4 blendStipple(vec4 color, float stippleAlpha) {\n      return ${d.stippleOffColorEnabled ? \"mix(color, stippleOffColor, stippleAlpha)\" : \"vec4(color.rgb, color.a * stippleAlpha)\"};\n    }\n  `);\n}\nfunction m(e) {\n  return e ? (Math.floor(.5 * (n(e) - 1)) + .5) / e.pixelRatio : 1;\n}\nfunction S(e) {\n  const t = e.stipplePattern;\n  return t ? d(e.stipplePattern) / t.pixelRatio : 1;\n}\nconst u = .4;\nexport { f as LineStipple, S as computePixelSize };","map":{"version":3,"names":["RgbaFloatEncoding","e","addCameraPosition","t","addPixelRatio","o","Float4PassUniform","r","FloatBindUniform","i","FloatPassUniform","l","glsl","a","If","p","Texture2DPassUniform","s","computeLongestPattern","n","computeTextureSize","d","ensureColor4","c","f","stippleEnabled","fragment","code","add","draped","stipplePreferContinuous","vertex","g","h","include","uniforms","_ref","camera","perScreenPixelRatio","varyings","float","u","stippleTexture","m","stipplePattern","S","stippleOffColorEnabled","stippleOffColor","Math","floor","pixelRatio","LineStipple","computePixelSize"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{RgbaFloatEncoding as e}from\"../util/RgbaFloatEncoding.glsl.js\";import{addCameraPosition as t,addPixelRatio as o}from\"../util/View.glsl.js\";import{Float4PassUniform as r}from\"../../shaderModules/Float4PassUniform.js\";import{FloatBindUniform as i}from\"../../shaderModules/FloatBindUniform.js\";import{FloatPassUniform as l}from\"../../shaderModules/FloatPassUniform.js\";import{glsl as a,If as p}from\"../../shaderModules/glsl.js\";import{Texture2DPassUniform as s}from\"../../shaderModules/Texture2DPassUniform.js\";import{computeLongestPattern as n,computeTextureSize as d}from\"../../../materials/stippleTextureRepository.js\";import{ensureColor4 as c}from\"../../../shaders/ensureColor4.js\";function f(n,d){if(!d.stippleEnabled)return void n.fragment.code.add(a`float getStippleAlpha() { return 1.0; }\nvoid discardByStippleAlpha(float stippleAlpha, float threshold) {}\nvec4 blendStipple(vec4 color, float stippleAlpha) { return color; }`);const f=!(d.draped&&d.stipplePreferContinuous),{vertex:g,fragment:h}=n;h.include(e),d.draped||(t(g,d),g.uniforms.add(new i(\"worldToScreenPerDistanceRatio\",(({camera:e})=>1/e.perScreenPixelRatio))).code.add(a`float computeWorldToScreenRatio(vec3 segmentCenter) {\nfloat segmentDistanceToCamera = length(segmentCenter - cameraPosition);\nreturn worldToScreenPerDistanceRatio / segmentDistanceToCamera;\n}`)),n.varyings.add(\"vStippleDistance\",\"float\"),n.varyings.add(\"vStippleDistanceLimits\",\"vec2\"),n.varyings.add(\"vStipplePatternStretch\",\"float\"),g.code.add(a`\n    float discretizeWorldToScreenRatio(float worldToScreenRatio) {\n      float step = ${a.float(u)};\n\n      float discreteWorldToScreenRatio = log(worldToScreenRatio);\n      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;\n      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);\n      return discreteWorldToScreenRatio;\n    }\n  `),g.code.add(a`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`),g.code.add(a`\n    if (segmentLengthPseudoScreen >= ${f?\"patternLength\":\"1e4\"}) {\n  `),o(g),g.code.add(a`float repetitions = segmentLengthScreen / (patternLength * pixelRatio);\nfloat flooredRepetitions = max(1.0, floor(repetitions + 0.5));\nfloat segmentLengthScreenRounded = flooredRepetitions * patternLength;\nfloat stretch = repetitions / flooredRepetitions;\nvStipplePatternStretch = max(0.75, stretch);\nreturn vec2(0.0, segmentLengthScreenRounded);\n}\nreturn vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);\n}`),h.uniforms.add(new s(\"stipplePatternTexture\",(e=>e.stippleTexture)),new l(\"stipplePatternSDFNormalizer\",(e=>m(e.stipplePattern))),new l(\"stipplePatternPixelSizeInv\",(e=>1/S(e)))),d.stippleOffColorEnabled&&h.uniforms.add(new r(\"stippleOffColor\",(e=>c(e.stippleOffColor)))),h.code.add(a`float getStippleSDF(out bool isClamped) {\nfloat stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);\nvec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;\nisClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;\nfloat u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv * vLineSizeInv;\nu = fract(u);\nfloat encodedSDF = rgbaTofloat(texture(stipplePatternTexture, vec2(u, 0.5)));\nfloat sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;\nreturn (sdf - 0.5) * vStipplePatternStretch + 0.5;\n}\nfloat getStippleSDF() {\nbool ignored;\nreturn getStippleSDF(ignored);\n}\nfloat getStippleAlpha() {\nbool isClamped;\nfloat stippleSDF = getStippleSDF(isClamped);\nfloat antiAliasedResult = clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);\nreturn isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;\n}`),h.code.add(a`\n    void discardByStippleAlpha(float stippleAlpha, float threshold) {\n     ${p(!d.stippleOffColorEnabled,\"if (stippleAlpha < threshold) { discard; }\")}\n    }\n\n    vec4 blendStipple(vec4 color, float stippleAlpha) {\n      return ${d.stippleOffColorEnabled?\"mix(color, stippleOffColor, stippleAlpha)\":\"vec4(color.rgb, color.a * stippleAlpha)\"};\n    }\n  `)}function m(e){return e?(Math.floor(.5*(n(e)-1))+.5)/e.pixelRatio:1}function S(e){const t=e.stipplePattern;return t?d(e.stipplePattern)/t.pixelRatio:1}const u=.4;export{f as LineStipple,S as computePixelSize};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}