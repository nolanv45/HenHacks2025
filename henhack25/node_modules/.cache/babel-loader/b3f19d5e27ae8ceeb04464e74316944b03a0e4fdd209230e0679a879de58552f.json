{"ast":null,"code":"import { ContextProvider as t } from \"../controllers/context-provider.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nfunction e(_ref) {\n  let {\n    context: e\n  } = _ref;\n  return (n, r) => {\n    const i = new WeakMap();\n    if (\"object\" == typeof r) return r.addInitializer(function () {\n      i.set(this, new t(this, {\n        context: e\n      }));\n    }), {\n      get() {\n        return n.get.call(this);\n      },\n      set(t) {\n        return i.get(this)?.setValue(t), n.set.call(this, t);\n      },\n      init(t) {\n        return i.get(this)?.setValue(t), t;\n      }\n    };\n    {\n      n.constructor.addInitializer(n => {\n        i.set(n, new t(n, {\n          context: e\n        }));\n      });\n      const o = Object.getOwnPropertyDescriptor(n, r);\n      let s;\n      if (void 0 === o) {\n        const t = new WeakMap();\n        s = {\n          get() {\n            return t.get(this);\n          },\n          set(e) {\n            i.get(this).setValue(e), t.set(this, e);\n          },\n          configurable: !0,\n          enumerable: !0\n        };\n      } else {\n        const t = o.set;\n        s = {\n          ...o,\n          set(e) {\n            i.get(this).setValue(e), t?.call(this, e);\n          }\n        };\n      }\n      return void Object.defineProperty(n, r, s);\n    }\n  };\n}\nexport { e as provide };","map":{"version":3,"names":["e","_ref","context","n","r","i","WeakMap","addInitializer","set","t","get","call","setValue","init","constructor","o","Object","getOwnPropertyDescriptor","s","configurable","enumerable","defineProperty","provide"],"sources":["C:\\Users\\nolan\\tasks\\HenHacks2025\\henhack25\\node_modules\\@lit\\context\\src\\lib\\decorators\\provide.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ReactiveElement} from '@lit/reactive-element';\nimport {Context} from '../create-context.js';\nimport {ContextProvider} from '../controllers/context-provider.js';\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\n/**\n * A property decorator that adds a ContextProvider controller to the component\n * making it respond to any `context-request` events from its children consumer.\n *\n * @param context A Context identifier value created via `createContext`\n *\n * @example\n *\n * ```ts\n * import {provide} from '@lit/context';\n * import {Logger} from 'my-logging-library';\n * import {loggerContext} from './logger-context.js';\n *\n * class MyElement {\n *   @provide({context: loggerContext})\n *   logger = new Logger();\n * }\n * ```\n * @category Decorator\n */\nexport function provide<ValueType>({\n  context: context,\n}: {\n  context: Context<unknown, ValueType>;\n}): ProvideDecorator<ValueType> {\n  return ((\n    protoOrTarget: ClassAccessorDecoratorTarget<ReactiveElement, ValueType>,\n    nameOrContext:\n      | PropertyKey\n      | ClassAccessorDecoratorContext<ReactiveElement, ValueType>\n  ) => {\n    // Map of instances to controllers\n    const controllerMap = new WeakMap<\n      ReactiveElement,\n      ContextProvider<Context<unknown, ValueType>>\n    >();\n    if (typeof nameOrContext === 'object') {\n      // Standard decorators branch\n      nameOrContext.addInitializer(function () {\n        controllerMap.set(this, new ContextProvider(this, {context}));\n      });\n      return {\n        get(this: ReactiveElement) {\n          return protoOrTarget.get.call(this);\n        },\n        set(this: ReactiveElement, value: ValueType) {\n          controllerMap.get(this)?.setValue(value);\n          return protoOrTarget.set.call(this, value);\n        },\n        init(this: ReactiveElement, value: ValueType) {\n          controllerMap.get(this)?.setValue(value);\n          return value;\n        },\n      };\n    } else {\n      // Experimental decorators branch\n      (protoOrTarget.constructor as typeof ReactiveElement).addInitializer(\n        (element: ReactiveElement): void => {\n          controllerMap.set(element, new ContextProvider(element, {context}));\n        }\n      );\n      // proxy any existing setter for this property and use it to\n      // notify the controller of an updated value\n      const descriptor = Object.getOwnPropertyDescriptor(\n        protoOrTarget,\n        nameOrContext\n      );\n      let newDescriptor: PropertyDescriptor;\n      if (descriptor === undefined) {\n        const valueMap = new WeakMap<ReactiveElement, ValueType>();\n        newDescriptor = {\n          get(this: ReactiveElement) {\n            return valueMap.get(this);\n          },\n          set(this: ReactiveElement, value: ValueType) {\n            controllerMap.get(this)!.setValue(value);\n            valueMap.set(this, value);\n          },\n          configurable: true,\n          enumerable: true,\n        };\n      } else {\n        const oldSetter = descriptor.set;\n        newDescriptor = {\n          ...descriptor,\n          set(this: ReactiveElement, value: ValueType) {\n            controllerMap.get(this)!.setValue(value);\n            oldSetter?.call(this, value);\n          },\n        };\n      }\n      Object.defineProperty(protoOrTarget, nameOrContext, newDescriptor);\n      return;\n    }\n  }) as ProvideDecorator<ValueType>;\n}\n\n/**\n * Generates a public interface type that removes private and protected fields.\n * This allows accepting otherwise compatible versions of the type (e.g. from\n * multiple copies of the same package in `node_modules`).\n */\ntype Interface<T> = {\n  [K in keyof T]: T[K];\n};\n\ntype ProvideDecorator<ContextType> = {\n  // legacy\n  <\n    K extends PropertyKey,\n    Proto extends Interface<Omit<ReactiveElement, 'renderRoot'>>,\n  >(\n    protoOrDescriptor: Proto,\n    name?: K\n  ): FieldMustMatchContextType<Proto, K, ContextType>;\n\n  // standard\n  <\n    C extends Interface<Omit<ReactiveElement, 'renderRoot'>>,\n    V extends ContextType,\n  >(\n    value: ClassAccessorDecoratorTarget<C, V>,\n    context: ClassAccessorDecoratorContext<C, V>\n  ): void;\n};\n\n// Note TypeScript requires the return type of a decorator to be `void | any`\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype DecoratorReturn = void | any;\n\ntype FieldMustMatchContextType<Obj, Key extends PropertyKey, ContextType> =\n  // First we check whether the object has the property as a required field\n  Obj extends Record<Key, infer ProvidingType>\n    ? // Ok, it does, just check whether it's ok to assign the\n      // provided type to the consuming field\n      [ProvidingType] extends [ContextType]\n      ? DecoratorReturn\n      : {\n          message: 'providing field not assignable to context';\n          context: ContextType;\n          provided: ProvidingType;\n        }\n    : // Next we check whether the object has the property as an optional field\n      Obj extends Partial<Record<Key, infer Providing>>\n      ? // Check assignability again. Note that we have to include undefined\n        // here on the providing type because it's optional.\n        [Providing | undefined] extends [ContextType]\n        ? DecoratorReturn\n        : {\n            message: 'providing field not assignable to context';\n            context: ContextType;\n            consuming: Providing | undefined;\n          }\n      : // Ok, the field isn't present, so either someone's using provide\n        // manually, i.e. not as a decorator (maybe don't do that! but if you do,\n        // you're on your own for your type checking, sorry), or the field is\n        // private, in which case we can't check it.\n        DecoratorReturn;\n"],"mappings":";;;;;;SAqCgBA,EAAAC,IAAA,EACL;EAAA,IADK;IACdC,OAAA,EAASF;EAAA,IAAAC,IAAA;EAIT,OAAQ,CACNE,CAAA,EACAC,CAAA;IAKA,MAAMC,CAAA,GAAgB,IAAIC,OAAA;IAI1B,IAA6B,mBAAlBF,CAAA,EAKT,OAHAA,CAAA,CAAcG,cAAA,CAAe;MAC3BF,CAAA,CAAcG,GAAA,CAAI,MAAM,IAAIC,CAAA,CAAgB,MAAM;QAACP,OAAA,EAAAF;MAAA,GACrD;IAAA,IACO;MACLU,IAAA;QACE,OAAOP,CAAA,CAAcO,GAAA,CAAIC,IAAA,CAAK,KAC/B;MAAA;MACDH,IAA2BC,CAAA;QAEzB,OADAJ,CAAA,CAAcK,GAAA,CAAI,OAAOE,QAAA,CAASH,CAAA,GAC3BN,CAAA,CAAcK,GAAA,CAAIG,IAAA,CAAK,MAAMF,CAAA,CACrC;MAAA;MACDI,KAA4BJ,CAAA;QAE1B,OADAJ,CAAA,CAAcK,GAAA,CAAI,OAAOE,QAAA,CAASH,CAAA,GAC3BA,CACR;MAAA;IAAA;IAEE;MAEJN,CAAA,CAAcW,WAAA,CAAuCP,cAAA,CACnDJ,CAAA;QACCE,CAAA,CAAcG,GAAA,CAAIL,CAAA,EAAS,IAAIM,CAAA,CAAgBN,CAAA,EAAS;UAACD,OAAA,EAAAF;QAAA,GAAU;MAAA;MAKvE,MAAMe,CAAA,GAAaC,MAAA,CAAOC,wBAAA,CACxBd,CAAA,EACAC,CAAA;MAEF,IAAIc,CAAA;MACJ,SAAmB,MAAfH,CAAA,EAA0B;QAC5B,MAAMN,CAAA,GAAW,IAAIH,OAAA;QACrBY,CAAA,GAAgB;UACdR,IAAA;YACE,OAAOD,CAAA,CAASC,GAAA,CAAI,KACrB;UAAA;UACDF,IAA2BR,CAAA;YACzBK,CAAA,CAAcK,GAAA,CAAI,MAAOE,QAAA,CAASZ,CAAA,GAClCS,CAAA,CAASD,GAAA,CAAI,MAAMR,CAAA,CACpB;UAAA;UACDmB,YAAA,GAAc;UACdC,UAAA,GAAY;QAAA,CAEf;MAAA,OAAM;QACL,MAAMX,CAAA,GAAYM,CAAA,CAAWP,GAAA;QAC7BU,CAAA,GAAgB;UAAA,GACXH,CAAA;UACHP,IAA2BR,CAAA;YACzBK,CAAA,CAAcK,GAAA,CAAI,MAAOE,QAAA,CAASZ,CAAA,GAClCS,CAAA,EAAWE,IAAA,CAAK,MAAMX,CAAA,CACvB;UAAA;QAAA,CAEJ;MAAA;MAED,YADAgB,MAAA,CAAOK,cAAA,CAAelB,CAAA,EAAeC,CAAA,EAAec,CAAA,CAErD;IAAA;EACF,CACH;AAAA;AAAA,SAAAlB,CAAA,IAAAsB,OAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}