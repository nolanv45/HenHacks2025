{"ast":null,"code":"import { lazyMetaGroupJoiner, lazyMetaItemJoiner, lazyMetaSubItemJoiner } from \"./chunk-PGHUBTOM.js\";\n\n// src/lazyLoad.ts\nimport { Deferred, camelToKebab, isEsriInternalEnv } from \"@arcgis/components-utils\";\n\n// src/devOnlyDetectIncorrectLazyUsages.ts\nfunction devOnlyDetectIncorrectLazyUsages(LitClass) {\n  const genericPrototype = LitClass.prototype;\n  const descriptor = Object.getOwnPropertyDescriptor(genericPrototype, \"innerText\");\n  if (descriptor !== void 0 && descriptor.get === descriptor.set) {\n    return;\n  }\n  const allowList = /* @__PURE__ */new Set([\n  // We shouldn't be overwriting this property\n  \"constructor\",\n  // Called by Lit - we proxy it to this.el in ProxyComponent\n  \"setAttribute\",\n  // Called by Lit SSR - we proxy it to this.el in ProxyComponent\n  \"removeAttribute\",\n  // Called by Lit - we proxy it to this.el in ProxyComponent\n  \"isConnected\",\n  // Called by Lit, but only in dev mode for warnings, so we don't have to proxy.\n  \"localName\",\n  // Called by Lit Context - we proxy it to this.el in ProxyComponent.\n  // Interestingly, they never call removeEventListener.\n  \"addEventListener\"]);\n  const customErrorMessages = {\n    addEventListener: \"use this.listen() or this.el.addEventListener()\"\n  };\n  Object.entries({\n    ...Object.getOwnPropertyDescriptors(HTMLElement.prototype),\n    ...Object.getOwnPropertyDescriptors(Element.prototype),\n    ...Object.getOwnPropertyDescriptors(Node.prototype),\n    ...Object.getOwnPropertyDescriptors(EventTarget.prototype)\n  }).forEach(_ref => {\n    let [key, value] = _ref;\n    if (allowList.has(key)) {\n      return;\n    }\n    const callback = function () {\n      if (key === \"hasAttribute\" && (arguments.length <= 0 ? undefined : arguments[0]) === \"defer-hydration\") {\n        return false;\n      }\n      throw new Error(`You should not be trying to access this.${key} directly as it won't work correctly in lazy-builds. Instead, ${customErrorMessages[key] ?? `use this.el.${key}`}`);\n    };\n    if (typeof value.value === \"function\") {\n      genericPrototype[key] = callback;\n    } else {\n      Object.defineProperty(genericPrototype, key, {\n        get: callback,\n        set: callback\n      });\n    }\n  });\n}\n\n// src/lifecycleSupport.ts\nfunction attachToAncestor(child) {\n  let ancestor = child;\n  while (ancestor = ancestor.parentNode ?? ancestor.host) {\n    if (ancestor?.constructor?.lumina) {\n      const litParent = ancestor;\n      if (!litParent.manager?.loadedCalled) {\n        litParent._offspring.push(child);\n      }\n      return litParent._postLoad.promise;\n    }\n  }\n  return false;\n}\n\n// src/lazyLoad.ts\nvar makeDefineCustomElements = (runtime, structure) => function defineCustomElements(windowOrOptions, options) {\n  if (!globalThis.customElements) {\n    return;\n  }\n  const resolvedOptions = options ?? windowOrOptions ?? {};\n  const resourcesUrl = resolvedOptions.resourcesUrl;\n  if (resourcesUrl) {\n    runtime.setAssetPath(resourcesUrl);\n  }\n  Object.entries(structure).forEach(createLazyElement);\n};\nfunction createLazyElement(_ref2) {\n  let [tagName, [load, compactMeta = \"\"]] = _ref2;\n  if (customElements.get(tagName)) {\n    return;\n  }\n  const [compactObservedProps, compactAsyncMethods, compactSyncMethods] = compactMeta.split(lazyMetaGroupJoiner);\n  const observedProps = compactObservedProps ? compactObservedProps?.split(lazyMetaItemJoiner).map(parseCondensedProp) : void 0;\n  const observedProperties = observedProps?.map(_ref3 => {\n    let [property] = _ref3;\n    return property;\n  });\n  const ProxyClass = class extends ProxyComponent {\n    static #_ = (() => this.observedAttributes = observedProps?.map(_ref4 => {\n      let [, attribute] = _ref4;\n      return attribute;\n    }).filter(attribute => attribute !== \"\"))();\n    static #_2 = (() => this._properties = observedProperties)();\n    static #_3 = (() => this._asyncMethods = compactAsyncMethods ? compactAsyncMethods?.split(lazyMetaItemJoiner) : void 0)();\n    static #_4 = (() => this._syncMethods = compactSyncMethods?.split(lazyMetaItemJoiner))();\n    static #_5 = (() => this._name = tagName)();\n    constructor() {\n      const isFirstInstanceOfType = !ProxyClass._loadPromise;\n      if (isFirstInstanceOfType) {\n        ProxyClass._loadPromise = load();\n        ProxyClass._initializePrototype();\n      }\n      super();\n    }\n  };\n  customElements.define(tagName, ProxyClass);\n  if (process.env.NODE_ENV !== \"production\") {\n    globalThis.devOnly$ownTagNames?.add(tagName);\n  }\n}\nvar defineProperty = Object.defineProperty;\nfunction parseCondensedProp(propAndAttribute) {\n  const name = propAndAttribute.split(lazyMetaSubItemJoiner);\n  return name.length === 1 ? [name[0], camelToKebab(name[0])] : name;\n}\nvar HtmlElement = globalThis.HTMLElement ?? parseCondensedProp;\nvar ProxyComponent = class extends HtmlElement {\n  constructor() {\n    super();\n    /** @internal */\n    this._store = {};\n    /**\n     * If attributeChangedCallback() is called before the LitElement is loaded,\n     * store the attributes here, and replay later\n     */\n    this._pendingAttributes = [];\n    /**\n     * Resolved once LitElement's load() is complete.\n     * Not read inside of this class, but needed for LitElement to determine if\n     * it's closest ancestor finished load()\n     */\n    this._postLoad = new Deferred();\n    /**\n     * Resolved once LitElement's loaded() is complete\n     */\n    this._postLoaded = new Deferred();\n    /**\n     * Direct offspring that should be awaited before loaded() is emitted\n     */\n    this._offspring = [];\n    if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv()) {\n      this._hmrSetProps = /* @__PURE__ */new Set();\n      this._hmrSetAttributes = /* @__PURE__ */new Set();\n      globalThis.devOnly$createdElements ??= [];\n      globalThis.devOnly$createdElements.push(new WeakRef(this));\n    }\n    this._saveInstanceProperties();\n    const ProxyClass = this.constructor;\n    if (ProxyClass._LitConstructor) {\n      this._initializeComponent({\n        a: ProxyClass._LitConstructor\n      });\n    } else {\n      void ProxyClass._loadPromise.then(this._initializeComponent.bind(this)).catch(error => {\n        this._postLoaded.reject(error);\n        setTimeout(() => {\n          throw error;\n        });\n      });\n    }\n    if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv()) {\n      ProxyClass._hmrInstances ??= [];\n      ProxyClass._hmrInstances.push(new WeakRef(this));\n      Object.defineProperty(this, \"_store\", {\n        value: this._store,\n        enumerable: false,\n        configurable: true\n      });\n    }\n  }\n  static #_ = (() => this.lumina = true)();\n  /** @internal */\n  static _initializePrototype() {\n    this._properties?.forEach(this._bindProp, this);\n    this._asyncMethods?.forEach(this._bindAsync, this);\n    this._syncMethods?.forEach(this._bindSync, this);\n  }\n  static _bindProp(propName) {\n    defineProperty(this.prototype, propName, {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return this._store[propName];\n      },\n      set(value) {\n        this._store[propName] = value;\n        if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv()) {\n          this._hmrSetProps.add(propName);\n        }\n      }\n    });\n  }\n  static _bindAsync(methodName) {\n    defineProperty(this.prototype, methodName, {\n      async value() {\n        if (!this._litElement) {\n          await this._postLoaded.promise;\n        }\n        const genericLitElement = this._litElement;\n        return await genericLitElement[methodName](...arguments);\n      },\n      configurable: true\n    });\n  }\n  static _bindSync(methodName) {\n    defineProperty(this.prototype, methodName, {\n      value() {\n        if (process.env.NODE_ENV !== \"production\" && !this._litElement) {\n          const ProxyClass = this.constructor;\n          throw new Error(`Tried to call method ${methodName}() on <${ProxyClass._name}> component before it's fully loaded. Please do 'await component.componentOnReady();' before calling this method.`);\n        }\n        const genericLitElement = this._litElement;\n        return genericLitElement[methodName](...arguments);\n      },\n      configurable: true\n    });\n  }\n  get manager() {\n    return this._litElement?.manager;\n  }\n  /**\n   * Until the custom element is registered on the page, an instance of that\n   * element can be constructed and some properties on that instance set.\n   *\n   * These properties are set before the element prototype is set to this proxy\n   * class and thus none of our getters/setters are yet registered - such\n   * properties will be set by JavaScript on the instance directly.\n   *\n   * Once element is registered, the properties set in the meanwhile will shadow\n   * the getter/setters, and thus break reactivity. The fix is to delete these\n   * properties from the instance, and re-apply them once accessors are set.\n   *\n   * @example\n   * ```ts\n   * import { defineCustomElements } from '@arcgis/map-components';\n   * const map = document.createElement('arcgis-map');\n   * // This will shadow the getter/setters\n   * map.itemId = '...';\n   * // This finally defines the custom elements and sets the property accessors\n   * defineCustomElements();\n   * ```\n   *\n   * @remarks\n   * This is an equivalent of the __saveInstanceProperties method in Lit's\n   * ReactiveElement. Lit takes care of this on LitElement, but we have to take\n   * care of this on the lazy proxy\n   */\n  _saveInstanceProperties() {\n    const ProxyClass = this.constructor;\n    const genericThis = this;\n    ProxyClass._properties?.forEach(propName => {\n      if (Object.hasOwn(this, propName)) {\n        this._store[propName] = genericThis[propName];\n        delete genericThis[propName];\n      }\n    });\n  }\n  /*\n   * This method must be statically present rather than added later, or else,\n   * browsers won't call it. Same for connected and disconnected callbacks.\n   */\n  attributeChangedCallback(name, oldValue, newValue) {\n    this._litElement?.attributeChangedCallback(name, oldValue, newValue);\n    if (!this._litElement) {\n      this._pendingAttributes.push(name);\n    }\n    if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv()) {\n      this._hmrSetAttributes.add(name);\n    }\n  }\n  connectedCallback() {\n    if (this._litElement) {\n      this._litElement.connectedCallback?.();\n    } else {\n      queueMicrotask(() => {\n        this._ancestorLoad = attachToAncestor(this);\n      });\n    }\n  }\n  disconnectedCallback() {\n    this._litElement?.disconnectedCallback?.();\n  }\n  /**\n   * Create a promise that resolves once component is fully loaded\n   */\n  async componentOnReady() {\n    await this._postLoaded.promise;\n    return this;\n  }\n  /** @internal */\n  _initializeComponent(module) {\n    const ProxyClass = this.constructor;\n    const tagName = ProxyClass._name;\n    const store = this._store;\n    const LitConstructor = Object.values(module).find(LitConstructor2 => LitConstructor2.tagName === tagName);\n    if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv() && !LitConstructor) {\n      throw new Error(`Unable to find the LitElement class for the \"${tagName}\" custom element in the lazy-loaded module`);\n    }\n    const lazyTagName = process.env.NODE_ENV !== \"production\" && isEsriInternalEnv() ? (ProxyClass._hmrIndex ?? 0) === 0 ? `${tagName}--lazy` : `${tagName}--lazy-${ProxyClass._hmrIndex}` : `${tagName}--lazy`;\n    let parentClass = LitConstructor;\n    while (parentClass && !Object.hasOwn(parentClass, \"lumina\")) {\n      parentClass = Object.getPrototypeOf(parentClass);\n    }\n    patchLitElement(parentClass);\n    const isFirstInitialization = !ProxyClass._LitConstructor;\n    if (isFirstInitialization) {\n      ProxyClass._LitConstructor = LitConstructor;\n      customElements.define(lazyTagName, LitConstructor);\n    }\n    LitConstructor.lazy = this;\n    const litElement = document.createElement(lazyTagName);\n    LitConstructor.lazy = void 0;\n    if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv()) {\n      Object.defineProperty(this, \"_litElement\", {\n        value: litElement,\n        configurable: true,\n        enumerable: false\n      });\n    } else {\n      this._litElement = litElement;\n    }\n    this._store = litElement;\n    this._pendingAttributes.forEach(name => {\n      const value = this.getAttribute(name);\n      litElement.attributeChangedCallback(name,\n      // Lit doesn't look at this value, thus even if attribute already exists, that's ok\n      null, value);\n    });\n    Object.entries(store).forEach(syncLitElement, litElement);\n    if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv()) {\n      const litObserved = LitConstructor.observedAttributes ?? [];\n      const lazyObserved = ProxyClass.observedAttributes ?? [];\n      const missingFromLazy = litObserved.filter(attribute => !lazyObserved.includes(attribute));\n      const missingFromLit = lazyObserved.filter(attribute => !litObserved.includes(attribute));\n      if (missingFromLazy.length > 0) {\n        console.warn(`The following attributes on <${ProxyClass._name}> are present on the Lit element, but are missing from the lazy proxy component: ${missingFromLazy.join(\", \")}. This either indicates a bug in Lumina, or you are creating the attribute dynamically in a way that compiler cannot infer statically. For these attributes, lazy-loading version of your component won't work correctly, thus this must be resolved`);\n      }\n      if (missingFromLit.length > 0) {\n        console.warn(`The following attributes on <${ProxyClass._name}> are defined on the lazy proxy component, but not on the actual Lit element: ${missingFromLit.join(\", \")}. This either indicates a bug in Lumina, or you are creating the attribute dynamically in a way that compiler cannot infer statically. This is a non-critical issue, but does indicate that something is going wrong and should be fixed`);\n      }\n    }\n    const isStillConnected = this.isConnected;\n    if (isStillConnected || this._ancestorLoad) {\n      litElement.connectedCallback?.();\n      if (!isStillConnected) {\n        litElement.disconnectedCallback();\n      }\n    }\n  }\n  /**\n   * Implemented on the proxy for compatibility with Lit Context.\n   */\n  addController() {}\n  /**\n   * Implemented on the proxy for compatibility with Lit Context.\n   */\n  requestUpdate() {\n    this._litElement?.requestUpdate();\n  }\n};\nfunction syncLitElement(_ref5) {\n  let [key, value] = _ref5;\n  this[key] = value;\n}\nfunction patchLitElement(parentClass) {\n  const litElementPrototype = parentClass.prototype;\n  const elementPrototype = Element.prototype;\n  const alreadyPatched = Object.hasOwn(litElementPrototype, \"isConnected\");\n  if (!alreadyPatched) {\n    litElementPrototype.setAttribute = function (qualifiedName, value) {\n      elementPrototype.setAttribute.call(this.el, qualifiedName, value);\n    };\n    litElementPrototype.removeAttribute = function (qualifiedName) {\n      elementPrototype.removeAttribute.call(this.el, qualifiedName);\n    };\n    defineProperty(litElementPrototype, \"isConnected\", {\n      get() {\n        return Reflect.get(elementPrototype, \"isConnected\", this.el);\n      }\n    });\n  }\n  if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv()) {\n    devOnlyDetectIncorrectLazyUsages(parentClass);\n  }\n}\n\n// src/utils.ts\nvar noShadowRoot = {};\nexport { attachToAncestor, makeDefineCustomElements, ProxyComponent, noShadowRoot };","map":{"version":3,"names":["lazyMetaGroupJoiner","lazyMetaItemJoiner","lazyMetaSubItemJoiner","Deferred","camelToKebab","isEsriInternalEnv","devOnlyDetectIncorrectLazyUsages","LitClass","genericPrototype","prototype","descriptor","Object","getOwnPropertyDescriptor","get","set","allowList","Set","customErrorMessages","addEventListener","entries","getOwnPropertyDescriptors","HTMLElement","Element","Node","EventTarget","forEach","_ref","key","value","has","callback","arguments","length","undefined","Error","defineProperty","attachToAncestor","child","ancestor","parentNode","host","constructor","lumina","litParent","manager","loadedCalled","_offspring","push","_postLoad","promise","makeDefineCustomElements","runtime","structure","defineCustomElements","windowOrOptions","options","globalThis","customElements","resolvedOptions","resourcesUrl","setAssetPath","createLazyElement","_ref2","tagName","load","compactMeta","compactObservedProps","compactAsyncMethods","compactSyncMethods","split","observedProps","map","parseCondensedProp","observedProperties","_ref3","property","ProxyClass","ProxyComponent","_","observedAttributes","_ref4","attribute","filter","_2","_properties","_3","_asyncMethods","_4","_syncMethods","_5","_name","isFirstInstanceOfType","_loadPromise","_initializePrototype","define","process","env","NODE_ENV","devOnly$ownTagNames","add","propAndAttribute","name","HtmlElement","_store","_pendingAttributes","_postLoaded","_hmrSetProps","_hmrSetAttributes","devOnly$createdElements","WeakRef","_saveInstanceProperties","_LitConstructor","_initializeComponent","a","then","bind","catch","error","reject","setTimeout","_hmrInstances","enumerable","configurable","_bindProp","_bindAsync","_bindSync","propName","methodName","_litElement","genericLitElement","genericThis","hasOwn","attributeChangedCallback","oldValue","newValue","connectedCallback","queueMicrotask","_ancestorLoad","disconnectedCallback","componentOnReady","module","store","LitConstructor","values","find","LitConstructor2","lazyTagName","_hmrIndex","parentClass","getPrototypeOf","patchLitElement","isFirstInitialization","lazy","litElement","document","createElement","getAttribute","syncLitElement","litObserved","lazyObserved","missingFromLazy","includes","missingFromLit","console","warn","join","isStillConnected","isConnected","addController","requestUpdate","_ref5","litElementPrototype","elementPrototype","alreadyPatched","setAttribute","qualifiedName","call","el","removeAttribute","Reflect","noShadowRoot"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/lumina/dist/chunk-NO7HOBNA.js"],"sourcesContent":["import {\n  lazyMetaGroupJoiner,\n  lazyMetaItemJoiner,\n  lazyMetaSubItemJoiner\n} from \"./chunk-PGHUBTOM.js\";\n\n// src/lazyLoad.ts\nimport { Deferred, camelToKebab, isEsriInternalEnv } from \"@arcgis/components-utils\";\n\n// src/devOnlyDetectIncorrectLazyUsages.ts\nfunction devOnlyDetectIncorrectLazyUsages(LitClass) {\n  const genericPrototype = LitClass.prototype;\n  const descriptor = Object.getOwnPropertyDescriptor(genericPrototype, \"innerText\");\n  if (descriptor !== void 0 && descriptor.get === descriptor.set) {\n    return;\n  }\n  const allowList = /* @__PURE__ */ new Set([\n    // We shouldn't be overwriting this property\n    \"constructor\",\n    // Called by Lit - we proxy it to this.el in ProxyComponent\n    \"setAttribute\",\n    // Called by Lit SSR - we proxy it to this.el in ProxyComponent\n    \"removeAttribute\",\n    // Called by Lit - we proxy it to this.el in ProxyComponent\n    \"isConnected\",\n    // Called by Lit, but only in dev mode for warnings, so we don't have to proxy.\n    \"localName\",\n    // Called by Lit Context - we proxy it to this.el in ProxyComponent.\n    // Interestingly, they never call removeEventListener.\n    \"addEventListener\"\n  ]);\n  const customErrorMessages = {\n    addEventListener: \"use this.listen() or this.el.addEventListener()\"\n  };\n  Object.entries({\n    ...Object.getOwnPropertyDescriptors(HTMLElement.prototype),\n    ...Object.getOwnPropertyDescriptors(Element.prototype),\n    ...Object.getOwnPropertyDescriptors(Node.prototype),\n    ...Object.getOwnPropertyDescriptors(EventTarget.prototype)\n  }).forEach(([key, value]) => {\n    if (allowList.has(key)) {\n      return;\n    }\n    const callback = (...args) => {\n      if (key === \"hasAttribute\" && args[0] === \"defer-hydration\") {\n        return false;\n      }\n      throw new Error(\n        `You should not be trying to access this.${key} directly as it won't work correctly in lazy-builds. Instead, ${customErrorMessages[key] ?? `use this.el.${key}`}`\n      );\n    };\n    if (typeof value.value === \"function\") {\n      genericPrototype[key] = callback;\n    } else {\n      Object.defineProperty(genericPrototype, key, { get: callback, set: callback });\n    }\n  });\n}\n\n// src/lifecycleSupport.ts\nfunction attachToAncestor(child) {\n  let ancestor = child;\n  while (ancestor = ancestor.parentNode ?? ancestor.host) {\n    if (ancestor?.constructor?.lumina) {\n      const litParent = ancestor;\n      if (!litParent.manager?.loadedCalled) {\n        litParent._offspring.push(child);\n      }\n      return litParent._postLoad.promise;\n    }\n  }\n  return false;\n}\n\n// src/lazyLoad.ts\nvar makeDefineCustomElements = (runtime, structure) => function defineCustomElements(windowOrOptions, options) {\n  if (!globalThis.customElements) {\n    return;\n  }\n  const resolvedOptions = options ?? windowOrOptions ?? {};\n  const resourcesUrl = resolvedOptions.resourcesUrl;\n  if (resourcesUrl) {\n    runtime.setAssetPath(resourcesUrl);\n  }\n  Object.entries(structure).forEach(createLazyElement);\n};\nfunction createLazyElement([tagName, [load, compactMeta = \"\"]]) {\n  if (customElements.get(tagName)) {\n    return;\n  }\n  const [compactObservedProps, compactAsyncMethods, compactSyncMethods] = compactMeta.split(lazyMetaGroupJoiner);\n  const observedProps = compactObservedProps ? compactObservedProps?.split(lazyMetaItemJoiner).map(parseCondensedProp) : void 0;\n  const observedProperties = observedProps?.map(([property]) => property);\n  const ProxyClass = class extends ProxyComponent {\n    static {\n      this.observedAttributes = observedProps?.map(([, attribute]) => attribute).filter((attribute) => attribute !== \"\");\n    }\n    static {\n      this._properties = observedProperties;\n    }\n    static {\n      this._asyncMethods = compactAsyncMethods ? compactAsyncMethods?.split(lazyMetaItemJoiner) : void 0;\n    }\n    static {\n      this._syncMethods = compactSyncMethods?.split(lazyMetaItemJoiner);\n    }\n    static {\n      this._name = tagName;\n    }\n    constructor() {\n      const isFirstInstanceOfType = !ProxyClass._loadPromise;\n      if (isFirstInstanceOfType) {\n        ProxyClass._loadPromise = load();\n        ProxyClass._initializePrototype();\n      }\n      super();\n    }\n  };\n  customElements.define(tagName, ProxyClass);\n  if (process.env.NODE_ENV !== \"production\") {\n    globalThis.devOnly$ownTagNames?.add(tagName);\n  }\n}\nvar defineProperty = Object.defineProperty;\nfunction parseCondensedProp(propAndAttribute) {\n  const name = propAndAttribute.split(lazyMetaSubItemJoiner);\n  return name.length === 1 ? [name[0], camelToKebab(name[0])] : name;\n}\nvar HtmlElement = globalThis.HTMLElement ?? parseCondensedProp;\nvar ProxyComponent = class extends HtmlElement {\n  constructor() {\n    super();\n    /** @internal */\n    this._store = {};\n    /**\n     * If attributeChangedCallback() is called before the LitElement is loaded,\n     * store the attributes here, and replay later\n     */\n    this._pendingAttributes = [];\n    /**\n     * Resolved once LitElement's load() is complete.\n     * Not read inside of this class, but needed for LitElement to determine if\n     * it's closest ancestor finished load()\n     */\n    this._postLoad = new Deferred();\n    /**\n     * Resolved once LitElement's loaded() is complete\n     */\n    this._postLoaded = new Deferred();\n    /**\n     * Direct offspring that should be awaited before loaded() is emitted\n     */\n    this._offspring = [];\n    if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv()) {\n      this._hmrSetProps = /* @__PURE__ */ new Set();\n      this._hmrSetAttributes = /* @__PURE__ */ new Set();\n      globalThis.devOnly$createdElements ??= [];\n      globalThis.devOnly$createdElements.push(new WeakRef(this));\n    }\n    this._saveInstanceProperties();\n    const ProxyClass = this.constructor;\n    if (ProxyClass._LitConstructor) {\n      this._initializeComponent({ a: ProxyClass._LitConstructor });\n    } else {\n      void ProxyClass._loadPromise.then(this._initializeComponent.bind(this)).catch((error) => {\n        this._postLoaded.reject(error);\n        setTimeout(() => {\n          throw error;\n        });\n      });\n    }\n    if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv()) {\n      ProxyClass._hmrInstances ??= [];\n      ProxyClass._hmrInstances.push(new WeakRef(this));\n      Object.defineProperty(this, \"_store\", {\n        value: this._store,\n        enumerable: false,\n        configurable: true\n      });\n    }\n  }\n  static {\n    this.lumina = true;\n  }\n  /** @internal */\n  static _initializePrototype() {\n    this._properties?.forEach(this._bindProp, this);\n    this._asyncMethods?.forEach(this._bindAsync, this);\n    this._syncMethods?.forEach(this._bindSync, this);\n  }\n  static _bindProp(propName) {\n    defineProperty(this.prototype, propName, {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return this._store[propName];\n      },\n      set(value) {\n        this._store[propName] = value;\n        if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv()) {\n          this._hmrSetProps.add(propName);\n        }\n      }\n    });\n  }\n  static _bindAsync(methodName) {\n    defineProperty(this.prototype, methodName, {\n      async value(...args) {\n        if (!this._litElement) {\n          await this._postLoaded.promise;\n        }\n        const genericLitElement = this._litElement;\n        return await genericLitElement[methodName](...args);\n      },\n      configurable: true\n    });\n  }\n  static _bindSync(methodName) {\n    defineProperty(this.prototype, methodName, {\n      value(...args) {\n        if (process.env.NODE_ENV !== \"production\" && !this._litElement) {\n          const ProxyClass = this.constructor;\n          throw new Error(\n            `Tried to call method ${methodName}() on <${ProxyClass._name}> component before it's fully loaded. Please do 'await component.componentOnReady();' before calling this method.`\n          );\n        }\n        const genericLitElement = this._litElement;\n        return genericLitElement[methodName](...args);\n      },\n      configurable: true\n    });\n  }\n  get manager() {\n    return this._litElement?.manager;\n  }\n  /**\n   * Until the custom element is registered on the page, an instance of that\n   * element can be constructed and some properties on that instance set.\n   *\n   * These properties are set before the element prototype is set to this proxy\n   * class and thus none of our getters/setters are yet registered - such\n   * properties will be set by JavaScript on the instance directly.\n   *\n   * Once element is registered, the properties set in the meanwhile will shadow\n   * the getter/setters, and thus break reactivity. The fix is to delete these\n   * properties from the instance, and re-apply them once accessors are set.\n   *\n   * @example\n   * ```ts\n   * import { defineCustomElements } from '@arcgis/map-components';\n   * const map = document.createElement('arcgis-map');\n   * // This will shadow the getter/setters\n   * map.itemId = '...';\n   * // This finally defines the custom elements and sets the property accessors\n   * defineCustomElements();\n   * ```\n   *\n   * @remarks\n   * This is an equivalent of the __saveInstanceProperties method in Lit's\n   * ReactiveElement. Lit takes care of this on LitElement, but we have to take\n   * care of this on the lazy proxy\n   */\n  _saveInstanceProperties() {\n    const ProxyClass = this.constructor;\n    const genericThis = this;\n    ProxyClass._properties?.forEach((propName) => {\n      if (Object.hasOwn(this, propName)) {\n        this._store[propName] = genericThis[propName];\n        delete genericThis[propName];\n      }\n    });\n  }\n  /*\n   * This method must be statically present rather than added later, or else,\n   * browsers won't call it. Same for connected and disconnected callbacks.\n   */\n  attributeChangedCallback(name, oldValue, newValue) {\n    this._litElement?.attributeChangedCallback(name, oldValue, newValue);\n    if (!this._litElement) {\n      this._pendingAttributes.push(name);\n    }\n    if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv()) {\n      this._hmrSetAttributes.add(name);\n    }\n  }\n  connectedCallback() {\n    if (this._litElement) {\n      this._litElement.connectedCallback?.();\n    } else {\n      queueMicrotask(() => {\n        this._ancestorLoad = attachToAncestor(this);\n      });\n    }\n  }\n  disconnectedCallback() {\n    this._litElement?.disconnectedCallback?.();\n  }\n  /**\n   * Create a promise that resolves once component is fully loaded\n   */\n  async componentOnReady() {\n    await this._postLoaded.promise;\n    return this;\n  }\n  /** @internal */\n  _initializeComponent(module) {\n    const ProxyClass = this.constructor;\n    const tagName = ProxyClass._name;\n    const store = this._store;\n    const LitConstructor = Object.values(module).find(\n      (LitConstructor2) => LitConstructor2.tagName === tagName\n    );\n    if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv() && !LitConstructor) {\n      throw new Error(\n        `Unable to find the LitElement class for the \"${tagName}\" custom element in the lazy-loaded module`\n      );\n    }\n    const lazyTagName = process.env.NODE_ENV !== \"production\" && isEsriInternalEnv() ? (ProxyClass._hmrIndex ?? 0) === 0 ? `${tagName}--lazy` : `${tagName}--lazy-${ProxyClass._hmrIndex}` : `${tagName}--lazy`;\n    let parentClass = LitConstructor;\n    while (parentClass && !Object.hasOwn(parentClass, \"lumina\")) {\n      parentClass = Object.getPrototypeOf(parentClass);\n    }\n    patchLitElement(parentClass);\n    const isFirstInitialization = !ProxyClass._LitConstructor;\n    if (isFirstInitialization) {\n      ProxyClass._LitConstructor = LitConstructor;\n      customElements.define(lazyTagName, LitConstructor);\n    }\n    LitConstructor.lazy = this;\n    const litElement = document.createElement(lazyTagName);\n    LitConstructor.lazy = void 0;\n    if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv()) {\n      Object.defineProperty(this, \"_litElement\", {\n        value: litElement,\n        configurable: true,\n        enumerable: false\n      });\n    } else {\n      this._litElement = litElement;\n    }\n    this._store = litElement;\n    this._pendingAttributes.forEach((name) => {\n      const value = this.getAttribute(name);\n      litElement.attributeChangedCallback(\n        name,\n        // Lit doesn't look at this value, thus even if attribute already exists, that's ok\n        null,\n        value\n      );\n    });\n    Object.entries(store).forEach(syncLitElement, litElement);\n    if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv()) {\n      const litObserved = LitConstructor.observedAttributes ?? [];\n      const lazyObserved = ProxyClass.observedAttributes ?? [];\n      const missingFromLazy = litObserved.filter((attribute) => !lazyObserved.includes(attribute));\n      const missingFromLit = lazyObserved.filter((attribute) => !litObserved.includes(attribute));\n      if (missingFromLazy.length > 0) {\n        console.warn(\n          `The following attributes on <${ProxyClass._name}> are present on the Lit element, but are missing from the lazy proxy component: ${missingFromLazy.join(\", \")}. This either indicates a bug in Lumina, or you are creating the attribute dynamically in a way that compiler cannot infer statically. For these attributes, lazy-loading version of your component won't work correctly, thus this must be resolved`\n        );\n      }\n      if (missingFromLit.length > 0) {\n        console.warn(\n          `The following attributes on <${ProxyClass._name}> are defined on the lazy proxy component, but not on the actual Lit element: ${missingFromLit.join(\", \")}. This either indicates a bug in Lumina, or you are creating the attribute dynamically in a way that compiler cannot infer statically. This is a non-critical issue, but does indicate that something is going wrong and should be fixed`\n        );\n      }\n    }\n    const isStillConnected = this.isConnected;\n    if (isStillConnected || this._ancestorLoad) {\n      litElement.connectedCallback?.();\n      if (!isStillConnected) {\n        litElement.disconnectedCallback();\n      }\n    }\n  }\n  /**\n   * Implemented on the proxy for compatibility with Lit Context.\n   */\n  addController() {\n  }\n  /**\n   * Implemented on the proxy for compatibility with Lit Context.\n   */\n  requestUpdate() {\n    this._litElement?.requestUpdate();\n  }\n};\nfunction syncLitElement([key, value]) {\n  this[key] = value;\n}\nfunction patchLitElement(parentClass) {\n  const litElementPrototype = parentClass.prototype;\n  const elementPrototype = Element.prototype;\n  const alreadyPatched = Object.hasOwn(litElementPrototype, \"isConnected\");\n  if (!alreadyPatched) {\n    litElementPrototype.setAttribute = function(qualifiedName, value) {\n      elementPrototype.setAttribute.call(this.el, qualifiedName, value);\n    };\n    litElementPrototype.removeAttribute = function(qualifiedName) {\n      elementPrototype.removeAttribute.call(this.el, qualifiedName);\n    };\n    defineProperty(litElementPrototype, \"isConnected\", {\n      get() {\n        return Reflect.get(elementPrototype, \"isConnected\", this.el);\n      }\n    });\n  }\n  if (process.env.NODE_ENV !== \"production\" && isEsriInternalEnv()) {\n    devOnlyDetectIncorrectLazyUsages(parentClass);\n  }\n}\n\n// src/utils.ts\nvar noShadowRoot = {};\n\nexport {\n  attachToAncestor,\n  makeDefineCustomElements,\n  ProxyComponent,\n  noShadowRoot\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}