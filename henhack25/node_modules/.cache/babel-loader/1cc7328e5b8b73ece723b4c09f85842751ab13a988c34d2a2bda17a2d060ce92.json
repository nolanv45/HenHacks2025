{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { fromValues as o } from \"../../../../../../core/libs/gl-matrix-2/factories/vec3f64.js\";\nimport { earth as t } from \"../../../../../../geometry/support/Ellipsoid.js\";\nimport { CloudsTextureChannels as e } from \"../../../../environment/Clouds.js\";\nimport { FadeState as a } from \"../../../../environment/CloudsParameters.js\";\nimport { cloudsHeight as r } from \"../../../../environment/weather.js\";\nimport { addMainLightDirection as i, addMainLightIntensity as c } from \"../shading/MainLighting.glsl.js\";\nimport { BooleanBindUniform as d } from \"../../shaderModules/BooleanBindUniform.js\";\nimport { Float3BindUniform as n } from \"../../shaderModules/Float3BindUniform.js\";\nimport { FloatBindUniform as l } from \"../../shaderModules/FloatBindUniform.js\";\nimport { glsl as s } from \"../../shaderModules/glsl.js\";\nimport { Matrix4BindUniform as u } from \"../../shaderModules/Matrix4BindUniform.js\";\nimport { TextureCubeBindUniform as m } from \"../../shaderModules/TextureCubeBindUniform.js\";\nfunction h(t) {\n  const r = t.fragment;\n  r.constants.add(\"radiusCloudsSquared\", \"float\", C).code.add(s`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos) {\nfloat B = 2.0 * dot(cameraPosition, dir);\nfloat C = dot(cameraPosition, cameraPosition) - radiusCloudsSquared;\nfloat det = B * B - 4.0 * C;\nfloat pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));\nreturn (cameraPosition + dir * pointIntDist) - spherePos;\n}`), r.uniforms.add(new l(\"radiusCurvatureCorrection\", ({\n    clouds: o\n  }) => o.parallax.radiusCurvatureCorrection)).code.add(s`vec3 correctForPlanetCurvature(vec3 dir) {\ndir.z = dir.z * (1.0 - radiusCurvatureCorrection) + radiusCurvatureCorrection;\nreturn dir;\n}`), r.code.add(s`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec) {\nreturn (rotMat * vec4(inVec, 0.0)).xyz;\n}`), i(r), c(r);\n  const h = o(.28, .175, .035);\n  r.constants.add(\"RIM_COLOR\", \"vec3\", h);\n  const v = .3,\n    f = 140,\n    p = .2,\n    g = 10,\n    w = .3;\n  r.code.add(s`\n    vec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds) {\n      float upDotLight = dot(cameraPosition, mainLightDirection);\n      float dirDotLight = max(dot(worldSpaceRay, mainLightDirection), 0.0);\n      float sunsetTransition = clamp(pow(max(upDotLight, 0.0), ${s.float(v)}), 0.0, 1.0);\n\n      // Base color of the clouds that depends on lighting of the sun and sky\n      vec3 ambientLight = calculateAmbientIrradiance(cameraPosition,  0.0);\n      vec3 combinedLight = clamp((mainLightIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));\n      vec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));\n\n      // Rim light around the edge of the clouds simulating scattering of the direct lun light\n      float scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);\n      float rimLightIntensity = 0.5 + 0.5 * pow(max(upDotLight, 0.0), 0.35);\n      vec3 directSunScattering = RIM_COLOR * rimLightIntensity * (pow(dirDotLight, ${s.float(f)})) * scatteringMod;\n\n      // Brighten the clouds around the sun at the sunsets\n      float additionalLight = ${s.float(p)} * pow(dirDotLight, ${s.float(g)}) * (1. - pow(sunsetTransition, ${s.float(w)})) ;\n\n      return vec3(baseCloudColor * (1.0 + additionalLight) + directSunScattering);\n    }\n  `), r.uniforms.add(new d(\"readChannelsRG\", o => o.clouds.readChannels === e.RG), new m(\"cubeMap\", o => o.clouds.data?.cubeMap?.colorTexture ?? null)).code.add(s`vec4 sampleCloud(vec3 rayDir, bool readOtherChannel) {\nvec4 s = texture(cubeMap, rayDir);\nbool readRG = readChannelsRG ^^ readOtherChannel;\ns = readRG ? vec4(vec3(s.r), s.g) : vec4(vec3(s.b), s.a);\nreturn length(s) == 0.0 ? vec4(s.rgb, 1.0) : s;\n}`), r.uniforms.add(new n(\"anchorPoint\", o => o.clouds.parallax.anchorPoint), new n(\"anchorPointNew\", o => o.clouds.parallaxNew.anchorPoint), new u(\"rotationClouds\", o => o.clouds.parallax.transform), new u(\"rotationCloudsNew\", o => o.clouds.parallaxNew.transform), new l(\"cloudsOpacity\", o => o.clouds.opacity), new l(\"fadeFactor\", o => o.clouds.fadeFactor), new d(\"crossFade\", o => o.clouds.fadeState === a.CROSS_FADE)).code.add(s`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition) {\nvec3 intersectionPoint = intersectWithCloudLayer(worldRay, cameraPosition, anchorPoint);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = sampleCloud(worldRayRotatedCorrected, crossFade);\nvec3 cameraPositionN = normalize(cameraPosition);\nvec4 cloudColor = vec4(calculateCloudColor(cameraPositionN, worldRay, cloudData), cloudData.a);\nif(crossFade) {\nintersectionPoint = intersectWithCloudLayer(worldRay, cameraPosition, anchorPointNew);\nworldRayRotated = rotateDirectionToAnchorPoint(rotationCloudsNew, normalize(intersectionPoint));\nworldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\ncloudData = sampleCloud(worldRayRotatedCorrected, false);\nvec4 cloudColorNew = vec4(calculateCloudColor(cameraPositionN, worldRay, cloudData), cloudData.a);\ncloudColor = mix(cloudColor, cloudColorNew, fadeFactor);\n}\nfloat totalTransmittance = length(cloudColor.rgb) == 0.0 ?\n1.0 :\nclamp(cloudColor.a * cloudsOpacity + (1.0 - cloudsOpacity), 0.0 , 1.0);\nreturn vec4(cloudColor.rgb, totalTransmittance);\n}`);\n}\nconst C = (t.radius + r) ** 2;\nexport { h as CloudsParallaxShading };","map":{"version":3,"names":["fromValues","o","earth","t","CloudsTextureChannels","e","FadeState","a","cloudsHeight","r","addMainLightDirection","i","addMainLightIntensity","c","BooleanBindUniform","d","Float3BindUniform","n","FloatBindUniform","l","glsl","s","Matrix4BindUniform","u","TextureCubeBindUniform","m","h","fragment","constants","add","C","code","uniforms","clouds","parallax","radiusCurvatureCorrection","v","f","p","g","w","float","readChannels","RG","data","cubeMap","colorTexture","anchorPoint","parallaxNew","transform","opacity","fadeFactor","fadeState","CROSS_FADE","radius","CloudsParallaxShading"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/CloudsParallaxShading.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{fromValues as o}from\"../../../../../../core/libs/gl-matrix-2/factories/vec3f64.js\";import{earth as t}from\"../../../../../../geometry/support/Ellipsoid.js\";import{CloudsTextureChannels as e}from\"../../../../environment/Clouds.js\";import{FadeState as a}from\"../../../../environment/CloudsParameters.js\";import{cloudsHeight as r}from\"../../../../environment/weather.js\";import{addMainLightDirection as i,addMainLightIntensity as c}from\"../shading/MainLighting.glsl.js\";import{BooleanBindUniform as d}from\"../../shaderModules/BooleanBindUniform.js\";import{Float3BindUniform as n}from\"../../shaderModules/Float3BindUniform.js\";import{FloatBindUniform as l}from\"../../shaderModules/FloatBindUniform.js\";import{glsl as s}from\"../../shaderModules/glsl.js\";import{Matrix4BindUniform as u}from\"../../shaderModules/Matrix4BindUniform.js\";import{TextureCubeBindUniform as m}from\"../../shaderModules/TextureCubeBindUniform.js\";function h(t){const r=t.fragment;r.constants.add(\"radiusCloudsSquared\",\"float\",C).code.add(s`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos) {\nfloat B = 2.0 * dot(cameraPosition, dir);\nfloat C = dot(cameraPosition, cameraPosition) - radiusCloudsSquared;\nfloat det = B * B - 4.0 * C;\nfloat pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));\nreturn (cameraPosition + dir * pointIntDist) - spherePos;\n}`),r.uniforms.add(new l(\"radiusCurvatureCorrection\",(({clouds:o})=>o.parallax.radiusCurvatureCorrection))).code.add(s`vec3 correctForPlanetCurvature(vec3 dir) {\ndir.z = dir.z * (1.0 - radiusCurvatureCorrection) + radiusCurvatureCorrection;\nreturn dir;\n}`),r.code.add(s`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec) {\nreturn (rotMat * vec4(inVec, 0.0)).xyz;\n}`),i(r),c(r);const h=o(.28,.175,.035);r.constants.add(\"RIM_COLOR\",\"vec3\",h);const v=.3,f=140,p=.2,g=10,w=.3;r.code.add(s`\n    vec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds) {\n      float upDotLight = dot(cameraPosition, mainLightDirection);\n      float dirDotLight = max(dot(worldSpaceRay, mainLightDirection), 0.0);\n      float sunsetTransition = clamp(pow(max(upDotLight, 0.0), ${s.float(v)}), 0.0, 1.0);\n\n      // Base color of the clouds that depends on lighting of the sun and sky\n      vec3 ambientLight = calculateAmbientIrradiance(cameraPosition,  0.0);\n      vec3 combinedLight = clamp((mainLightIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));\n      vec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));\n\n      // Rim light around the edge of the clouds simulating scattering of the direct lun light\n      float scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);\n      float rimLightIntensity = 0.5 + 0.5 * pow(max(upDotLight, 0.0), 0.35);\n      vec3 directSunScattering = RIM_COLOR * rimLightIntensity * (pow(dirDotLight, ${s.float(f)})) * scatteringMod;\n\n      // Brighten the clouds around the sun at the sunsets\n      float additionalLight = ${s.float(p)} * pow(dirDotLight, ${s.float(g)}) * (1. - pow(sunsetTransition, ${s.float(w)})) ;\n\n      return vec3(baseCloudColor * (1.0 + additionalLight) + directSunScattering);\n    }\n  `),r.uniforms.add(new d(\"readChannelsRG\",(o=>o.clouds.readChannels===e.RG)),new m(\"cubeMap\",(o=>o.clouds.data?.cubeMap?.colorTexture??null))).code.add(s`vec4 sampleCloud(vec3 rayDir, bool readOtherChannel) {\nvec4 s = texture(cubeMap, rayDir);\nbool readRG = readChannelsRG ^^ readOtherChannel;\ns = readRG ? vec4(vec3(s.r), s.g) : vec4(vec3(s.b), s.a);\nreturn length(s) == 0.0 ? vec4(s.rgb, 1.0) : s;\n}`),r.uniforms.add(new n(\"anchorPoint\",(o=>o.clouds.parallax.anchorPoint)),new n(\"anchorPointNew\",(o=>o.clouds.parallaxNew.anchorPoint)),new u(\"rotationClouds\",(o=>o.clouds.parallax.transform)),new u(\"rotationCloudsNew\",(o=>o.clouds.parallaxNew.transform)),new l(\"cloudsOpacity\",(o=>o.clouds.opacity)),new l(\"fadeFactor\",(o=>o.clouds.fadeFactor)),new d(\"crossFade\",(o=>o.clouds.fadeState===a.CROSS_FADE))).code.add(s`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition) {\nvec3 intersectionPoint = intersectWithCloudLayer(worldRay, cameraPosition, anchorPoint);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = sampleCloud(worldRayRotatedCorrected, crossFade);\nvec3 cameraPositionN = normalize(cameraPosition);\nvec4 cloudColor = vec4(calculateCloudColor(cameraPositionN, worldRay, cloudData), cloudData.a);\nif(crossFade) {\nintersectionPoint = intersectWithCloudLayer(worldRay, cameraPosition, anchorPointNew);\nworldRayRotated = rotateDirectionToAnchorPoint(rotationCloudsNew, normalize(intersectionPoint));\nworldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\ncloudData = sampleCloud(worldRayRotatedCorrected, false);\nvec4 cloudColorNew = vec4(calculateCloudColor(cameraPositionN, worldRay, cloudData), cloudData.a);\ncloudColor = mix(cloudColor, cloudColorNew, fadeFactor);\n}\nfloat totalTransmittance = length(cloudColor.rgb) == 0.0 ?\n1.0 :\nclamp(cloudColor.a * cloudsOpacity + (1.0 - cloudsOpacity), 0.0 , 1.0);\nreturn vec4(cloudColor.rgb, totalTransmittance);\n}`)}const C=(t.radius+r)**2;export{h as CloudsParallaxShading};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}