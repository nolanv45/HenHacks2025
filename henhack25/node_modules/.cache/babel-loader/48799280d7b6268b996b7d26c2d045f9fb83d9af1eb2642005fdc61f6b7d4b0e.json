{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { colorGamma as i } from \"../../../../../../colorUtils.js\";\nimport { neverReached as n } from \"../../../../../../core/compilerUtils.js\";\nimport { EvaluateAmbientLighting as e } from \"./EvaluateAmbientLighting.glsl.js\";\nimport { EvaluateAmbientOcclusion as o } from \"./EvaluateAmbientOcclusion.glsl.js\";\nimport { addMainLightDirection as t, addMainLightIntensity as a, applyShading as r } from \"./MainLighting.glsl.js\";\nimport { PhysicallyBasedRendering as l } from \"./PhysicallyBasedRendering.glsl.js\";\nimport { PBRMode as c } from \"./PhysicallyBasedRenderingParameters.glsl.js\";\nimport { PiUtils as d } from \"./PiUtils.glsl.js\";\nimport { BooleanBindUniform as s } from \"../../shaderModules/BooleanBindUniform.js\";\nimport { FloatBindUniform as m } from \"../../shaderModules/FloatBindUniform.js\";\nimport { glsl as g } from \"../../shaderModules/glsl.js\";\nimport { ambientBoost as h } from \"../../../lighting/SceneLighting.js\";\nfunction u(i) {\n  i.constants.add(\"ambientBoostFactor\", \"float\", h);\n}\nfunction p(i) {\n  i.uniforms.add(new m(\"lightingGlobalFactor\", i => i.lighting.globalFactor));\n}\nfunction v(h, v) {\n  const f = h.fragment;\n  switch (h.include(o, v), v.pbrMode !== c.Disabled && h.include(l, v), h.include(e, v), h.include(d), f.code.add(g`\n    const float GAMMA_SRGB = ${g.float(i)};\n    const float INV_GAMMA_SRGB = 0.4761904;\n    ${v.pbrMode === c.Disabled ? \"\" : \"const vec3 GROUND_REFLECTANCE = vec3(0.2);\"}\n  `), u(f), p(f), t(f), f.code.add(g`\n    float additionalDirectedAmbientLight(vec3 vPosWorld) {\n      float vndl = dot(${v.spherical ? g`normalize(vPosWorld)` : g`vec3(0.0, 0.0, 1.0)`}, mainLightDirection);\n      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n    }\n  `), a(f), f.code.add(g`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\nfloat additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);\nreturn (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;\n}`), v.pbrMode) {\n    case c.Disabled:\n    case c.WaterOnIntegratedMesh:\n    case c.Water:\n      h.include(r), f.code.add(g`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight) {\nvec3 mainLighting = applyShading(normalWorld, shadow);\nvec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);\nvec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\nvec3 totalLight = mainLighting + ambientLighting + additionalLight;\ntotalLight = min(totalLight, vec3(PI));\nvec3 outColor = vec3((albedoLinear / PI) * totalLight);\nreturn pow(outColor, vec3(INV_GAMMA_SRGB));\n}`);\n      break;\n    case c.Normal:\n    case c.Schematic:\n      f.code.add(g`const float fillLightIntensity = 0.25;\nconst float horizonLightDiffusion = 0.4;\nconst float additionalAmbientIrradianceFactor = 0.02;\nvec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec4 _emission, float additionalAmbientIrradiance)\n{\nvec3 viewDirection = -viewDir;\nvec3 h = normalize(viewDirection + mainLightDirection);\nPBRShadingInfo inputs;\ninputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\ninputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\nvec3 reflectedView = normalize(reflect(viewDirection, normal));\ninputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\ninputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\ninputs.ssao = ssao;\ninputs.metalness = mrr[0];\ninputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`), f.code.add(g`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\ninputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));\ninputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`), v.useFillLights ? f.uniforms.add(new s(\"hasFillLights\", i => i.enableFillLights)) : f.constants.add(\"hasFillLights\", \"bool\", !1), f.code.add(g`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);\nambientDir = ambientDir != vec3(0.0) ? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\ninputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;\nfloat NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\nvec3 mainLightIrradianceComponent = NdotL * (1.0 - shadow) * mainLightIntensity;\nvec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * mainLightIntensity * fillLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\ninputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\ninputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`), f.uniforms.add(new m(\"lightingSpecularStrength\", i => i.lighting.mainLight.specularStrength), new m(\"lightingEnvironmentStrength\", i => i.lighting.mainLight.environmentStrength)).code.add(g`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\nvec3 horizonRingH = normalize(viewDirection + horizonRingDir);\ninputs.NdotH_Horizon = dot(normal, horizonRingH);\nfloat NdotH = clamp(dot(normal, h), 0.0, 1.0);\nvec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(NdotH, inputs.roughness) * mainLightIntensity * (1.0 - shadow);\nvec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * mainLightIntensity * fillLightIntensity;\nvec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;\nfloat normalDirectionModifier = mix(1., min(mix(0.1, 2.0, (inputs.NdotNG + 1.) * 0.5), 1.0), clamp(inputs.roughness * 5.0, 0.0 , 1.0));\ninputs.skyRadianceToSurface = (ambientLightRadianceComponent + horizonLightRadianceComponent) * normalDirectionModifier + mainLightRadianceComponent;\ninputs.groundRadianceToSurface = 0.5 * GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) * normalDirectionModifier + mainLightRadianceComponent;\ninputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`), f.code.add(g`\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = _emission.rgb == vec3(0.0) ? _emission.rgb : pow(_emission.rgb, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        ${v.pbrMode !== c.Schematic || v.hasColorTexture ? g`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));` : g`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));`}\n        return outColor;\n      }\n    `);\n      break;\n    case c.Simplified:\n    case c.TerrainWithWater:\n      t(f), a(f), f.code.add(g`const float roughnessTerrain = 0.5;\nconst float specularityTerrain = 0.5;\nconst vec3 fresnelReflectionTerrain = vec3(0.04);\nvec3 evaluatePBRSimplifiedLighting(vec3 n, vec3 c, float shadow, float ssao, vec3 al, vec3 vd, vec3 nup) {\nvec3 viewDirection = -vd;\nvec3 h = normalize(viewDirection + mainLightDirection);\nfloat NdotL = clamp(dot(n, mainLightDirection), 0.001, 1.0);\nfloat NdotV = clamp(abs(dot(n, viewDirection)), 0.001, 1.0);\nfloat NdotH = clamp(dot(n, h), 0.0, 1.0);\nfloat NdotNG = clamp(dot(n, nup), -1.0, 1.0);\nvec3 albedoLinear = pow(c, vec3(GAMMA_SRGB));\nfloat lightness = 0.3 * albedoLinear[0] + 0.5 * albedoLinear[1] + 0.2 * albedoLinear[2];\nvec3 f0 = (0.85 * lightness + 0.15) * fresnelReflectionTerrain;\nvec3 f90 =  vec3(clamp(dot(f0, vec3(50.0 * 0.33)), 0.0, 1.0));\nvec3 mainLightIrradianceComponent = (1. - shadow) * NdotL * mainLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(n, ssao) + al;\nvec3 ambientSky = ambientLightIrradianceComponent + mainLightIrradianceComponent;\nvec3 indirectDiffuse = ((1.0 - NdotNG) * mainLightIrradianceComponent + (1.0 + NdotNG ) * ambientSky) * 0.5;\nvec3 outDiffColor = albedoLinear * (1.0 - f0) * indirectDiffuse / PI;\nvec3 mainLightRadianceComponent = normalDistribution(NdotH, roughnessTerrain) * mainLightIntensity;\nvec2 dfg = prefilteredDFGAnalytical(roughnessTerrain, NdotV);\nvec3 specularColor = f0 * dfg.x + f90 * dfg.y;\nvec3 specularComponent = specularityTerrain * specularColor * mainLightRadianceComponent;\nvec3 outColorLinear = outDiffColor + specularComponent;\nvec3 outColor = pow(outColorLinear, vec3(INV_GAMMA_SRGB));\nreturn outColor;\n}`);\n      break;\n    default:\n      n(v.pbrMode);\n    case c.COUNT:\n  }\n}\nexport { v as EvaluateSceneLighting, u as addAmbientBoostFactor, p as addLightingGlobalFactor };","map":{"version":3,"names":["colorGamma","i","neverReached","n","EvaluateAmbientLighting","e","EvaluateAmbientOcclusion","o","addMainLightDirection","t","addMainLightIntensity","a","applyShading","r","PhysicallyBasedRendering","l","PBRMode","c","PiUtils","d","BooleanBindUniform","s","FloatBindUniform","m","glsl","g","ambientBoost","h","u","constants","add","p","uniforms","lighting","globalFactor","v","f","fragment","include","pbrMode","Disabled","code","float","spherical","WaterOnIntegratedMesh","Water","Normal","Schematic","useFillLights","enableFillLights","mainLight","specularStrength","environmentStrength","hasColorTexture","Simplified","TerrainWithWater","COUNT","EvaluateSceneLighting","addAmbientBoostFactor","addLightingGlobalFactor"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{colorGamma as i}from\"../../../../../../colorUtils.js\";import{neverReached as n}from\"../../../../../../core/compilerUtils.js\";import{EvaluateAmbientLighting as e}from\"./EvaluateAmbientLighting.glsl.js\";import{EvaluateAmbientOcclusion as o}from\"./EvaluateAmbientOcclusion.glsl.js\";import{addMainLightDirection as t,addMainLightIntensity as a,applyShading as r}from\"./MainLighting.glsl.js\";import{PhysicallyBasedRendering as l}from\"./PhysicallyBasedRendering.glsl.js\";import{PBRMode as c}from\"./PhysicallyBasedRenderingParameters.glsl.js\";import{PiUtils as d}from\"./PiUtils.glsl.js\";import{BooleanBindUniform as s}from\"../../shaderModules/BooleanBindUniform.js\";import{FloatBindUniform as m}from\"../../shaderModules/FloatBindUniform.js\";import{glsl as g}from\"../../shaderModules/glsl.js\";import{ambientBoost as h}from\"../../../lighting/SceneLighting.js\";function u(i){i.constants.add(\"ambientBoostFactor\",\"float\",h)}function p(i){i.uniforms.add(new m(\"lightingGlobalFactor\",(i=>i.lighting.globalFactor)))}function v(h,v){const f=h.fragment;switch(h.include(o,v),v.pbrMode!==c.Disabled&&h.include(l,v),h.include(e,v),h.include(d),f.code.add(g`\n    const float GAMMA_SRGB = ${g.float(i)};\n    const float INV_GAMMA_SRGB = 0.4761904;\n    ${v.pbrMode===c.Disabled?\"\":\"const vec3 GROUND_REFLECTANCE = vec3(0.2);\"}\n  `),u(f),p(f),t(f),f.code.add(g`\n    float additionalDirectedAmbientLight(vec3 vPosWorld) {\n      float vndl = dot(${v.spherical?g`normalize(vPosWorld)`:g`vec3(0.0, 0.0, 1.0)`}, mainLightDirection);\n      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n    }\n  `),a(f),f.code.add(g`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\nfloat additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);\nreturn (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;\n}`),v.pbrMode){case c.Disabled:case c.WaterOnIntegratedMesh:case c.Water:h.include(r),f.code.add(g`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight) {\nvec3 mainLighting = applyShading(normalWorld, shadow);\nvec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);\nvec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\nvec3 totalLight = mainLighting + ambientLighting + additionalLight;\ntotalLight = min(totalLight, vec3(PI));\nvec3 outColor = vec3((albedoLinear / PI) * totalLight);\nreturn pow(outColor, vec3(INV_GAMMA_SRGB));\n}`);break;case c.Normal:case c.Schematic:f.code.add(g`const float fillLightIntensity = 0.25;\nconst float horizonLightDiffusion = 0.4;\nconst float additionalAmbientIrradianceFactor = 0.02;\nvec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec4 _emission, float additionalAmbientIrradiance)\n{\nvec3 viewDirection = -viewDir;\nvec3 h = normalize(viewDirection + mainLightDirection);\nPBRShadingInfo inputs;\ninputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\ninputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\nvec3 reflectedView = normalize(reflect(viewDirection, normal));\ninputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\ninputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\ninputs.ssao = ssao;\ninputs.metalness = mrr[0];\ninputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`),f.code.add(g`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\ninputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));\ninputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`),v.useFillLights?f.uniforms.add(new s(\"hasFillLights\",(i=>i.enableFillLights))):f.constants.add(\"hasFillLights\",\"bool\",!1),f.code.add(g`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);\nambientDir = ambientDir != vec3(0.0) ? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\ninputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;\nfloat NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\nvec3 mainLightIrradianceComponent = NdotL * (1.0 - shadow) * mainLightIntensity;\nvec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * mainLightIntensity * fillLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\ninputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\ninputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`),f.uniforms.add(new m(\"lightingSpecularStrength\",(i=>i.lighting.mainLight.specularStrength)),new m(\"lightingEnvironmentStrength\",(i=>i.lighting.mainLight.environmentStrength))).code.add(g`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\nvec3 horizonRingH = normalize(viewDirection + horizonRingDir);\ninputs.NdotH_Horizon = dot(normal, horizonRingH);\nfloat NdotH = clamp(dot(normal, h), 0.0, 1.0);\nvec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(NdotH, inputs.roughness) * mainLightIntensity * (1.0 - shadow);\nvec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * mainLightIntensity * fillLightIntensity;\nvec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;\nfloat normalDirectionModifier = mix(1., min(mix(0.1, 2.0, (inputs.NdotNG + 1.) * 0.5), 1.0), clamp(inputs.roughness * 5.0, 0.0 , 1.0));\ninputs.skyRadianceToSurface = (ambientLightRadianceComponent + horizonLightRadianceComponent) * normalDirectionModifier + mainLightRadianceComponent;\ninputs.groundRadianceToSurface = 0.5 * GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) * normalDirectionModifier + mainLightRadianceComponent;\ninputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`),f.code.add(g`\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = _emission.rgb == vec3(0.0) ? _emission.rgb : pow(_emission.rgb, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        ${v.pbrMode!==c.Schematic||v.hasColorTexture?g`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));`:g`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));`}\n        return outColor;\n      }\n    `);break;case c.Simplified:case c.TerrainWithWater:t(f),a(f),f.code.add(g`const float roughnessTerrain = 0.5;\nconst float specularityTerrain = 0.5;\nconst vec3 fresnelReflectionTerrain = vec3(0.04);\nvec3 evaluatePBRSimplifiedLighting(vec3 n, vec3 c, float shadow, float ssao, vec3 al, vec3 vd, vec3 nup) {\nvec3 viewDirection = -vd;\nvec3 h = normalize(viewDirection + mainLightDirection);\nfloat NdotL = clamp(dot(n, mainLightDirection), 0.001, 1.0);\nfloat NdotV = clamp(abs(dot(n, viewDirection)), 0.001, 1.0);\nfloat NdotH = clamp(dot(n, h), 0.0, 1.0);\nfloat NdotNG = clamp(dot(n, nup), -1.0, 1.0);\nvec3 albedoLinear = pow(c, vec3(GAMMA_SRGB));\nfloat lightness = 0.3 * albedoLinear[0] + 0.5 * albedoLinear[1] + 0.2 * albedoLinear[2];\nvec3 f0 = (0.85 * lightness + 0.15) * fresnelReflectionTerrain;\nvec3 f90 =  vec3(clamp(dot(f0, vec3(50.0 * 0.33)), 0.0, 1.0));\nvec3 mainLightIrradianceComponent = (1. - shadow) * NdotL * mainLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(n, ssao) + al;\nvec3 ambientSky = ambientLightIrradianceComponent + mainLightIrradianceComponent;\nvec3 indirectDiffuse = ((1.0 - NdotNG) * mainLightIrradianceComponent + (1.0 + NdotNG ) * ambientSky) * 0.5;\nvec3 outDiffColor = albedoLinear * (1.0 - f0) * indirectDiffuse / PI;\nvec3 mainLightRadianceComponent = normalDistribution(NdotH, roughnessTerrain) * mainLightIntensity;\nvec2 dfg = prefilteredDFGAnalytical(roughnessTerrain, NdotV);\nvec3 specularColor = f0 * dfg.x + f90 * dfg.y;\nvec3 specularComponent = specularityTerrain * specularColor * mainLightRadianceComponent;\nvec3 outColorLinear = outDiffColor + specularComponent;\nvec3 outColor = pow(outColorLinear, vec3(INV_GAMMA_SRGB));\nreturn outColor;\n}`);break;default:n(v.pbrMode);case c.COUNT:}}export{v as EvaluateSceneLighting,u as addAmbientBoostFactor,p as addLightingGlobalFactor};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}