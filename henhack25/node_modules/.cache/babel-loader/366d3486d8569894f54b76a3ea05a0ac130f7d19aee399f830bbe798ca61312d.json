{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { unpackFloatRGBA as e } from \"../../core/floatRGBA.js\";\nimport has from \"../../core/has.js\";\nimport { disposeMaybe as n } from \"../../core/maybe.js\";\nimport { fromValues as t } from \"../../core/libs/gl-matrix-2/factories/vec3f64.js\";\nimport { BufferObject as r } from \"./BufferObject.js\";\nimport { encodeDoubleArray as o } from \"./doublePrecisionUtils.js\";\nimport { TextureWrapMode as i, TextureSamplingMode as s, Usage as c, DataType as a, PrimitiveType as u, PixelFormat as f, PixelType as l } from \"./enums.js\";\nimport { FramebufferObject as p } from \"./FramebufferObject.js\";\nimport { TextureDescriptor as m } from \"./TextureDescriptor.js\";\nimport { VertexArrayObject as v } from \"./VertexArrayObject.js\";\nimport { VertexElementDescriptor as h } from \"./VertexElementDescriptor.js\";\nimport { WebGLDriverTestModule as d } from \"./WebGLDriverTestModule.js\";\nclass _ extends d {\n  constructor(e) {\n    super(), this._rctx = e, this._program = A(this._rctx, !1), this._obfuscated = A(this._rctx, !0);\n  }\n  dispose() {\n    super.dispose(), this._obfuscated = n(this._obfuscated);\n  }\n  _test(e) {\n    if (has(\"force-double-precision-obfuscation\")) return !0;\n    if (null == this._obfuscated) return !1;\n    const n = this._rctx,\n      t = n.getBoundFramebufferObject(),\n      {\n        x: r,\n        y: o,\n        width: i,\n        height: s\n      } = n.getViewport(),\n      c = this._runProgram(e),\n      a = this._runProgram(this._obfuscated);\n    return n.setViewport(r, o, i, s), n.bindFramebuffer(t), 0 !== c && (0 === a || c / a > 5);\n  }\n  _runProgram(n) {\n    const d = this._rctx;\n    d.resetState();\n    const _ = new m(1);\n    _.wrapMode = i.CLAMP_TO_EDGE, _.samplingMode = s.NEAREST;\n    const A = new p(d, _),\n      b = r.createVertex(d, c.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])),\n      g = new v(d, new Map([[\"position\", 0]]), new Map([[\"geometry\", [new h(\"position\", 2, a.UNSIGNED_SHORT, 0, 4)]]]), new Map([[\"geometry\", b]])),\n      B = t(5633261.287538229, 2626832.878767164, 1434988.0495278358),\n      w = t(5633271.46742708, 2626873.6381334523, 1434963.231608387),\n      F = new Float32Array(6);\n    o(B, F, 3);\n    const O = new Float32Array(6);\n    o(w, O, 3), d.useProgram(n), n.setUniform3f(\"u_highA\", F[0], F[2], F[4]), n.setUniform3f(\"u_lowA\", F[1], F[3], F[5]), n.setUniform3f(\"u_highB\", O[0], O[2], O[4]), n.setUniform3f(\"u_lowB\", O[1], O[3], O[5]), d.bindFramebuffer(A), d.setViewport(0, 0, 1, 1), d.bindVAO(g), d.drawArrays(u.TRIANGLE_STRIP, 0, 4);\n    const E = new Uint8Array(4);\n    A.readPixels(0, 0, 1, 1, f.RGBA, l.UNSIGNED_BYTE, E), g.dispose(), A.dispose();\n    const x = (B[2] - w[2]) / 25,\n      I = e(E);\n    return Math.abs(x - I);\n  }\n}\nfunction A(e, n) {\n  const t = `\\n\\n  precision highp float;\\n\\n  attribute vec2 position;\\n\\n  uniform vec3 u_highA;\\n  uniform vec3 u_lowA;\\n  uniform vec3 u_highB;\\n  uniform vec3 u_lowB;\\n\\n  varying vec4 v_color;\\n\\n  ${n ? \"#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION\" : \"\"}\\n\\n  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION\\n\\n  vec3 dpPlusFrc(vec3 a, vec3 b) {\\n    return mix(a, a + b, vec3(notEqual(b, vec3(0))));\\n  }\\n\\n  vec3 dpMinusFrc(vec3 a, vec3 b) {\\n    return mix(vec3(0), a - b, vec3(notEqual(a, b)));\\n  }\\n\\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\\n    vec3 t1 = dpPlusFrc(hiA, hiB);\\n    vec3 e = dpMinusFrc(t1, hiA);\\n    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\\n    return t1 + t2;\\n  }\\n\\n  #else\\n\\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\\n    vec3 t1 = hiA + hiB;\\n    vec3 e = t1 - hiA;\\n    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\\n    return t1 + t2;\\n  }\\n\\n  #endif\\n\\n  const float MAX_RGBA_FLOAT =\\n    255.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 / 256.0 / 256.0;\\n\\n  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\\n\\n  vec4 float2rgba(const float value) {\\n    // Make sure value is in the domain we can represent\\n    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\\n\\n    // Decompose value in 32bit fixed point parts represented as\\n    // uint8 rgba components. Decomposition uses the fractional part after multiplying\\n    // by a power of 256 (this removes the bits that are represented in the previous\\n    // component) and then converts the fractional part to 8bits.\\n    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\\n\\n    // Convert uint8 values (from 0 to 255) to floating point representation for\\n    // the shader\\n    const float toU8AsFloat = 1.0 / 255.0;\\n\\n    return fixedPointU8 * toU8AsFloat;\\n  }\\n\\n  void main() {\\n    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);\\n\\n    v_color = float2rgba(val.z / 25.0);\\n\\n    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);\\n  }\\n  `,\n    r = \"\\n  precision highp float;\\n\\n  varying vec4 v_color;\\n\\n  void main() {\\n    gl_FragColor = v_color;\\n  }\\n  \";\n  return e.programCache.acquire(t, r, new Map([[\"position\", 0]]));\n}\nexport { _ as DoublePrecisionRequiresObfuscation };","map":{"version":3,"names":["unpackFloatRGBA","e","has","disposeMaybe","n","fromValues","t","BufferObject","r","encodeDoubleArray","o","TextureWrapMode","i","TextureSamplingMode","s","Usage","c","DataType","a","PrimitiveType","u","PixelFormat","f","PixelType","l","FramebufferObject","p","TextureDescriptor","m","VertexArrayObject","v","VertexElementDescriptor","h","WebGLDriverTestModule","d","_","constructor","_rctx","_program","A","_obfuscated","dispose","_test","getBoundFramebufferObject","x","y","width","height","getViewport","_runProgram","setViewport","bindFramebuffer","resetState","wrapMode","CLAMP_TO_EDGE","samplingMode","NEAREST","b","createVertex","STATIC_DRAW","Uint16Array","g","Map","UNSIGNED_SHORT","B","w","F","Float32Array","O","useProgram","setUniform3f","bindVAO","drawArrays","TRIANGLE_STRIP","E","Uint8Array","readPixels","RGBA","UNSIGNED_BYTE","I","Math","abs","programCache","acquire","DoublePrecisionRequiresObfuscation"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/views/webgl/testDoublePrecisionArithmetic.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{unpackFloatRGBA as e}from\"../../core/floatRGBA.js\";import has from\"../../core/has.js\";import{disposeMaybe as n}from\"../../core/maybe.js\";import{fromValues as t}from\"../../core/libs/gl-matrix-2/factories/vec3f64.js\";import{BufferObject as r}from\"./BufferObject.js\";import{encodeDoubleArray as o}from\"./doublePrecisionUtils.js\";import{TextureWrapMode as i,TextureSamplingMode as s,Usage as c,DataType as a,PrimitiveType as u,PixelFormat as f,PixelType as l}from\"./enums.js\";import{FramebufferObject as p}from\"./FramebufferObject.js\";import{TextureDescriptor as m}from\"./TextureDescriptor.js\";import{VertexArrayObject as v}from\"./VertexArrayObject.js\";import{VertexElementDescriptor as h}from\"./VertexElementDescriptor.js\";import{WebGLDriverTestModule as d}from\"./WebGLDriverTestModule.js\";class _ extends d{constructor(e){super(),this._rctx=e,this._program=A(this._rctx,!1),this._obfuscated=A(this._rctx,!0)}dispose(){super.dispose(),this._obfuscated=n(this._obfuscated)}_test(e){if(has(\"force-double-precision-obfuscation\"))return!0;if(null==this._obfuscated)return!1;const n=this._rctx,t=n.getBoundFramebufferObject(),{x:r,y:o,width:i,height:s}=n.getViewport(),c=this._runProgram(e),a=this._runProgram(this._obfuscated);return n.setViewport(r,o,i,s),n.bindFramebuffer(t),0!==c&&(0===a||c/a>5)}_runProgram(n){const d=this._rctx;d.resetState();const _=new m(1);_.wrapMode=i.CLAMP_TO_EDGE,_.samplingMode=s.NEAREST;const A=new p(d,_),b=r.createVertex(d,c.STATIC_DRAW,new Uint16Array([0,0,1,0,0,1,1,1])),g=new v(d,new Map([[\"position\",0]]),new Map([[\"geometry\",[new h(\"position\",2,a.UNSIGNED_SHORT,0,4)]]]),new Map([[\"geometry\",b]])),B=t(5633261.287538229,2626832.878767164,1434988.0495278358),w=t(5633271.46742708,2626873.6381334523,1434963.231608387),F=new Float32Array(6);o(B,F,3);const O=new Float32Array(6);o(w,O,3),d.useProgram(n),n.setUniform3f(\"u_highA\",F[0],F[2],F[4]),n.setUniform3f(\"u_lowA\",F[1],F[3],F[5]),n.setUniform3f(\"u_highB\",O[0],O[2],O[4]),n.setUniform3f(\"u_lowB\",O[1],O[3],O[5]),d.bindFramebuffer(A),d.setViewport(0,0,1,1),d.bindVAO(g),d.drawArrays(u.TRIANGLE_STRIP,0,4);const E=new Uint8Array(4);A.readPixels(0,0,1,1,f.RGBA,l.UNSIGNED_BYTE,E),g.dispose(),A.dispose();const x=(B[2]-w[2])/25,I=e(E);return Math.abs(x-I)}}function A(e,n){const t=`\\n\\n  precision highp float;\\n\\n  attribute vec2 position;\\n\\n  uniform vec3 u_highA;\\n  uniform vec3 u_lowA;\\n  uniform vec3 u_highB;\\n  uniform vec3 u_lowB;\\n\\n  varying vec4 v_color;\\n\\n  ${n?\"#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION\":\"\"}\\n\\n  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION\\n\\n  vec3 dpPlusFrc(vec3 a, vec3 b) {\\n    return mix(a, a + b, vec3(notEqual(b, vec3(0))));\\n  }\\n\\n  vec3 dpMinusFrc(vec3 a, vec3 b) {\\n    return mix(vec3(0), a - b, vec3(notEqual(a, b)));\\n  }\\n\\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\\n    vec3 t1 = dpPlusFrc(hiA, hiB);\\n    vec3 e = dpMinusFrc(t1, hiA);\\n    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\\n    return t1 + t2;\\n  }\\n\\n  #else\\n\\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\\n    vec3 t1 = hiA + hiB;\\n    vec3 e = t1 - hiA;\\n    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\\n    return t1 + t2;\\n  }\\n\\n  #endif\\n\\n  const float MAX_RGBA_FLOAT =\\n    255.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 / 256.0 +\\n    255.0 / 256.0 / 256.0 / 256.0 / 256.0;\\n\\n  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\\n\\n  vec4 float2rgba(const float value) {\\n    // Make sure value is in the domain we can represent\\n    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\\n\\n    // Decompose value in 32bit fixed point parts represented as\\n    // uint8 rgba components. Decomposition uses the fractional part after multiplying\\n    // by a power of 256 (this removes the bits that are represented in the previous\\n    // component) and then converts the fractional part to 8bits.\\n    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\\n\\n    // Convert uint8 values (from 0 to 255) to floating point representation for\\n    // the shader\\n    const float toU8AsFloat = 1.0 / 255.0;\\n\\n    return fixedPointU8 * toU8AsFloat;\\n  }\\n\\n  void main() {\\n    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);\\n\\n    v_color = float2rgba(val.z / 25.0);\\n\\n    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);\\n  }\\n  `,r=\"\\n  precision highp float;\\n\\n  varying vec4 v_color;\\n\\n  void main() {\\n    gl_FragColor = v_color;\\n  }\\n  \";return e.programCache.acquire(t,r,new Map([[\"position\",0]]))}export{_ as DoublePrecisionRequiresObfuscation};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}