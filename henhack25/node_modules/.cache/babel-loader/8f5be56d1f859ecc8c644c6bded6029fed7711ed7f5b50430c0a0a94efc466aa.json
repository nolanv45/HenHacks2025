{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nclass s {\n  get value() {\n    return this.o;\n  }\n  set value(s) {\n    this.setValue(s);\n  }\n  setValue(s) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n    const i = t || !Object.is(s, this.o);\n    this.o = s, i && this.updateObservers();\n  }\n  constructor(s) {\n    this.subscriptions = new Map(), this.updateObservers = () => {\n      for (const [s, {\n        disposer: t\n      }] of this.subscriptions) s(this.o, t);\n    }, void 0 !== s && (this.value = s);\n  }\n  addCallback(s, t, i) {\n    if (!i) return void s(this.value);\n    this.subscriptions.has(s) || this.subscriptions.set(s, {\n      disposer: () => {\n        this.subscriptions.delete(s);\n      },\n      consumerHost: t\n    });\n    const {\n      disposer: h\n    } = this.subscriptions.get(s);\n    s(this.value, h);\n  }\n  clearCallbacks() {\n    this.subscriptions.clear();\n  }\n}\nexport { s as ValueNotifier };","map":{"version":3,"names":["s","value","o","setValue","t","arguments","length","undefined","i","Object","is","updateObservers","constructor","subscriptions","Map","disposer","addCallback","has","set","delete","consumerHost","h","get","clearCallbacks","clear","ValueNotifier"],"sources":["C:\\Users\\nolan\\tasks\\HenHacks2025\\henhack25\\node_modules\\@lit\\context\\src\\lib\\value-notifier.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextCallback} from './context-request-event.js';\n\n/**\n * A disposer function\n */\ntype Disposer = () => void;\n\ninterface CallbackInfo {\n  disposer: Disposer;\n  consumerHost: Element;\n}\n\n/**\n * A simple class which stores a value, and triggers registered callbacks when\n * the value is changed via its setter.\n *\n * An implementor might use other observable patterns such as MobX or Redux to\n * get behavior like this. But this is a pretty minimal approach that will\n * likely work for a number of use cases.\n */\nexport class ValueNotifier<T> {\n  protected readonly subscriptions = new Map<\n    ContextCallback<T>,\n    CallbackInfo\n  >();\n  private _value!: T;\n  get value(): T {\n    return this._value;\n  }\n  set value(v: T) {\n    this.setValue(v);\n  }\n\n  setValue(v: T, force = false) {\n    const update = force || !Object.is(v, this._value);\n    this._value = v;\n    if (update) {\n      this.updateObservers();\n    }\n  }\n\n  constructor(defaultValue?: T) {\n    if (defaultValue !== undefined) {\n      this.value = defaultValue;\n    }\n  }\n\n  updateObservers = (): void => {\n    for (const [callback, {disposer}] of this.subscriptions) {\n      callback(this._value, disposer);\n    }\n  };\n\n  addCallback(\n    callback: ContextCallback<T>,\n    consumerHost: Element,\n    subscribe?: boolean\n  ): void {\n    if (!subscribe) {\n      // just call the callback once and we're done\n      callback(this.value);\n      return;\n    }\n    if (!this.subscriptions.has(callback)) {\n      this.subscriptions.set(callback, {\n        disposer: () => {\n          this.subscriptions.delete(callback);\n        },\n        consumerHost,\n      });\n    }\n    const {disposer} = this.subscriptions.get(callback)!;\n    callback(this.value, disposer);\n  }\n\n  clearCallbacks(): void {\n    this.subscriptions.clear();\n  }\n}\n"],"mappings":";;;;;MA0BaA,CAAA;EAMX,IAAAC,KAAIA,CAAA;IACF,OAAO,KAAKC,CACb;EAAA;EACD,IAAAD,KAAIA,CAAMD,CAAA;IACR,KAAKG,QAAA,CAASH,CAAA,CACf;EAAA;EAEDG,SAASH,CAAA,EAAc;IAAA,IAARI,CAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,OAAQ;IACrB,MAAMG,CAAA,GAASJ,CAAA,KAAUK,MAAA,CAAOC,EAAA,CAAGV,CAAA,EAAG,KAAKE,CAAA;IAC3C,KAAKA,CAAA,GAASF,CAAA,EACVQ,CAAA,IACF,KAAKG,eAAA,EAER;EAAA;EAEDC,YAAYZ,CAAA;IApBO,KAAAa,aAAA,GAAgB,IAAIC,GAAA,IA0BvC,KAAeH,eAAA,GAAG;MAChB,KAAK,OAAOX,CAAA;QAAUe,QAAA,EAACX;MAAA,MAAc,KAAKS,aAAA,EACxCb,CAAA,CAAS,KAAKE,CAAA,EAAQE,CAAA,CACvB;IAAA,QARoB,MAAjBJ,CAAA,KACF,KAAKC,KAAA,GAAQD,CAAA,CAEhB;EAAA;EAQDgB,YACEhB,CAAA,EACAI,CAAA,EACAI,CAAA;IAEA,KAAKA,CAAA,EAGH,YADAR,CAAA,CAAS,KAAKC,KAAA;IAGX,KAAKY,aAAA,CAAcI,GAAA,CAAIjB,CAAA,KAC1B,KAAKa,aAAA,CAAcK,GAAA,CAAIlB,CAAA,EAAU;MAC/Be,QAAA,EAAUA,CAAA;QACR,KAAKF,aAAA,CAAcM,MAAA,CAAOnB,CAAA,CAAS;MAAA;MAErCoB,YAAA,EAAAhB;IAAA;IAGJ;MAAMW,QAAA,EAACM;IAAA,IAAY,KAAKR,aAAA,CAAcS,GAAA,CAAItB,CAAA;IAC1CA,CAAA,CAAS,KAAKC,KAAA,EAAOoB,CAAA,CACtB;EAAA;EAEDE,eAAA;IACE,KAAKV,aAAA,CAAcW,KAAA,EACpB;EAAA;AAAA;AAAA,SAAAxB,CAAA,IAAAyB,aAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}