{"ast":null,"code":"/*\n Copyright (c) 2022 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright\n notice, this list of conditions and the following disclaimer in\n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* global TransformStream, Response */\n// deno-lint-ignore-file no-this-alias\n\nimport { MAX_32_BITS, MAX_16_BITS, COMPRESSION_METHOD_DEFLATE, COMPRESSION_METHOD_STORE, COMPRESSION_METHOD_AES, SPLIT_ZIP_FILE_SIGNATURE, LOCAL_FILE_HEADER_SIGNATURE, DATA_DESCRIPTOR_RECORD_SIGNATURE, CENTRAL_FILE_HEADER_SIGNATURE, END_OF_CENTRAL_DIR_SIGNATURE, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE, ZIP64_END_OF_CENTRAL_DIR_SIGNATURE, EXTRAFIELD_TYPE_AES, EXTRAFIELD_TYPE_ZIP64, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP, EXTRAFIELD_TYPE_NTFS, EXTRAFIELD_TYPE_NTFS_TAG1, EXTRAFIELD_TYPE_USDZ, END_OF_CENTRAL_DIR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH, BITFLAG_ENCRYPTED, BITFLAG_DATA_DESCRIPTOR, BITFLAG_LANG_ENCODING_FLAG, FILE_ATTR_MSDOS_DIR_MASK, FILE_ATTR_UNIX_DIR_MASK, FILE_ATTR_UNIX_EXECUTABLE_MASK, FILE_ATTR_UNIX_DEFAULT_MASK, VERSION_DEFLATE, VERSION_ZIP64, VERSION_AES, DIRECTORY_SIGNATURE, MIN_DATE, MAX_DATE, UNDEFINED_VALUE } from \"./constants.js\";\nimport { getConfiguration, getChunkSize } from \"./configuration.js\";\nimport { CODEC_DEFLATE, runWorker } from \"./codec-pool.js\";\nimport { initStream, initReader, initWriter } from \"./io.js\";\nimport { encodeText } from \"./util/encode-text.js\";\nimport { PROPERTY_NAME_LAST_MODIFICATION_DATE, PROPERTY_NAME_LAST_ACCESS_DATE, PROPERTY_NAME_CREATION_DATE, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES, PROPERTY_NAME_MS_DOS_COMPATIBLE, PROPERTY_NAME_ZIP64, PROPERTY_NAME_ENCRYPTED, PROPERTY_NAME_VERSION, PROPERTY_NAME_VERSION_MADE_BY, PROPERTY_NAME_ZIPCRYPTO, PROPERTY_NAME_DIRECTORY, PROPERTY_NAME_EXECUTABLE, Entry } from \"./zip-entry.js\";\nconst ERR_DUPLICATED_NAME = \"File already exists\";\nconst ERR_INVALID_COMMENT = \"Zip file comment exceeds 64KB\";\nconst ERR_INVALID_ENTRY_COMMENT = \"File entry comment exceeds 64KB\";\nconst ERR_INVALID_ENTRY_NAME = \"File entry name exceeds 64KB\";\nconst ERR_INVALID_VERSION = \"Version exceeds 65535\";\nconst ERR_INVALID_ENCRYPTION_STRENGTH = \"The strength must equal 1, 2, or 3\";\nconst ERR_INVALID_EXTRAFIELD_TYPE = \"Extra field type exceeds 65535\";\nconst ERR_INVALID_EXTRAFIELD_DATA = \"Extra field data exceeds 64KB\";\nconst ERR_UNSUPPORTED_FORMAT = \"Zip64 is not supported (make sure 'keepOrder' is set to 'true')\";\nconst ERR_UNDEFINED_UNCOMPRESSED_SIZE = \"Undefined uncompressed size\";\nconst EXTRAFIELD_DATA_AES = new Uint8Array([0x07, 0x00, 0x02, 0x00, 0x41, 0x45, 0x03, 0x00, 0x00]);\nlet workers = 0;\nconst pendingEntries = [];\nclass ZipWriter {\n  constructor(writer, options = {}) {\n    writer = initWriter(writer);\n    const addSplitZipSignature = writer.availableSize !== UNDEFINED_VALUE && writer.availableSize > 0 && writer.availableSize !== Infinity && writer.maxSize !== UNDEFINED_VALUE && writer.maxSize > 0 && writer.maxSize !== Infinity;\n    Object.assign(this, {\n      writer,\n      addSplitZipSignature,\n      options,\n      config: getConfiguration(),\n      files: new Map(),\n      filenames: new Set(),\n      offset: options.offset === UNDEFINED_VALUE ? writer.writable.size : options.offset,\n      pendingEntriesSize: 0,\n      pendingAddFileCalls: new Set(),\n      bufferedWrites: 0\n    });\n  }\n  async add(name = \"\", reader, options = {}) {\n    const zipWriter = this;\n    const {\n      pendingAddFileCalls,\n      config\n    } = zipWriter;\n    if (workers < config.maxWorkers) {\n      workers++;\n    } else {\n      await new Promise(resolve => pendingEntries.push(resolve));\n    }\n    let promiseAddFile;\n    try {\n      name = name.trim();\n      if (zipWriter.filenames.has(name)) {\n        throw new Error(ERR_DUPLICATED_NAME);\n      }\n      zipWriter.filenames.add(name);\n      promiseAddFile = addFile(zipWriter, name, reader, options);\n      pendingAddFileCalls.add(promiseAddFile);\n      return await promiseAddFile;\n    } catch (error) {\n      zipWriter.filenames.delete(name);\n      throw error;\n    } finally {\n      pendingAddFileCalls.delete(promiseAddFile);\n      const pendingEntry = pendingEntries.shift();\n      if (pendingEntry) {\n        pendingEntry();\n      } else {\n        workers--;\n      }\n    }\n  }\n  async close(comment = new Uint8Array(), options = {}) {\n    const zipWriter = this;\n    const {\n      pendingAddFileCalls,\n      writer\n    } = this;\n    const {\n      writable\n    } = writer;\n    while (pendingAddFileCalls.size) {\n      await Promise.allSettled(Array.from(pendingAddFileCalls));\n    }\n    await closeFile(this, comment, options);\n    const preventClose = getOptionValue(zipWriter, options, \"preventClose\");\n    if (!preventClose) {\n      await writable.getWriter().close();\n    }\n    return writer.getData ? writer.getData() : writable;\n  }\n}\nclass ZipWriterStream {\n  constructor(options = {}) {\n    const {\n      readable,\n      writable\n    } = new TransformStream();\n    this.readable = readable;\n    this.zipWriter = new ZipWriter(writable, options);\n  }\n  transform(path) {\n    const {\n      readable,\n      writable\n    } = new TransformStream({\n      flush: () => {\n        this.zipWriter.close();\n      }\n    });\n    this.zipWriter.add(path, readable);\n    return {\n      readable: this.readable,\n      writable\n    };\n  }\n  writable(path) {\n    const {\n      readable,\n      writable\n    } = new TransformStream();\n    this.zipWriter.add(path, readable);\n    return writable;\n  }\n  close(comment = undefined, options = {}) {\n    return this.zipWriter.close(comment, options);\n  }\n}\nexport { ZipWriter, ZipWriterStream, ERR_DUPLICATED_NAME, ERR_INVALID_COMMENT, ERR_INVALID_ENTRY_NAME, ERR_INVALID_ENTRY_COMMENT, ERR_INVALID_VERSION, ERR_INVALID_EXTRAFIELD_TYPE, ERR_INVALID_EXTRAFIELD_DATA, ERR_INVALID_ENCRYPTION_STRENGTH, ERR_UNSUPPORTED_FORMAT, ERR_UNDEFINED_UNCOMPRESSED_SIZE };\nasync function addFile(zipWriter, name, reader, options) {\n  name = name.trim();\n  const msDosCompatible = getOptionValue(zipWriter, options, PROPERTY_NAME_MS_DOS_COMPATIBLE);\n  const versionMadeBy = getOptionValue(zipWriter, options, PROPERTY_NAME_VERSION_MADE_BY, msDosCompatible ? 20 : 768);\n  const executable = getOptionValue(zipWriter, options, PROPERTY_NAME_EXECUTABLE);\n  if (versionMadeBy > MAX_16_BITS) {\n    throw new Error(ERR_INVALID_VERSION);\n  }\n  let externalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES, 0);\n  if (externalFileAttributes === 0) {\n    externalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE, 0);\n  }\n  if (!options.directory && name.endsWith(DIRECTORY_SIGNATURE)) {\n    options.directory = true;\n  }\n  const directory = getOptionValue(zipWriter, options, PROPERTY_NAME_DIRECTORY);\n  if (directory) {\n    if (!name.endsWith(DIRECTORY_SIGNATURE)) {\n      name += DIRECTORY_SIGNATURE;\n    }\n    if (externalFileAttributes === 0) {\n      if (msDosCompatible) {\n        externalFileAttributes = FILE_ATTR_MSDOS_DIR_MASK;\n      } else {\n        externalFileAttributes = FILE_ATTR_UNIX_DIR_MASK << 16;\n      }\n    }\n  } else if (!msDosCompatible && externalFileAttributes === 0) {\n    if (executable) {\n      externalFileAttributes = (FILE_ATTR_UNIX_EXECUTABLE_MASK | FILE_ATTR_UNIX_DEFAULT_MASK) << 16;\n    } else {\n      externalFileAttributes = FILE_ATTR_UNIX_DEFAULT_MASK << 16;\n    }\n  }\n  const encode = getOptionValue(zipWriter, options, \"encodeText\", encodeText);\n  let rawFilename = encode(name);\n  if (rawFilename === UNDEFINED_VALUE) {\n    rawFilename = encodeText(name);\n  }\n  if (getLength(rawFilename) > MAX_16_BITS) {\n    throw new Error(ERR_INVALID_ENTRY_NAME);\n  }\n  const comment = options.comment || \"\";\n  let rawComment = encode(comment);\n  if (rawComment === UNDEFINED_VALUE) {\n    rawComment = encodeText(comment);\n  }\n  if (getLength(rawComment) > MAX_16_BITS) {\n    throw new Error(ERR_INVALID_ENTRY_COMMENT);\n  }\n  const version = getOptionValue(zipWriter, options, PROPERTY_NAME_VERSION, VERSION_DEFLATE);\n  if (version > MAX_16_BITS) {\n    throw new Error(ERR_INVALID_VERSION);\n  }\n  const lastModDate = getOptionValue(zipWriter, options, PROPERTY_NAME_LAST_MODIFICATION_DATE, new Date());\n  const lastAccessDate = getOptionValue(zipWriter, options, PROPERTY_NAME_LAST_ACCESS_DATE);\n  const creationDate = getOptionValue(zipWriter, options, PROPERTY_NAME_CREATION_DATE);\n  let internalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES, 0);\n  if (internalFileAttributes === 0) {\n    internalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE, 0);\n  }\n  const passThrough = getOptionValue(zipWriter, options, \"passThrough\");\n  let password, rawPassword;\n  if (!passThrough) {\n    password = getOptionValue(zipWriter, options, \"password\");\n    rawPassword = getOptionValue(zipWriter, options, \"rawPassword\");\n  }\n  const encryptionStrength = getOptionValue(zipWriter, options, \"encryptionStrength\", 3);\n  const zipCrypto = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIPCRYPTO);\n  const extendedTimestamp = getOptionValue(zipWriter, options, \"extendedTimestamp\", true);\n  const keepOrder = getOptionValue(zipWriter, options, \"keepOrder\", true);\n  const level = getOptionValue(zipWriter, options, \"level\");\n  const useWebWorkers = getOptionValue(zipWriter, options, \"useWebWorkers\");\n  const bufferedWrite = getOptionValue(zipWriter, options, \"bufferedWrite\");\n  const dataDescriptorSignature = getOptionValue(zipWriter, options, \"dataDescriptorSignature\", false);\n  const signal = getOptionValue(zipWriter, options, \"signal\");\n  const useUnicodeFileNames = getOptionValue(zipWriter, options, \"useUnicodeFileNames\", true);\n  const useCompressionStream = getOptionValue(zipWriter, options, \"useCompressionStream\");\n  const compressionMethod = getOptionValue(zipWriter, options, \"compressionMethod\");\n  let dataDescriptor = getOptionValue(zipWriter, options, \"dataDescriptor\", true);\n  let zip64 = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIP64);\n  if (!zipCrypto && (password !== UNDEFINED_VALUE || rawPassword !== UNDEFINED_VALUE) && !(encryptionStrength >= 1 && encryptionStrength <= 3)) {\n    throw new Error(ERR_INVALID_ENCRYPTION_STRENGTH);\n  }\n  let rawExtraField = new Uint8Array();\n  const {\n    extraField\n  } = options;\n  if (extraField) {\n    let extraFieldSize = 0;\n    let offset = 0;\n    extraField.forEach(data => extraFieldSize += 4 + getLength(data));\n    rawExtraField = new Uint8Array(extraFieldSize);\n    extraField.forEach((data, type) => {\n      if (type > MAX_16_BITS) {\n        throw new Error(ERR_INVALID_EXTRAFIELD_TYPE);\n      }\n      if (getLength(data) > MAX_16_BITS) {\n        throw new Error(ERR_INVALID_EXTRAFIELD_DATA);\n      }\n      arraySet(rawExtraField, new Uint16Array([type]), offset);\n      arraySet(rawExtraField, new Uint16Array([getLength(data)]), offset + 2);\n      arraySet(rawExtraField, data, offset + 4);\n      offset += 4 + getLength(data);\n    });\n  }\n  let maximumCompressedSize = 0;\n  let maximumEntrySize = 0;\n  let uncompressedSize = 0;\n  if (passThrough) {\n    ({\n      uncompressedSize\n    } = options);\n    if (uncompressedSize === UNDEFINED_VALUE) {\n      throw new Error(ERR_UNDEFINED_UNCOMPRESSED_SIZE);\n    }\n  }\n  const zip64Enabled = zip64 === true;\n  if (reader) {\n    reader = initReader(reader);\n    await initStream(reader);\n    if (!passThrough) {\n      if (reader.size === UNDEFINED_VALUE) {\n        dataDescriptor = true;\n        if (zip64 || zip64 === UNDEFINED_VALUE) {\n          zip64 = true;\n          uncompressedSize = maximumCompressedSize = MAX_32_BITS + 1;\n        }\n      } else {\n        uncompressedSize = reader.size;\n        maximumCompressedSize = getMaximumCompressedSize(uncompressedSize);\n      }\n    } else {\n      maximumCompressedSize = getMaximumCompressedSize(uncompressedSize);\n    }\n  }\n  const {\n    diskOffset,\n    diskNumber,\n    maxSize\n  } = zipWriter.writer;\n  const zip64UncompressedSize = zip64Enabled || uncompressedSize > MAX_32_BITS;\n  const zip64CompressedSize = zip64Enabled || maximumCompressedSize > MAX_32_BITS;\n  const zip64Offset = zip64Enabled || zipWriter.offset + zipWriter.pendingEntriesSize - diskOffset > MAX_32_BITS;\n  const supportZip64SplitFile = getOptionValue(zipWriter, options, \"supportZip64SplitFile\", true);\n  const zip64DiskNumberStart = supportZip64SplitFile && zip64Enabled || diskNumber + Math.ceil(zipWriter.pendingEntriesSize / maxSize) > MAX_16_BITS;\n  if (zip64Offset || zip64UncompressedSize || zip64CompressedSize || zip64DiskNumberStart) {\n    if (zip64 === false || !keepOrder) {\n      throw new Error(ERR_UNSUPPORTED_FORMAT);\n    } else {\n      zip64 = true;\n    }\n  }\n  zip64 = zip64 || false;\n  const encrypted = getOptionValue(zipWriter, options, PROPERTY_NAME_ENCRYPTED);\n  const {\n    signature\n  } = options;\n  options = Object.assign({}, options, {\n    rawFilename,\n    rawComment,\n    version,\n    versionMadeBy,\n    lastModDate,\n    lastAccessDate,\n    creationDate,\n    rawExtraField,\n    zip64,\n    zip64UncompressedSize,\n    zip64CompressedSize,\n    zip64Offset,\n    zip64DiskNumberStart,\n    password,\n    rawPassword,\n    level: !useCompressionStream && zipWriter.config.CompressionStream === UNDEFINED_VALUE && zipWriter.config.CompressionStreamNative === UNDEFINED_VALUE ? 0 : level,\n    useWebWorkers,\n    encryptionStrength,\n    extendedTimestamp,\n    zipCrypto,\n    bufferedWrite,\n    keepOrder,\n    useUnicodeFileNames,\n    dataDescriptor,\n    dataDescriptorSignature,\n    signal,\n    msDosCompatible,\n    internalFileAttribute: internalFileAttributes,\n    internalFileAttributes,\n    externalFileAttribute: externalFileAttributes,\n    externalFileAttributes,\n    useCompressionStream,\n    passThrough,\n    encrypted: Boolean(password && getLength(password) || rawPassword && getLength(rawPassword)) || passThrough && encrypted,\n    signature,\n    compressionMethod\n  });\n  const headerInfo = getHeaderInfo(options);\n  const dataDescriptorInfo = getDataDescriptorInfo(options);\n  const metadataSize = getLength(headerInfo.localHeaderArray, dataDescriptorInfo.dataDescriptorArray);\n  maximumEntrySize = metadataSize + maximumCompressedSize;\n  if (zipWriter.options.usdz) {\n    maximumEntrySize += maximumEntrySize + 64;\n  }\n  zipWriter.pendingEntriesSize += maximumEntrySize;\n  let fileEntry;\n  try {\n    fileEntry = await getFileEntry(zipWriter, name, reader, {\n      headerInfo,\n      dataDescriptorInfo,\n      metadataSize\n    }, options);\n  } finally {\n    zipWriter.pendingEntriesSize -= maximumEntrySize;\n  }\n  Object.assign(fileEntry, {\n    name,\n    comment,\n    extraField\n  });\n  return new Entry(fileEntry);\n}\nasync function getFileEntry(zipWriter, name, reader, entryInfo, options) {\n  const {\n    files,\n    writer\n  } = zipWriter;\n  const {\n    keepOrder,\n    dataDescriptor,\n    signal\n  } = options;\n  const {\n    headerInfo\n  } = entryInfo;\n  const {\n    usdz\n  } = zipWriter.options;\n  const previousFileEntry = Array.from(files.values()).pop();\n  let fileEntry = {};\n  let bufferedWrite;\n  let releaseLockWriter;\n  let releaseLockCurrentFileEntry;\n  let writingBufferedEntryData;\n  let writingEntryData;\n  let fileWriter;\n  let blobPromise;\n  files.set(name, fileEntry);\n  try {\n    let lockPreviousFileEntry;\n    if (keepOrder) {\n      lockPreviousFileEntry = previousFileEntry && previousFileEntry.lock;\n      requestLockCurrentFileEntry();\n    }\n    if ((options.bufferedWrite || zipWriter.writerLocked || zipWriter.bufferedWrites && keepOrder || !dataDescriptor) && !usdz) {\n      fileWriter = new TransformStream();\n      blobPromise = new Response(fileWriter.readable).blob();\n      fileWriter.writable.size = 0;\n      bufferedWrite = true;\n      zipWriter.bufferedWrites++;\n      await initStream(writer);\n    } else {\n      fileWriter = writer;\n      await requestLockWriter();\n    }\n    await initStream(fileWriter);\n    const {\n      writable\n    } = writer;\n    let {\n      diskOffset\n    } = writer;\n    if (zipWriter.addSplitZipSignature) {\n      delete zipWriter.addSplitZipSignature;\n      const signatureArray = new Uint8Array(4);\n      const signatureArrayView = getDataView(signatureArray);\n      setUint32(signatureArrayView, 0, SPLIT_ZIP_FILE_SIGNATURE);\n      await writeData(writable, signatureArray);\n      zipWriter.offset += 4;\n    }\n    if (usdz) {\n      appendExtraFieldUSDZ(entryInfo, zipWriter.offset - diskOffset);\n    }\n    if (!bufferedWrite) {\n      await lockPreviousFileEntry;\n      await skipDiskIfNeeded(writable);\n    }\n    const {\n      diskNumber\n    } = writer;\n    writingEntryData = true;\n    fileEntry.diskNumberStart = diskNumber;\n    fileEntry = await createFileEntry(reader, fileWriter, fileEntry, entryInfo, zipWriter.config, options);\n    writingEntryData = false;\n    files.set(name, fileEntry);\n    fileEntry.filename = name;\n    if (bufferedWrite) {\n      await fileWriter.writable.getWriter().close();\n      let blob = await blobPromise;\n      await lockPreviousFileEntry;\n      await requestLockWriter();\n      writingBufferedEntryData = true;\n      if (!dataDescriptor) {\n        blob = await writeExtraHeaderInfo(fileEntry, blob, writable, options);\n      }\n      await skipDiskIfNeeded(writable);\n      fileEntry.diskNumberStart = writer.diskNumber;\n      diskOffset = writer.diskOffset;\n      await blob.stream().pipeTo(writable, {\n        preventClose: true,\n        preventAbort: true,\n        signal\n      });\n      writable.size += blob.size;\n      writingBufferedEntryData = false;\n    }\n    fileEntry.offset = zipWriter.offset - diskOffset;\n    if (fileEntry.zip64) {\n      setZip64ExtraInfo(fileEntry, options);\n    } else if (fileEntry.offset > MAX_32_BITS) {\n      throw new Error(ERR_UNSUPPORTED_FORMAT);\n    }\n    zipWriter.offset += fileEntry.size;\n    return fileEntry;\n  } catch (error) {\n    if (bufferedWrite && writingBufferedEntryData || !bufferedWrite && writingEntryData) {\n      zipWriter.hasCorruptedEntries = true;\n      if (error) {\n        try {\n          error.corruptedEntry = true;\n          // eslint-disable-next-line no-unused-vars\n        } catch (_) {\n          // ignored\n        }\n      }\n      if (bufferedWrite) {\n        zipWriter.offset += fileWriter.writable.size;\n      } else {\n        zipWriter.offset = fileWriter.writable.size;\n      }\n    }\n    files.delete(name);\n    throw error;\n  } finally {\n    if (bufferedWrite) {\n      zipWriter.bufferedWrites--;\n    }\n    if (releaseLockCurrentFileEntry) {\n      releaseLockCurrentFileEntry();\n    }\n    if (releaseLockWriter) {\n      releaseLockWriter();\n    }\n  }\n  function requestLockCurrentFileEntry() {\n    fileEntry.lock = new Promise(resolve => releaseLockCurrentFileEntry = resolve);\n  }\n  async function requestLockWriter() {\n    zipWriter.writerLocked = true;\n    const {\n      lockWriter\n    } = zipWriter;\n    zipWriter.lockWriter = new Promise(resolve => releaseLockWriter = () => {\n      zipWriter.writerLocked = false;\n      resolve();\n    });\n    await lockWriter;\n  }\n  async function skipDiskIfNeeded(writable) {\n    if (getLength(headerInfo.localHeaderArray) > writer.availableSize) {\n      writer.availableSize = 0;\n      await writeData(writable, new Uint8Array());\n    }\n  }\n}\nasync function createFileEntry(reader, writer, {\n  diskNumberStart,\n  lock\n}, entryInfo, config, options) {\n  const {\n    headerInfo,\n    dataDescriptorInfo,\n    metadataSize\n  } = entryInfo;\n  const {\n    localHeaderArray,\n    headerArray,\n    lastModDate,\n    rawLastModDate,\n    encrypted,\n    compressed,\n    version,\n    compressionMethod,\n    rawExtraFieldExtendedTimestamp,\n    extraFieldExtendedTimestampFlag,\n    rawExtraFieldNTFS,\n    rawExtraFieldAES\n  } = headerInfo;\n  const {\n    dataDescriptorArray\n  } = dataDescriptorInfo;\n  const {\n    rawFilename,\n    lastAccessDate,\n    creationDate,\n    password,\n    rawPassword,\n    level,\n    zip64,\n    zip64UncompressedSize,\n    zip64CompressedSize,\n    zip64Offset,\n    zip64DiskNumberStart,\n    zipCrypto,\n    dataDescriptor,\n    directory,\n    executable,\n    versionMadeBy,\n    rawComment,\n    rawExtraField,\n    useWebWorkers,\n    onstart,\n    onprogress,\n    onend,\n    signal,\n    encryptionStrength,\n    extendedTimestamp,\n    msDosCompatible,\n    internalFileAttributes,\n    externalFileAttributes,\n    useCompressionStream,\n    passThrough\n  } = options;\n  const fileEntry = {\n    lock,\n    versionMadeBy,\n    zip64,\n    directory: Boolean(directory),\n    executable: Boolean(executable),\n    filenameUTF8: true,\n    rawFilename,\n    commentUTF8: true,\n    rawComment,\n    rawExtraFieldExtendedTimestamp,\n    rawExtraFieldNTFS,\n    rawExtraFieldAES,\n    rawExtraField,\n    extendedTimestamp,\n    msDosCompatible,\n    internalFileAttributes,\n    externalFileAttributes,\n    diskNumberStart\n  };\n  let {\n    signature,\n    uncompressedSize\n  } = options;\n  let compressedSize = 0;\n  if (!passThrough) {\n    uncompressedSize = 0;\n  }\n  const {\n    writable\n  } = writer;\n  if (reader) {\n    reader.chunkSize = getChunkSize(config);\n    await writeData(writable, localHeaderArray);\n    const readable = reader.readable;\n    const size = readable.size = reader.size;\n    const workerOptions = {\n      options: {\n        codecType: CODEC_DEFLATE,\n        level,\n        rawPassword,\n        password,\n        encryptionStrength,\n        zipCrypto: encrypted && zipCrypto,\n        passwordVerification: encrypted && zipCrypto && rawLastModDate >> 8 & 0xFF,\n        signed: !passThrough,\n        compressed: compressed && !passThrough,\n        encrypted: encrypted && !passThrough,\n        useWebWorkers,\n        useCompressionStream,\n        transferStreams: false\n      },\n      config,\n      streamOptions: {\n        signal,\n        size,\n        onstart,\n        onprogress,\n        onend\n      }\n    };\n    const result = await runWorker({\n      readable,\n      writable\n    }, workerOptions);\n    compressedSize = result.outputSize;\n    if (!passThrough) {\n      uncompressedSize = result.inputSize;\n      signature = result.signature;\n    }\n    writable.size += uncompressedSize;\n  } else {\n    await writeData(writable, localHeaderArray);\n  }\n  let rawExtraFieldZip64;\n  if (zip64) {\n    let rawExtraFieldZip64Length = 4;\n    if (zip64UncompressedSize) {\n      rawExtraFieldZip64Length += 8;\n    }\n    if (zip64CompressedSize) {\n      rawExtraFieldZip64Length += 8;\n    }\n    if (zip64Offset) {\n      rawExtraFieldZip64Length += 8;\n    }\n    if (zip64DiskNumberStart) {\n      rawExtraFieldZip64Length += 4;\n    }\n    rawExtraFieldZip64 = new Uint8Array(rawExtraFieldZip64Length);\n  } else {\n    rawExtraFieldZip64 = new Uint8Array();\n  }\n  setEntryInfo({\n    signature,\n    rawExtraFieldZip64,\n    compressedSize,\n    uncompressedSize,\n    headerInfo,\n    dataDescriptorInfo\n  }, options);\n  if (dataDescriptor) {\n    await writeData(writable, dataDescriptorArray);\n  }\n  Object.assign(fileEntry, {\n    uncompressedSize,\n    compressedSize,\n    lastModDate,\n    rawLastModDate,\n    creationDate,\n    lastAccessDate,\n    encrypted,\n    zipCrypto,\n    size: metadataSize + compressedSize,\n    compressionMethod,\n    version,\n    headerArray,\n    signature,\n    rawExtraFieldZip64,\n    extraFieldExtendedTimestampFlag,\n    zip64UncompressedSize,\n    zip64CompressedSize,\n    zip64Offset,\n    zip64DiskNumberStart\n  });\n  return fileEntry;\n}\nfunction getHeaderInfo(options) {\n  const {\n    rawFilename,\n    lastModDate,\n    lastAccessDate,\n    creationDate,\n    level,\n    zip64,\n    zipCrypto,\n    useUnicodeFileNames,\n    dataDescriptor,\n    directory,\n    rawExtraField,\n    encryptionStrength,\n    extendedTimestamp,\n    encrypted\n  } = options;\n  let {\n    version,\n    compressionMethod\n  } = options;\n  const compressed = !directory && (level > 0 || level === UNDEFINED_VALUE && compressionMethod !== 0);\n  let rawExtraFieldAES;\n  if (encrypted && !zipCrypto) {\n    rawExtraFieldAES = new Uint8Array(getLength(EXTRAFIELD_DATA_AES) + 2);\n    const extraFieldAESView = getDataView(rawExtraFieldAES);\n    setUint16(extraFieldAESView, 0, EXTRAFIELD_TYPE_AES);\n    arraySet(rawExtraFieldAES, EXTRAFIELD_DATA_AES, 2);\n    setUint8(extraFieldAESView, 8, encryptionStrength);\n  } else {\n    rawExtraFieldAES = new Uint8Array();\n  }\n  let rawExtraFieldNTFS;\n  let rawExtraFieldExtendedTimestamp;\n  let extraFieldExtendedTimestampFlag;\n  if (extendedTimestamp) {\n    rawExtraFieldExtendedTimestamp = new Uint8Array(9 + (lastAccessDate ? 4 : 0) + (creationDate ? 4 : 0));\n    const extraFieldExtendedTimestampView = getDataView(rawExtraFieldExtendedTimestamp);\n    setUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);\n    setUint16(extraFieldExtendedTimestampView, 2, getLength(rawExtraFieldExtendedTimestamp) - 4);\n    extraFieldExtendedTimestampFlag = 0x1 + (lastAccessDate ? 0x2 : 0) + (creationDate ? 0x4 : 0);\n    setUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);\n    let offset = 5;\n    setUint32(extraFieldExtendedTimestampView, offset, Math.floor(lastModDate.getTime() / 1000));\n    offset += 4;\n    if (lastAccessDate) {\n      setUint32(extraFieldExtendedTimestampView, offset, Math.floor(lastAccessDate.getTime() / 1000));\n      offset += 4;\n    }\n    if (creationDate) {\n      setUint32(extraFieldExtendedTimestampView, offset, Math.floor(creationDate.getTime() / 1000));\n    }\n    try {\n      rawExtraFieldNTFS = new Uint8Array(36);\n      const extraFieldNTFSView = getDataView(rawExtraFieldNTFS);\n      const lastModTimeNTFS = getTimeNTFS(lastModDate);\n      setUint16(extraFieldNTFSView, 0, EXTRAFIELD_TYPE_NTFS);\n      setUint16(extraFieldNTFSView, 2, 32);\n      setUint16(extraFieldNTFSView, 8, EXTRAFIELD_TYPE_NTFS_TAG1);\n      setUint16(extraFieldNTFSView, 10, 24);\n      setBigUint64(extraFieldNTFSView, 12, lastModTimeNTFS);\n      setBigUint64(extraFieldNTFSView, 20, getTimeNTFS(lastAccessDate) || lastModTimeNTFS);\n      setBigUint64(extraFieldNTFSView, 28, getTimeNTFS(creationDate) || lastModTimeNTFS);\n      // eslint-disable-next-line no-unused-vars\n    } catch (_) {\n      rawExtraFieldNTFS = new Uint8Array();\n    }\n  } else {\n    rawExtraFieldNTFS = rawExtraFieldExtendedTimestamp = new Uint8Array();\n  }\n  let bitFlag = 0;\n  if (useUnicodeFileNames) {\n    bitFlag = bitFlag | BITFLAG_LANG_ENCODING_FLAG;\n  }\n  if (dataDescriptor) {\n    bitFlag = bitFlag | BITFLAG_DATA_DESCRIPTOR;\n  }\n  if (compressionMethod === UNDEFINED_VALUE) {\n    compressionMethod = compressed ? COMPRESSION_METHOD_DEFLATE : COMPRESSION_METHOD_STORE;\n  }\n  if (compressionMethod == COMPRESSION_METHOD_DEFLATE) {\n    if (level >= 1 && level < 3) {\n      bitFlag = bitFlag | 0b110;\n    }\n    if (level >= 3 && level < 5) {\n      bitFlag = bitFlag | 0b01;\n    }\n    if (level === 9) {\n      bitFlag = bitFlag | 0b10;\n    }\n  }\n  if (zip64) {\n    version = version > VERSION_ZIP64 ? version : VERSION_ZIP64;\n  }\n  if (encrypted) {\n    bitFlag = bitFlag | BITFLAG_ENCRYPTED;\n    if (!zipCrypto) {\n      version = version > VERSION_AES ? version : VERSION_AES;\n      rawExtraFieldAES[9] = compressionMethod;\n      compressionMethod = COMPRESSION_METHOD_AES;\n    }\n  }\n  const headerArray = new Uint8Array(26);\n  const headerView = getDataView(headerArray);\n  setUint16(headerView, 0, version);\n  setUint16(headerView, 2, bitFlag);\n  setUint16(headerView, 4, compressionMethod);\n  const dateArray = new Uint32Array(1);\n  const dateView = getDataView(dateArray);\n  let lastModDateMsDos;\n  if (lastModDate < MIN_DATE) {\n    lastModDateMsDos = MIN_DATE;\n  } else if (lastModDate > MAX_DATE) {\n    lastModDateMsDos = MAX_DATE;\n  } else {\n    lastModDateMsDos = lastModDate;\n  }\n  setUint16(dateView, 0, (lastModDateMsDos.getHours() << 6 | lastModDateMsDos.getMinutes()) << 5 | lastModDateMsDos.getSeconds() / 2);\n  setUint16(dateView, 2, (lastModDateMsDos.getFullYear() - 1980 << 4 | lastModDateMsDos.getMonth() + 1) << 5 | lastModDateMsDos.getDate());\n  const rawLastModDate = dateArray[0];\n  setUint32(headerView, 6, rawLastModDate);\n  setUint16(headerView, 22, getLength(rawFilename));\n  const extraFieldLength = getLength(rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraField);\n  setUint16(headerView, 24, extraFieldLength);\n  const localHeaderArray = new Uint8Array(30 + getLength(rawFilename) + extraFieldLength);\n  const localHeaderView = getDataView(localHeaderArray);\n  setUint32(localHeaderView, 0, LOCAL_FILE_HEADER_SIGNATURE);\n  arraySet(localHeaderArray, headerArray, 4);\n  arraySet(localHeaderArray, rawFilename, 30);\n  arraySet(localHeaderArray, rawExtraFieldAES, 30 + getLength(rawFilename));\n  arraySet(localHeaderArray, rawExtraFieldExtendedTimestamp, 30 + getLength(rawFilename, rawExtraFieldAES));\n  arraySet(localHeaderArray, rawExtraFieldNTFS, 30 + getLength(rawFilename, rawExtraFieldAES, rawExtraFieldExtendedTimestamp));\n  arraySet(localHeaderArray, rawExtraField, 30 + getLength(rawFilename, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS));\n  return {\n    localHeaderArray,\n    headerArray,\n    headerView,\n    lastModDate,\n    rawLastModDate,\n    encrypted,\n    compressed,\n    version,\n    compressionMethod,\n    extraFieldExtendedTimestampFlag,\n    rawExtraFieldExtendedTimestamp,\n    rawExtraFieldNTFS,\n    rawExtraFieldAES,\n    extraFieldLength\n  };\n}\nfunction appendExtraFieldUSDZ(entryInfo, zipWriterOffset) {\n  const {\n    headerInfo\n  } = entryInfo;\n  let {\n    localHeaderArray,\n    extraFieldLength\n  } = headerInfo;\n  let localHeaderArrayView = getDataView(localHeaderArray);\n  let extraBytesLength = 64 - (zipWriterOffset + getLength(localHeaderArray)) % 64;\n  if (extraBytesLength < 4) {\n    extraBytesLength += 64;\n  }\n  const rawExtraFieldUSDZ = new Uint8Array(extraBytesLength);\n  const extraFieldUSDZView = getDataView(rawExtraFieldUSDZ);\n  setUint16(extraFieldUSDZView, 0, EXTRAFIELD_TYPE_USDZ);\n  setUint16(extraFieldUSDZView, 2, extraBytesLength - 2);\n  const previousLocalHeaderArray = localHeaderArray;\n  headerInfo.localHeaderArray = localHeaderArray = new Uint8Array(getLength(previousLocalHeaderArray) + extraBytesLength);\n  arraySet(localHeaderArray, previousLocalHeaderArray);\n  arraySet(localHeaderArray, rawExtraFieldUSDZ, getLength(previousLocalHeaderArray));\n  localHeaderArrayView = getDataView(localHeaderArray);\n  setUint16(localHeaderArrayView, 28, extraFieldLength + extraBytesLength);\n  entryInfo.metadataSize += extraBytesLength;\n}\nfunction getDataDescriptorInfo(options) {\n  const {\n    zip64,\n    dataDescriptor,\n    dataDescriptorSignature\n  } = options;\n  let dataDescriptorArray = new Uint8Array();\n  let dataDescriptorView,\n    dataDescriptorOffset = 0;\n  if (dataDescriptor) {\n    dataDescriptorArray = new Uint8Array(zip64 ? dataDescriptorSignature ? 24 : 20 : dataDescriptorSignature ? 16 : 12);\n    dataDescriptorView = getDataView(dataDescriptorArray);\n    if (dataDescriptorSignature) {\n      dataDescriptorOffset = 4;\n      setUint32(dataDescriptorView, 0, DATA_DESCRIPTOR_RECORD_SIGNATURE);\n    }\n  }\n  return {\n    dataDescriptorArray,\n    dataDescriptorView,\n    dataDescriptorOffset\n  };\n}\nfunction setEntryInfo(entryInfo, options) {\n  const {\n    signature,\n    rawExtraFieldZip64,\n    compressedSize,\n    uncompressedSize,\n    headerInfo,\n    dataDescriptorInfo\n  } = entryInfo;\n  const {\n    headerView,\n    encrypted\n  } = headerInfo;\n  const {\n    dataDescriptorView,\n    dataDescriptorOffset\n  } = dataDescriptorInfo;\n  const {\n    zip64,\n    zip64UncompressedSize,\n    zip64CompressedSize,\n    zipCrypto,\n    dataDescriptor\n  } = options;\n  if ((!encrypted || zipCrypto) && signature !== UNDEFINED_VALUE) {\n    setUint32(headerView, 10, signature);\n    if (dataDescriptor) {\n      setUint32(dataDescriptorView, dataDescriptorOffset, signature);\n    }\n  }\n  if (zip64) {\n    const rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);\n    setUint16(rawExtraFieldZip64View, 0, EXTRAFIELD_TYPE_ZIP64);\n    setUint16(rawExtraFieldZip64View, 2, getLength(rawExtraFieldZip64) - 4);\n    let rawExtraFieldZip64Offset = 4;\n    if (zip64UncompressedSize) {\n      setUint32(headerView, 18, MAX_32_BITS);\n      setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(uncompressedSize));\n      rawExtraFieldZip64Offset += 8;\n    }\n    if (zip64CompressedSize) {\n      setUint32(headerView, 14, MAX_32_BITS);\n      setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(compressedSize));\n    }\n    if (dataDescriptor) {\n      setBigUint64(dataDescriptorView, dataDescriptorOffset + 4, BigInt(compressedSize));\n      setBigUint64(dataDescriptorView, dataDescriptorOffset + 12, BigInt(uncompressedSize));\n    }\n  } else {\n    setUint32(headerView, 14, compressedSize);\n    setUint32(headerView, 18, uncompressedSize);\n    if (dataDescriptor) {\n      setUint32(dataDescriptorView, dataDescriptorOffset + 4, compressedSize);\n      setUint32(dataDescriptorView, dataDescriptorOffset + 8, uncompressedSize);\n    }\n  }\n}\nasync function writeExtraHeaderInfo(fileEntry, entryData, writable, {\n  zipCrypto\n}) {\n  let arrayBuffer;\n  arrayBuffer = await entryData.slice(0, 26).arrayBuffer();\n  if (arrayBuffer.byteLength != 26) {\n    arrayBuffer = arrayBuffer.slice(0, 26);\n  }\n  const arrayBufferView = new DataView(arrayBuffer);\n  if (!fileEntry.encrypted || zipCrypto) {\n    setUint32(arrayBufferView, 14, fileEntry.signature);\n  }\n  if (fileEntry.zip64) {\n    setUint32(arrayBufferView, 18, MAX_32_BITS);\n    setUint32(arrayBufferView, 22, MAX_32_BITS);\n  } else {\n    setUint32(arrayBufferView, 18, fileEntry.compressedSize);\n    setUint32(arrayBufferView, 22, fileEntry.uncompressedSize);\n  }\n  await writeData(writable, new Uint8Array(arrayBuffer));\n  return entryData.slice(arrayBuffer.byteLength);\n}\nfunction setZip64ExtraInfo(fileEntry, options) {\n  const {\n    rawExtraFieldZip64,\n    offset,\n    diskNumberStart\n  } = fileEntry;\n  const {\n    zip64UncompressedSize,\n    zip64CompressedSize,\n    zip64Offset,\n    zip64DiskNumberStart\n  } = options;\n  const rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);\n  let rawExtraFieldZip64Offset = 4;\n  if (zip64UncompressedSize) {\n    rawExtraFieldZip64Offset += 8;\n  }\n  if (zip64CompressedSize) {\n    rawExtraFieldZip64Offset += 8;\n  }\n  if (zip64Offset) {\n    setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(offset));\n    rawExtraFieldZip64Offset += 8;\n  }\n  if (zip64DiskNumberStart) {\n    setUint32(rawExtraFieldZip64View, rawExtraFieldZip64Offset, diskNumberStart);\n  }\n}\nasync function closeFile(zipWriter, comment, options) {\n  const {\n    files,\n    writer\n  } = zipWriter;\n  const {\n    diskOffset,\n    writable\n  } = writer;\n  let {\n    diskNumber\n  } = writer;\n  let offset = 0;\n  let directoryDataLength = 0;\n  let directoryOffset = zipWriter.offset - diskOffset;\n  let filesLength = files.size;\n  for (const [, fileEntry] of files) {\n    const {\n      rawFilename,\n      rawExtraFieldZip64,\n      rawExtraFieldAES,\n      rawComment,\n      rawExtraFieldNTFS,\n      rawExtraField,\n      extendedTimestamp,\n      extraFieldExtendedTimestampFlag,\n      lastModDate\n    } = fileEntry;\n    let rawExtraFieldTimestamp;\n    if (extendedTimestamp) {\n      rawExtraFieldTimestamp = new Uint8Array(9);\n      const extraFieldExtendedTimestampView = getDataView(rawExtraFieldTimestamp);\n      setUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);\n      setUint16(extraFieldExtendedTimestampView, 2, 5);\n      setUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);\n      setUint32(extraFieldExtendedTimestampView, 5, Math.floor(lastModDate.getTime() / 1000));\n    } else {\n      rawExtraFieldTimestamp = new Uint8Array();\n    }\n    fileEntry.rawExtraFieldCDExtendedTimestamp = rawExtraFieldTimestamp;\n    directoryDataLength += 46 + getLength(rawFilename, rawComment, rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldNTFS, rawExtraFieldTimestamp, rawExtraField);\n  }\n  const directoryArray = new Uint8Array(directoryDataLength);\n  const directoryView = getDataView(directoryArray);\n  await initStream(writer);\n  let directoryDiskOffset = 0;\n  for (const [indexFileEntry, fileEntry] of Array.from(files.values()).entries()) {\n    const {\n      offset: fileEntryOffset,\n      rawFilename,\n      rawExtraFieldZip64,\n      rawExtraFieldAES,\n      rawExtraFieldCDExtendedTimestamp,\n      rawExtraFieldNTFS,\n      rawExtraField,\n      rawComment,\n      versionMadeBy,\n      headerArray,\n      zip64,\n      zip64UncompressedSize,\n      zip64CompressedSize,\n      zip64DiskNumberStart,\n      zip64Offset,\n      internalFileAttributes,\n      externalFileAttributes,\n      diskNumberStart,\n      uncompressedSize,\n      compressedSize\n    } = fileEntry;\n    const extraFieldLength = getLength(rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldCDExtendedTimestamp, rawExtraFieldNTFS, rawExtraField);\n    setUint32(directoryView, offset, CENTRAL_FILE_HEADER_SIGNATURE);\n    setUint16(directoryView, offset + 4, versionMadeBy);\n    const headerView = getDataView(headerArray);\n    if (!zip64UncompressedSize) {\n      setUint32(headerView, 18, uncompressedSize);\n    }\n    if (!zip64CompressedSize) {\n      setUint32(headerView, 14, compressedSize);\n    }\n    arraySet(directoryArray, headerArray, offset + 6);\n    setUint16(directoryView, offset + 30, extraFieldLength);\n    setUint16(directoryView, offset + 32, getLength(rawComment));\n    setUint16(directoryView, offset + 34, zip64 && zip64DiskNumberStart ? MAX_16_BITS : diskNumberStart);\n    setUint16(directoryView, offset + 36, internalFileAttributes);\n    if (externalFileAttributes) {\n      setUint32(directoryView, offset + 38, externalFileAttributes);\n    }\n    setUint32(directoryView, offset + 42, zip64 && zip64Offset ? MAX_32_BITS : fileEntryOffset);\n    arraySet(directoryArray, rawFilename, offset + 46);\n    arraySet(directoryArray, rawExtraFieldZip64, offset + 46 + getLength(rawFilename));\n    arraySet(directoryArray, rawExtraFieldAES, offset + 46 + getLength(rawFilename, rawExtraFieldZip64));\n    arraySet(directoryArray, rawExtraFieldCDExtendedTimestamp, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES));\n    arraySet(directoryArray, rawExtraFieldNTFS, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldCDExtendedTimestamp));\n    arraySet(directoryArray, rawExtraField, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldCDExtendedTimestamp, rawExtraFieldNTFS));\n    arraySet(directoryArray, rawComment, offset + 46 + getLength(rawFilename) + extraFieldLength);\n    const directoryEntryLength = 46 + getLength(rawFilename, rawComment) + extraFieldLength;\n    if (offset - directoryDiskOffset > writer.availableSize) {\n      writer.availableSize = 0;\n      await writeData(writable, directoryArray.slice(directoryDiskOffset, offset));\n      directoryDiskOffset = offset;\n    }\n    offset += directoryEntryLength;\n    if (options.onprogress) {\n      try {\n        await options.onprogress(indexFileEntry + 1, files.size, new Entry(fileEntry));\n        // eslint-disable-next-line no-unused-vars\n      } catch (_) {\n        // ignored\n      }\n    }\n  }\n  await writeData(writable, directoryDiskOffset ? directoryArray.slice(directoryDiskOffset) : directoryArray);\n  let lastDiskNumber = writer.diskNumber;\n  const {\n    availableSize\n  } = writer;\n  if (availableSize < END_OF_CENTRAL_DIR_LENGTH) {\n    lastDiskNumber++;\n  }\n  let zip64 = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIP64);\n  if (directoryOffset > MAX_32_BITS || directoryDataLength > MAX_32_BITS || filesLength > MAX_16_BITS || lastDiskNumber > MAX_16_BITS) {\n    if (zip64 === false) {\n      throw new Error(ERR_UNSUPPORTED_FORMAT);\n    } else {\n      zip64 = true;\n    }\n  }\n  const endOfdirectoryArray = new Uint8Array(zip64 ? ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH : END_OF_CENTRAL_DIR_LENGTH);\n  const endOfdirectoryView = getDataView(endOfdirectoryArray);\n  offset = 0;\n  if (zip64) {\n    setUint32(endOfdirectoryView, 0, ZIP64_END_OF_CENTRAL_DIR_SIGNATURE);\n    setBigUint64(endOfdirectoryView, 4, BigInt(44));\n    setUint16(endOfdirectoryView, 12, 45);\n    setUint16(endOfdirectoryView, 14, 45);\n    setUint32(endOfdirectoryView, 16, lastDiskNumber);\n    setUint32(endOfdirectoryView, 20, diskNumber);\n    setBigUint64(endOfdirectoryView, 24, BigInt(filesLength));\n    setBigUint64(endOfdirectoryView, 32, BigInt(filesLength));\n    setBigUint64(endOfdirectoryView, 40, BigInt(directoryDataLength));\n    setBigUint64(endOfdirectoryView, 48, BigInt(directoryOffset));\n    setUint32(endOfdirectoryView, 56, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE);\n    setBigUint64(endOfdirectoryView, 64, BigInt(directoryOffset) + BigInt(directoryDataLength));\n    setUint32(endOfdirectoryView, 72, lastDiskNumber + 1);\n    const supportZip64SplitFile = getOptionValue(zipWriter, options, \"supportZip64SplitFile\", true);\n    if (supportZip64SplitFile) {\n      lastDiskNumber = MAX_16_BITS;\n      diskNumber = MAX_16_BITS;\n    }\n    filesLength = MAX_16_BITS;\n    directoryOffset = MAX_32_BITS;\n    directoryDataLength = MAX_32_BITS;\n    offset += ZIP64_END_OF_CENTRAL_DIR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH;\n  }\n  setUint32(endOfdirectoryView, offset, END_OF_CENTRAL_DIR_SIGNATURE);\n  setUint16(endOfdirectoryView, offset + 4, lastDiskNumber);\n  setUint16(endOfdirectoryView, offset + 6, diskNumber);\n  setUint16(endOfdirectoryView, offset + 8, filesLength);\n  setUint16(endOfdirectoryView, offset + 10, filesLength);\n  setUint32(endOfdirectoryView, offset + 12, directoryDataLength);\n  setUint32(endOfdirectoryView, offset + 16, directoryOffset);\n  const commentLength = getLength(comment);\n  if (commentLength) {\n    if (commentLength <= MAX_16_BITS) {\n      setUint16(endOfdirectoryView, offset + 20, commentLength);\n    } else {\n      throw new Error(ERR_INVALID_COMMENT);\n    }\n  }\n  await writeData(writable, endOfdirectoryArray);\n  if (commentLength) {\n    await writeData(writable, comment);\n  }\n}\nasync function writeData(writable, array) {\n  const streamWriter = writable.getWriter();\n  try {\n    await streamWriter.ready;\n    writable.size += getLength(array);\n    await streamWriter.write(array);\n  } finally {\n    streamWriter.releaseLock();\n  }\n}\nfunction getTimeNTFS(date) {\n  if (date) {\n    return (BigInt(date.getTime()) + BigInt(11644473600000)) * BigInt(10000);\n  }\n}\nfunction getOptionValue(zipWriter, options, name, defaultValue) {\n  const result = options[name] === UNDEFINED_VALUE ? zipWriter.options[name] : options[name];\n  return result === UNDEFINED_VALUE ? defaultValue : result;\n}\nfunction getMaximumCompressedSize(uncompressedSize) {\n  return uncompressedSize + 5 * (Math.floor(uncompressedSize / 16383) + 1);\n}\nfunction setUint8(view, offset, value) {\n  view.setUint8(offset, value);\n}\nfunction setUint16(view, offset, value) {\n  view.setUint16(offset, value, true);\n}\nfunction setUint32(view, offset, value) {\n  view.setUint32(offset, value, true);\n}\nfunction setBigUint64(view, offset, value) {\n  view.setBigUint64(offset, value, true);\n}\nfunction arraySet(array, typedArray, offset) {\n  array.set(typedArray, offset);\n}\nfunction getDataView(array) {\n  return new DataView(array.buffer);\n}\nfunction getLength(...arrayLikes) {\n  let result = 0;\n  arrayLikes.forEach(arrayLike => arrayLike && (result += arrayLike.length));\n  return result;\n}","map":{"version":3,"names":["MAX_32_BITS","MAX_16_BITS","COMPRESSION_METHOD_DEFLATE","COMPRESSION_METHOD_STORE","COMPRESSION_METHOD_AES","SPLIT_ZIP_FILE_SIGNATURE","LOCAL_FILE_HEADER_SIGNATURE","DATA_DESCRIPTOR_RECORD_SIGNATURE","CENTRAL_FILE_HEADER_SIGNATURE","END_OF_CENTRAL_DIR_SIGNATURE","ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE","ZIP64_END_OF_CENTRAL_DIR_SIGNATURE","EXTRAFIELD_TYPE_AES","EXTRAFIELD_TYPE_ZIP64","EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP","EXTRAFIELD_TYPE_NTFS","EXTRAFIELD_TYPE_NTFS_TAG1","EXTRAFIELD_TYPE_USDZ","END_OF_CENTRAL_DIR_LENGTH","ZIP64_END_OF_CENTRAL_DIR_LENGTH","ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH","ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH","BITFLAG_ENCRYPTED","BITFLAG_DATA_DESCRIPTOR","BITFLAG_LANG_ENCODING_FLAG","FILE_ATTR_MSDOS_DIR_MASK","FILE_ATTR_UNIX_DIR_MASK","FILE_ATTR_UNIX_EXECUTABLE_MASK","FILE_ATTR_UNIX_DEFAULT_MASK","VERSION_DEFLATE","VERSION_ZIP64","VERSION_AES","DIRECTORY_SIGNATURE","MIN_DATE","MAX_DATE","UNDEFINED_VALUE","getConfiguration","getChunkSize","CODEC_DEFLATE","runWorker","initStream","initReader","initWriter","encodeText","PROPERTY_NAME_LAST_MODIFICATION_DATE","PROPERTY_NAME_LAST_ACCESS_DATE","PROPERTY_NAME_CREATION_DATE","PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE","PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE","PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES","PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES","PROPERTY_NAME_MS_DOS_COMPATIBLE","PROPERTY_NAME_ZIP64","PROPERTY_NAME_ENCRYPTED","PROPERTY_NAME_VERSION","PROPERTY_NAME_VERSION_MADE_BY","PROPERTY_NAME_ZIPCRYPTO","PROPERTY_NAME_DIRECTORY","PROPERTY_NAME_EXECUTABLE","Entry","ERR_DUPLICATED_NAME","ERR_INVALID_COMMENT","ERR_INVALID_ENTRY_COMMENT","ERR_INVALID_ENTRY_NAME","ERR_INVALID_VERSION","ERR_INVALID_ENCRYPTION_STRENGTH","ERR_INVALID_EXTRAFIELD_TYPE","ERR_INVALID_EXTRAFIELD_DATA","ERR_UNSUPPORTED_FORMAT","ERR_UNDEFINED_UNCOMPRESSED_SIZE","EXTRAFIELD_DATA_AES","Uint8Array","workers","pendingEntries","ZipWriter","constructor","writer","options","addSplitZipSignature","availableSize","Infinity","maxSize","Object","assign","config","files","Map","filenames","Set","offset","writable","size","pendingEntriesSize","pendingAddFileCalls","bufferedWrites","add","name","reader","zipWriter","maxWorkers","Promise","resolve","push","promiseAddFile","trim","has","Error","addFile","error","delete","pendingEntry","shift","close","comment","allSettled","Array","from","closeFile","preventClose","getOptionValue","getWriter","getData","ZipWriterStream","readable","TransformStream","transform","path","flush","undefined","msDosCompatible","versionMadeBy","executable","externalFileAttributes","directory","endsWith","encode","rawFilename","getLength","rawComment","version","lastModDate","Date","lastAccessDate","creationDate","internalFileAttributes","passThrough","password","rawPassword","encryptionStrength","zipCrypto","extendedTimestamp","keepOrder","level","useWebWorkers","bufferedWrite","dataDescriptorSignature","signal","useUnicodeFileNames","useCompressionStream","compressionMethod","dataDescriptor","zip64","rawExtraField","extraField","extraFieldSize","forEach","data","type","arraySet","Uint16Array","maximumCompressedSize","maximumEntrySize","uncompressedSize","zip64Enabled","getMaximumCompressedSize","diskOffset","diskNumber","zip64UncompressedSize","zip64CompressedSize","zip64Offset","supportZip64SplitFile","zip64DiskNumberStart","Math","ceil","encrypted","signature","CompressionStream","CompressionStreamNative","internalFileAttribute","externalFileAttribute","Boolean","headerInfo","getHeaderInfo","dataDescriptorInfo","getDataDescriptorInfo","metadataSize","localHeaderArray","dataDescriptorArray","usdz","fileEntry","getFileEntry","entryInfo","previousFileEntry","values","pop","releaseLockWriter","releaseLockCurrentFileEntry","writingBufferedEntryData","writingEntryData","fileWriter","blobPromise","set","lockPreviousFileEntry","lock","requestLockCurrentFileEntry","writerLocked","Response","blob","requestLockWriter","signatureArray","signatureArrayView","getDataView","setUint32","writeData","appendExtraFieldUSDZ","skipDiskIfNeeded","diskNumberStart","createFileEntry","filename","writeExtraHeaderInfo","stream","pipeTo","preventAbort","setZip64ExtraInfo","hasCorruptedEntries","corruptedEntry","_","lockWriter","headerArray","rawLastModDate","compressed","rawExtraFieldExtendedTimestamp","extraFieldExtendedTimestampFlag","rawExtraFieldNTFS","rawExtraFieldAES","onstart","onprogress","onend","filenameUTF8","commentUTF8","compressedSize","chunkSize","workerOptions","codecType","passwordVerification","signed","transferStreams","streamOptions","result","outputSize","inputSize","rawExtraFieldZip64","rawExtraFieldZip64Length","setEntryInfo","extraFieldAESView","setUint16","setUint8","extraFieldExtendedTimestampView","floor","getTime","extraFieldNTFSView","lastModTimeNTFS","getTimeNTFS","setBigUint64","bitFlag","headerView","dateArray","Uint32Array","dateView","lastModDateMsDos","getHours","getMinutes","getSeconds","getFullYear","getMonth","getDate","extraFieldLength","localHeaderView","zipWriterOffset","localHeaderArrayView","extraBytesLength","rawExtraFieldUSDZ","extraFieldUSDZView","previousLocalHeaderArray","dataDescriptorView","dataDescriptorOffset","rawExtraFieldZip64View","rawExtraFieldZip64Offset","BigInt","entryData","arrayBuffer","slice","byteLength","arrayBufferView","DataView","directoryDataLength","directoryOffset","filesLength","rawExtraFieldTimestamp","rawExtraFieldCDExtendedTimestamp","directoryArray","directoryView","directoryDiskOffset","indexFileEntry","entries","fileEntryOffset","directoryEntryLength","lastDiskNumber","endOfdirectoryArray","endOfdirectoryView","commentLength","array","streamWriter","ready","write","releaseLock","date","defaultValue","view","value","typedArray","buffer","arrayLikes","arrayLike","length"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@zip.js/zip.js/lib/core/zip-writer.js"],"sourcesContent":["/*\n Copyright (c) 2022 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright\n notice, this list of conditions and the following disclaimer in\n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* global TransformStream, Response */\n// deno-lint-ignore-file no-this-alias\n\nimport {\n\tMAX_32_BITS,\n\tMAX_16_BITS,\n\tCOMPRESSION_METHOD_DEFLATE,\n\tCOMPRESSION_METHOD_STORE,\n\tCOMPRESSION_METHOD_AES,\n\tSPLIT_ZIP_FILE_SIGNATURE,\n\tLOCAL_FILE_HEADER_SIGNATURE,\n\tDATA_DESCRIPTOR_RECORD_SIGNATURE,\n\tCENTRAL_FILE_HEADER_SIGNATURE,\n\tEND_OF_CENTRAL_DIR_SIGNATURE,\n\tZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE,\n\tZIP64_END_OF_CENTRAL_DIR_SIGNATURE,\n\tEXTRAFIELD_TYPE_AES,\n\tEXTRAFIELD_TYPE_ZIP64,\n\tEXTRAFIELD_TYPE_EXTENDED_TIMESTAMP,\n\tEXTRAFIELD_TYPE_NTFS,\n\tEXTRAFIELD_TYPE_NTFS_TAG1,\n\tEXTRAFIELD_TYPE_USDZ,\n\tEND_OF_CENTRAL_DIR_LENGTH,\n\tZIP64_END_OF_CENTRAL_DIR_LENGTH,\n\tZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH,\n\tZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH,\n\tBITFLAG_ENCRYPTED,\n\tBITFLAG_DATA_DESCRIPTOR,\n\tBITFLAG_LANG_ENCODING_FLAG,\n\tFILE_ATTR_MSDOS_DIR_MASK,\n\tFILE_ATTR_UNIX_DIR_MASK,\n\tFILE_ATTR_UNIX_EXECUTABLE_MASK,\n\tFILE_ATTR_UNIX_DEFAULT_MASK,\n\tVERSION_DEFLATE,\n\tVERSION_ZIP64,\n\tVERSION_AES,\n\tDIRECTORY_SIGNATURE,\n\tMIN_DATE,\n\tMAX_DATE,\n\tUNDEFINED_VALUE\n} from \"./constants.js\";\nimport {\n\tgetConfiguration,\n\tgetChunkSize\n} from \"./configuration.js\";\nimport {\n\tCODEC_DEFLATE,\n\trunWorker\n} from \"./codec-pool.js\";\nimport {\n\tinitStream,\n\tinitReader,\n\tinitWriter\n} from \"./io.js\";\nimport { encodeText } from \"./util/encode-text.js\";\nimport {\n\tPROPERTY_NAME_LAST_MODIFICATION_DATE,\n\tPROPERTY_NAME_LAST_ACCESS_DATE,\n\tPROPERTY_NAME_CREATION_DATE,\n\tPROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE,\n\tPROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE,\n\tPROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES,\n\tPROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES,\n\tPROPERTY_NAME_MS_DOS_COMPATIBLE,\n\tPROPERTY_NAME_ZIP64,\n\tPROPERTY_NAME_ENCRYPTED,\n\tPROPERTY_NAME_VERSION,\n\tPROPERTY_NAME_VERSION_MADE_BY,\n\tPROPERTY_NAME_ZIPCRYPTO,\n\tPROPERTY_NAME_DIRECTORY,\n\tPROPERTY_NAME_EXECUTABLE,\n\tEntry\n} from \"./zip-entry.js\";\n\nconst ERR_DUPLICATED_NAME = \"File already exists\";\nconst ERR_INVALID_COMMENT = \"Zip file comment exceeds 64KB\";\nconst ERR_INVALID_ENTRY_COMMENT = \"File entry comment exceeds 64KB\";\nconst ERR_INVALID_ENTRY_NAME = \"File entry name exceeds 64KB\";\nconst ERR_INVALID_VERSION = \"Version exceeds 65535\";\nconst ERR_INVALID_ENCRYPTION_STRENGTH = \"The strength must equal 1, 2, or 3\";\nconst ERR_INVALID_EXTRAFIELD_TYPE = \"Extra field type exceeds 65535\";\nconst ERR_INVALID_EXTRAFIELD_DATA = \"Extra field data exceeds 64KB\";\nconst ERR_UNSUPPORTED_FORMAT = \"Zip64 is not supported (make sure 'keepOrder' is set to 'true')\";\nconst ERR_UNDEFINED_UNCOMPRESSED_SIZE = \"Undefined uncompressed size\";\n\nconst EXTRAFIELD_DATA_AES = new Uint8Array([0x07, 0x00, 0x02, 0x00, 0x41, 0x45, 0x03, 0x00, 0x00]);\n\nlet workers = 0;\nconst pendingEntries = [];\n\nclass ZipWriter {\n\n\tconstructor(writer, options = {}) {\n\t\twriter = initWriter(writer);\n\t\tconst addSplitZipSignature =\n\t\t\twriter.availableSize !== UNDEFINED_VALUE && writer.availableSize > 0 && writer.availableSize !== Infinity &&\n\t\t\twriter.maxSize !== UNDEFINED_VALUE && writer.maxSize > 0 && writer.maxSize !== Infinity;\n\t\tObject.assign(this, {\n\t\t\twriter,\n\t\t\taddSplitZipSignature,\n\t\t\toptions,\n\t\t\tconfig: getConfiguration(),\n\t\t\tfiles: new Map(),\n\t\t\tfilenames: new Set(),\n\t\t\toffset: options.offset === UNDEFINED_VALUE ? writer.writable.size : options.offset,\n\t\t\tpendingEntriesSize: 0,\n\t\t\tpendingAddFileCalls: new Set(),\n\t\t\tbufferedWrites: 0\n\t\t});\n\t}\n\n\tasync add(name = \"\", reader, options = {}) {\n\t\tconst zipWriter = this;\n\t\tconst {\n\t\t\tpendingAddFileCalls,\n\t\t\tconfig\n\t\t} = zipWriter;\n\t\tif (workers < config.maxWorkers) {\n\t\t\tworkers++;\n\t\t} else {\n\t\t\tawait new Promise(resolve => pendingEntries.push(resolve));\n\t\t}\n\t\tlet promiseAddFile;\n\t\ttry {\n\t\t\tname = name.trim();\n\t\t\tif (zipWriter.filenames.has(name)) {\n\t\t\t\tthrow new Error(ERR_DUPLICATED_NAME);\n\t\t\t}\n\t\t\tzipWriter.filenames.add(name);\n\t\t\tpromiseAddFile = addFile(zipWriter, name, reader, options);\n\t\t\tpendingAddFileCalls.add(promiseAddFile);\n\t\t\treturn await promiseAddFile;\n\t\t} catch (error) {\n\t\t\tzipWriter.filenames.delete(name);\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tpendingAddFileCalls.delete(promiseAddFile);\n\t\t\tconst pendingEntry = pendingEntries.shift();\n\t\t\tif (pendingEntry) {\n\t\t\t\tpendingEntry();\n\t\t\t} else {\n\t\t\t\tworkers--;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync close(comment = new Uint8Array(), options = {}) {\n\t\tconst zipWriter = this;\n\t\tconst { pendingAddFileCalls, writer } = this;\n\t\tconst { writable } = writer;\n\t\twhile (pendingAddFileCalls.size) {\n\t\t\tawait Promise.allSettled(Array.from(pendingAddFileCalls));\n\t\t}\n\t\tawait closeFile(this, comment, options);\n\t\tconst preventClose = getOptionValue(zipWriter, options, \"preventClose\");\n\t\tif (!preventClose) {\n\t\t\tawait writable.getWriter().close();\n\t\t}\n\t\treturn writer.getData ? writer.getData() : writable;\n\t}\n}\n\nclass ZipWriterStream {\n\n\tconstructor(options = {}) {\n\t\tconst { readable, writable } = new TransformStream();\n\t\tthis.readable = readable;\n\t\tthis.zipWriter = new ZipWriter(writable, options);\n\t}\n\n\ttransform(path) {\n\t\tconst { readable, writable } = new TransformStream({\n\t\t\tflush: () => { this.zipWriter.close(); }\n\t\t});\n\t\tthis.zipWriter.add(path, readable);\n\t\treturn { readable: this.readable, writable };\n\t}\n\n\twritable(path) {\n\t\tconst { readable, writable } = new TransformStream();\n\t\tthis.zipWriter.add(path, readable);\n\t\treturn writable;\n\t}\n\n\tclose(comment = undefined, options = {}) {\n\t\treturn this.zipWriter.close(comment, options);\n\t}\n}\n\nexport {\n\tZipWriter,\n\tZipWriterStream,\n\tERR_DUPLICATED_NAME,\n\tERR_INVALID_COMMENT,\n\tERR_INVALID_ENTRY_NAME,\n\tERR_INVALID_ENTRY_COMMENT,\n\tERR_INVALID_VERSION,\n\tERR_INVALID_EXTRAFIELD_TYPE,\n\tERR_INVALID_EXTRAFIELD_DATA,\n\tERR_INVALID_ENCRYPTION_STRENGTH,\n\tERR_UNSUPPORTED_FORMAT,\n\tERR_UNDEFINED_UNCOMPRESSED_SIZE\n};\n\nasync function addFile(zipWriter, name, reader, options) {\n\tname = name.trim();\n\tconst msDosCompatible = getOptionValue(zipWriter, options, PROPERTY_NAME_MS_DOS_COMPATIBLE);\n\tconst versionMadeBy = getOptionValue(zipWriter, options, PROPERTY_NAME_VERSION_MADE_BY, msDosCompatible ? 20 : 768);\n\tconst executable = getOptionValue(zipWriter, options, PROPERTY_NAME_EXECUTABLE);\n\tif (versionMadeBy > MAX_16_BITS) {\n\t\tthrow new Error(ERR_INVALID_VERSION);\n\t}\n\tlet externalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES, 0);\n\tif (externalFileAttributes === 0) {\n\t\texternalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE, 0);\n\t}\n\tif (!options.directory && name.endsWith(DIRECTORY_SIGNATURE)) {\n\t\toptions.directory = true;\n\t}\n\tconst directory = getOptionValue(zipWriter, options, PROPERTY_NAME_DIRECTORY);\n\tif (directory) {\n\t\tif (!name.endsWith(DIRECTORY_SIGNATURE)) {\n\t\t\tname += DIRECTORY_SIGNATURE;\n\t\t}\n\t\tif (externalFileAttributes === 0) {\n\t\t\tif (msDosCompatible) {\n\t\t\t\texternalFileAttributes = FILE_ATTR_MSDOS_DIR_MASK;\n\t\t\t} else {\n\t\t\t\texternalFileAttributes = FILE_ATTR_UNIX_DIR_MASK << 16;\n\t\t\t}\n\t\t}\n\t} else if (!msDosCompatible && externalFileAttributes === 0) {\n\t\tif (executable) {\n\t\t\texternalFileAttributes = (FILE_ATTR_UNIX_EXECUTABLE_MASK | FILE_ATTR_UNIX_DEFAULT_MASK) << 16;\n\t\t} else {\n\t\t\texternalFileAttributes = FILE_ATTR_UNIX_DEFAULT_MASK << 16;\n\t\t}\n\t}\n\tconst encode = getOptionValue(zipWriter, options, \"encodeText\", encodeText);\n\tlet rawFilename = encode(name);\n\tif (rawFilename === UNDEFINED_VALUE) {\n\t\trawFilename = encodeText(name);\n\t}\n\tif (getLength(rawFilename) > MAX_16_BITS) {\n\t\tthrow new Error(ERR_INVALID_ENTRY_NAME);\n\t}\n\tconst comment = options.comment || \"\";\n\tlet rawComment = encode(comment);\n\tif (rawComment === UNDEFINED_VALUE) {\n\t\trawComment = encodeText(comment);\n\t}\n\tif (getLength(rawComment) > MAX_16_BITS) {\n\t\tthrow new Error(ERR_INVALID_ENTRY_COMMENT);\n\t}\n\tconst version = getOptionValue(zipWriter, options, PROPERTY_NAME_VERSION, VERSION_DEFLATE);\n\tif (version > MAX_16_BITS) {\n\t\tthrow new Error(ERR_INVALID_VERSION);\n\t}\n\tconst lastModDate = getOptionValue(zipWriter, options, PROPERTY_NAME_LAST_MODIFICATION_DATE, new Date());\n\tconst lastAccessDate = getOptionValue(zipWriter, options, PROPERTY_NAME_LAST_ACCESS_DATE);\n\tconst creationDate = getOptionValue(zipWriter, options, PROPERTY_NAME_CREATION_DATE);\n\tlet internalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES, 0);\n\tif (internalFileAttributes === 0) {\n\t\tinternalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE, 0);\n\t}\n\tconst passThrough = getOptionValue(zipWriter, options, \"passThrough\");\n\tlet password, rawPassword;\n\tif (!passThrough) {\n\t\tpassword = getOptionValue(zipWriter, options, \"password\");\n\t\trawPassword = getOptionValue(zipWriter, options, \"rawPassword\");\n\t}\n\tconst encryptionStrength = getOptionValue(zipWriter, options, \"encryptionStrength\", 3);\n\tconst zipCrypto = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIPCRYPTO);\n\tconst extendedTimestamp = getOptionValue(zipWriter, options, \"extendedTimestamp\", true);\n\tconst keepOrder = getOptionValue(zipWriter, options, \"keepOrder\", true);\n\tconst level = getOptionValue(zipWriter, options, \"level\");\n\tconst useWebWorkers = getOptionValue(zipWriter, options, \"useWebWorkers\");\n\tconst bufferedWrite = getOptionValue(zipWriter, options, \"bufferedWrite\");\n\tconst dataDescriptorSignature = getOptionValue(zipWriter, options, \"dataDescriptorSignature\", false);\n\tconst signal = getOptionValue(zipWriter, options, \"signal\");\n\tconst useUnicodeFileNames = getOptionValue(zipWriter, options, \"useUnicodeFileNames\", true);\n\tconst useCompressionStream = getOptionValue(zipWriter, options, \"useCompressionStream\");\n\tconst compressionMethod = getOptionValue(zipWriter, options, \"compressionMethod\");\n\tlet dataDescriptor = getOptionValue(zipWriter, options, \"dataDescriptor\", true);\n\tlet zip64 = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIP64);\n\tif (!zipCrypto && (password !== UNDEFINED_VALUE || rawPassword !== UNDEFINED_VALUE) && !(encryptionStrength >= 1 && encryptionStrength <= 3)) {\n\t\tthrow new Error(ERR_INVALID_ENCRYPTION_STRENGTH);\n\t}\n\tlet rawExtraField = new Uint8Array();\n\tconst { extraField } = options;\n\tif (extraField) {\n\t\tlet extraFieldSize = 0;\n\t\tlet offset = 0;\n\t\textraField.forEach(data => extraFieldSize += 4 + getLength(data));\n\t\trawExtraField = new Uint8Array(extraFieldSize);\n\t\textraField.forEach((data, type) => {\n\t\t\tif (type > MAX_16_BITS) {\n\t\t\t\tthrow new Error(ERR_INVALID_EXTRAFIELD_TYPE);\n\t\t\t}\n\t\t\tif (getLength(data) > MAX_16_BITS) {\n\t\t\t\tthrow new Error(ERR_INVALID_EXTRAFIELD_DATA);\n\t\t\t}\n\t\t\tarraySet(rawExtraField, new Uint16Array([type]), offset);\n\t\t\tarraySet(rawExtraField, new Uint16Array([getLength(data)]), offset + 2);\n\t\t\tarraySet(rawExtraField, data, offset + 4);\n\t\t\toffset += 4 + getLength(data);\n\t\t});\n\t}\n\tlet maximumCompressedSize = 0;\n\tlet maximumEntrySize = 0;\n\tlet uncompressedSize = 0;\n\tif (passThrough) {\n\t\t({ uncompressedSize } = options);\n\t\tif (uncompressedSize === UNDEFINED_VALUE) {\n\t\t\tthrow new Error(ERR_UNDEFINED_UNCOMPRESSED_SIZE);\n\t\t}\n\t}\n\tconst zip64Enabled = zip64 === true;\n\tif (reader) {\n\t\treader = initReader(reader);\n\t\tawait initStream(reader);\n\t\tif (!passThrough) {\n\t\t\tif (reader.size === UNDEFINED_VALUE) {\n\t\t\t\tdataDescriptor = true;\n\t\t\t\tif (zip64 || zip64 === UNDEFINED_VALUE) {\n\t\t\t\t\tzip64 = true;\n\t\t\t\t\tuncompressedSize = maximumCompressedSize = MAX_32_BITS + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tuncompressedSize = reader.size;\n\t\t\t\tmaximumCompressedSize = getMaximumCompressedSize(uncompressedSize);\n\t\t\t}\n\t\t} else {\n\t\t\tmaximumCompressedSize = getMaximumCompressedSize(uncompressedSize);\n\t\t}\n\t}\n\tconst { diskOffset, diskNumber, maxSize } = zipWriter.writer;\n\tconst zip64UncompressedSize = zip64Enabled || uncompressedSize > MAX_32_BITS;\n\tconst zip64CompressedSize = zip64Enabled || maximumCompressedSize > MAX_32_BITS;\n\tconst zip64Offset = zip64Enabled || zipWriter.offset + zipWriter.pendingEntriesSize - diskOffset > MAX_32_BITS;\n\tconst supportZip64SplitFile = getOptionValue(zipWriter, options, \"supportZip64SplitFile\", true);\n\tconst zip64DiskNumberStart = (supportZip64SplitFile && zip64Enabled) || diskNumber + Math.ceil(zipWriter.pendingEntriesSize / maxSize) > MAX_16_BITS;\n\tif (zip64Offset || zip64UncompressedSize || zip64CompressedSize || zip64DiskNumberStart) {\n\t\tif (zip64 === false || !keepOrder) {\n\t\t\tthrow new Error(ERR_UNSUPPORTED_FORMAT);\n\t\t} else {\n\t\t\tzip64 = true;\n\t\t}\n\t}\n\tzip64 = zip64 || false;\n\tconst encrypted = getOptionValue(zipWriter, options, PROPERTY_NAME_ENCRYPTED);\n\tconst { signature } = options;\n\toptions = Object.assign({}, options, {\n\t\trawFilename,\n\t\trawComment,\n\t\tversion,\n\t\tversionMadeBy,\n\t\tlastModDate,\n\t\tlastAccessDate,\n\t\tcreationDate,\n\t\trawExtraField,\n\t\tzip64,\n\t\tzip64UncompressedSize,\n\t\tzip64CompressedSize,\n\t\tzip64Offset,\n\t\tzip64DiskNumberStart,\n\t\tpassword,\n\t\trawPassword,\n\t\tlevel: !useCompressionStream && (zipWriter.config.CompressionStream === UNDEFINED_VALUE && zipWriter.config.CompressionStreamNative === UNDEFINED_VALUE) ? 0 : level,\n\t\tuseWebWorkers,\n\t\tencryptionStrength,\n\t\textendedTimestamp,\n\t\tzipCrypto,\n\t\tbufferedWrite,\n\t\tkeepOrder,\n\t\tuseUnicodeFileNames,\n\t\tdataDescriptor,\n\t\tdataDescriptorSignature,\n\t\tsignal,\n\t\tmsDosCompatible,\n\t\tinternalFileAttribute: internalFileAttributes,\n\t\tinternalFileAttributes,\n\t\texternalFileAttribute: externalFileAttributes,\n\t\texternalFileAttributes,\n\t\tuseCompressionStream,\n\t\tpassThrough,\n\t\tencrypted: Boolean((password && getLength(password)) || (rawPassword && getLength(rawPassword))) || (passThrough && encrypted),\n\t\tsignature,\n\t\tcompressionMethod\n\t});\n\tconst headerInfo = getHeaderInfo(options);\n\tconst dataDescriptorInfo = getDataDescriptorInfo(options);\n\tconst metadataSize = getLength(headerInfo.localHeaderArray, dataDescriptorInfo.dataDescriptorArray);\n\tmaximumEntrySize = metadataSize + maximumCompressedSize;\n\tif (zipWriter.options.usdz) {\n\t\tmaximumEntrySize += maximumEntrySize + 64;\n\t}\n\tzipWriter.pendingEntriesSize += maximumEntrySize;\n\tlet fileEntry;\n\ttry {\n\t\tfileEntry = await getFileEntry(zipWriter, name, reader, { headerInfo, dataDescriptorInfo, metadataSize }, options);\n\t} finally {\n\t\tzipWriter.pendingEntriesSize -= maximumEntrySize;\n\t}\n\tObject.assign(fileEntry, { name, comment, extraField });\n\treturn new Entry(fileEntry);\n}\n\nasync function getFileEntry(zipWriter, name, reader, entryInfo, options) {\n\tconst {\n\t\tfiles,\n\t\twriter\n\t} = zipWriter;\n\tconst {\n\t\tkeepOrder,\n\t\tdataDescriptor,\n\t\tsignal\n\t} = options;\n\tconst {\n\t\theaderInfo\n\t} = entryInfo;\n\tconst { usdz } = zipWriter.options;\n\tconst previousFileEntry = Array.from(files.values()).pop();\n\tlet fileEntry = {};\n\tlet bufferedWrite;\n\tlet releaseLockWriter;\n\tlet releaseLockCurrentFileEntry;\n\tlet writingBufferedEntryData;\n\tlet writingEntryData;\n\tlet fileWriter;\n\tlet blobPromise;\n\tfiles.set(name, fileEntry);\n\ttry {\n\t\tlet lockPreviousFileEntry;\n\t\tif (keepOrder) {\n\t\t\tlockPreviousFileEntry = previousFileEntry && previousFileEntry.lock;\n\t\t\trequestLockCurrentFileEntry();\n\t\t}\n\t\tif ((options.bufferedWrite || zipWriter.writerLocked || (zipWriter.bufferedWrites && keepOrder) || !dataDescriptor) && !usdz) {\n\t\t\tfileWriter = new TransformStream();\n\t\t\tblobPromise = new Response(fileWriter.readable).blob();\n\t\t\tfileWriter.writable.size = 0;\n\t\t\tbufferedWrite = true;\n\t\t\tzipWriter.bufferedWrites++;\n\t\t\tawait initStream(writer);\n\t\t} else {\n\t\t\tfileWriter = writer;\n\t\t\tawait requestLockWriter();\n\t\t}\n\t\tawait initStream(fileWriter);\n\t\tconst { writable } = writer;\n\t\tlet { diskOffset } = writer;\n\t\tif (zipWriter.addSplitZipSignature) {\n\t\t\tdelete zipWriter.addSplitZipSignature;\n\t\t\tconst signatureArray = new Uint8Array(4);\n\t\t\tconst signatureArrayView = getDataView(signatureArray);\n\t\t\tsetUint32(signatureArrayView, 0, SPLIT_ZIP_FILE_SIGNATURE);\n\t\t\tawait writeData(writable, signatureArray);\n\t\t\tzipWriter.offset += 4;\n\t\t}\n\t\tif (usdz) {\n\t\t\tappendExtraFieldUSDZ(entryInfo, zipWriter.offset - diskOffset);\n\t\t}\n\t\tif (!bufferedWrite) {\n\t\t\tawait lockPreviousFileEntry;\n\t\t\tawait skipDiskIfNeeded(writable);\n\t\t}\n\t\tconst { diskNumber } = writer;\n\t\twritingEntryData = true;\n\t\tfileEntry.diskNumberStart = diskNumber;\n\t\tfileEntry = await createFileEntry(reader, fileWriter, fileEntry, entryInfo, zipWriter.config, options);\n\t\twritingEntryData = false;\n\t\tfiles.set(name, fileEntry);\n\t\tfileEntry.filename = name;\n\t\tif (bufferedWrite) {\n\t\t\tawait fileWriter.writable.getWriter().close();\n\t\t\tlet blob = await blobPromise;\n\t\t\tawait lockPreviousFileEntry;\n\t\t\tawait requestLockWriter();\n\t\t\twritingBufferedEntryData = true;\n\t\t\tif (!dataDescriptor) {\n\t\t\t\tblob = await writeExtraHeaderInfo(fileEntry, blob, writable, options);\n\t\t\t}\n\t\t\tawait skipDiskIfNeeded(writable);\n\t\t\tfileEntry.diskNumberStart = writer.diskNumber;\n\t\t\tdiskOffset = writer.diskOffset;\n\t\t\tawait blob.stream().pipeTo(writable, { preventClose: true, preventAbort: true, signal });\n\t\t\twritable.size += blob.size;\n\t\t\twritingBufferedEntryData = false;\n\t\t}\n\t\tfileEntry.offset = zipWriter.offset - diskOffset;\n\t\tif (fileEntry.zip64) {\n\t\t\tsetZip64ExtraInfo(fileEntry, options);\n\t\t} else if (fileEntry.offset > MAX_32_BITS) {\n\t\t\tthrow new Error(ERR_UNSUPPORTED_FORMAT);\n\t\t}\n\t\tzipWriter.offset += fileEntry.size;\n\t\treturn fileEntry;\n\t} catch (error) {\n\t\tif ((bufferedWrite && writingBufferedEntryData) || (!bufferedWrite && writingEntryData)) {\n\t\t\tzipWriter.hasCorruptedEntries = true;\n\t\t\tif (error) {\n\t\t\t\ttry {\n\t\t\t\t\terror.corruptedEntry = true;\n\t\t\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\t\t} catch (_) {\n\t\t\t\t\t// ignored\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bufferedWrite) {\n\t\t\t\tzipWriter.offset += fileWriter.writable.size;\n\t\t\t} else {\n\t\t\t\tzipWriter.offset = fileWriter.writable.size;\n\t\t\t}\n\t\t}\n\t\tfiles.delete(name);\n\t\tthrow error;\n\t} finally {\n\t\tif (bufferedWrite) {\n\t\t\tzipWriter.bufferedWrites--;\n\t\t}\n\t\tif (releaseLockCurrentFileEntry) {\n\t\t\treleaseLockCurrentFileEntry();\n\t\t}\n\t\tif (releaseLockWriter) {\n\t\t\treleaseLockWriter();\n\t\t}\n\t}\n\n\tfunction requestLockCurrentFileEntry() {\n\t\tfileEntry.lock = new Promise(resolve => releaseLockCurrentFileEntry = resolve);\n\t}\n\n\tasync function requestLockWriter() {\n\t\tzipWriter.writerLocked = true;\n\t\tconst { lockWriter } = zipWriter;\n\t\tzipWriter.lockWriter = new Promise(resolve => releaseLockWriter = () => {\n\t\t\tzipWriter.writerLocked = false;\n\t\t\tresolve();\n\t\t});\n\t\tawait lockWriter;\n\t}\n\n\tasync function skipDiskIfNeeded(writable) {\n\t\tif (getLength(headerInfo.localHeaderArray) > writer.availableSize) {\n\t\t\twriter.availableSize = 0;\n\t\t\tawait writeData(writable, new Uint8Array());\n\t\t}\n\t}\n}\n\nasync function createFileEntry(reader, writer, { diskNumberStart, lock }, entryInfo, config, options) {\n\tconst {\n\t\theaderInfo,\n\t\tdataDescriptorInfo,\n\t\tmetadataSize\n\t} = entryInfo;\n\tconst {\n\t\tlocalHeaderArray,\n\t\theaderArray,\n\t\tlastModDate,\n\t\trawLastModDate,\n\t\tencrypted,\n\t\tcompressed,\n\t\tversion,\n\t\tcompressionMethod,\n\t\trawExtraFieldExtendedTimestamp,\n\t\textraFieldExtendedTimestampFlag,\n\t\trawExtraFieldNTFS,\n\t\trawExtraFieldAES\n\t} = headerInfo;\n\tconst { dataDescriptorArray } = dataDescriptorInfo;\n\tconst {\n\t\trawFilename,\n\t\tlastAccessDate,\n\t\tcreationDate,\n\t\tpassword,\n\t\trawPassword,\n\t\tlevel,\n\t\tzip64,\n\t\tzip64UncompressedSize,\n\t\tzip64CompressedSize,\n\t\tzip64Offset,\n\t\tzip64DiskNumberStart,\n\t\tzipCrypto,\n\t\tdataDescriptor,\n\t\tdirectory,\n\t\texecutable,\n\t\tversionMadeBy,\n\t\trawComment,\n\t\trawExtraField,\n\t\tuseWebWorkers,\n\t\tonstart,\n\t\tonprogress,\n\t\tonend,\n\t\tsignal,\n\t\tencryptionStrength,\n\t\textendedTimestamp,\n\t\tmsDosCompatible,\n\t\tinternalFileAttributes,\n\t\texternalFileAttributes,\n\t\tuseCompressionStream,\n\t\tpassThrough\n\t} = options;\n\tconst fileEntry = {\n\t\tlock,\n\t\tversionMadeBy,\n\t\tzip64,\n\t\tdirectory: Boolean(directory),\n\t\texecutable: Boolean(executable),\n\t\tfilenameUTF8: true,\n\t\trawFilename,\n\t\tcommentUTF8: true,\n\t\trawComment,\n\t\trawExtraFieldExtendedTimestamp,\n\t\trawExtraFieldNTFS,\n\t\trawExtraFieldAES,\n\t\trawExtraField,\n\t\textendedTimestamp,\n\t\tmsDosCompatible,\n\t\tinternalFileAttributes,\n\t\texternalFileAttributes,\n\t\tdiskNumberStart\n\t};\n\tlet {\n\t\tsignature,\n\t\tuncompressedSize\n\t} = options;\n\tlet compressedSize = 0;\n\tif (!passThrough) {\n\t\tuncompressedSize = 0;\n\t}\n\tconst { writable } = writer;\n\tif (reader) {\n\t\treader.chunkSize = getChunkSize(config);\n\t\tawait writeData(writable, localHeaderArray);\n\t\tconst readable = reader.readable;\n\t\tconst size = readable.size = reader.size;\n\t\tconst workerOptions = {\n\t\t\toptions: {\n\t\t\t\tcodecType: CODEC_DEFLATE,\n\t\t\t\tlevel,\n\t\t\t\trawPassword,\n\t\t\t\tpassword,\n\t\t\t\tencryptionStrength,\n\t\t\t\tzipCrypto: encrypted && zipCrypto,\n\t\t\t\tpasswordVerification: encrypted && zipCrypto && (rawLastModDate >> 8) & 0xFF,\n\t\t\t\tsigned: !passThrough,\n\t\t\t\tcompressed: compressed && !passThrough,\n\t\t\t\tencrypted: encrypted && !passThrough,\n\t\t\t\tuseWebWorkers,\n\t\t\t\tuseCompressionStream,\n\t\t\t\ttransferStreams: false\n\t\t\t},\n\t\t\tconfig,\n\t\t\tstreamOptions: { signal, size, onstart, onprogress, onend }\n\t\t};\n\t\tconst result = await runWorker({ readable, writable }, workerOptions);\n\t\tcompressedSize = result.outputSize;\n\t\tif (!passThrough) {\n\t\t\tuncompressedSize = result.inputSize;\n\t\t\tsignature = result.signature;\n\t\t}\n\t\twritable.size += uncompressedSize;\n\t} else {\n\t\tawait writeData(writable, localHeaderArray);\n\t}\n\tlet rawExtraFieldZip64;\n\tif (zip64) {\n\t\tlet rawExtraFieldZip64Length = 4;\n\t\tif (zip64UncompressedSize) {\n\t\t\trawExtraFieldZip64Length += 8;\n\t\t}\n\t\tif (zip64CompressedSize) {\n\t\t\trawExtraFieldZip64Length += 8;\n\t\t}\n\t\tif (zip64Offset) {\n\t\t\trawExtraFieldZip64Length += 8;\n\t\t}\n\t\tif (zip64DiskNumberStart) {\n\t\t\trawExtraFieldZip64Length += 4;\n\t\t}\n\t\trawExtraFieldZip64 = new Uint8Array(rawExtraFieldZip64Length);\n\t} else {\n\t\trawExtraFieldZip64 = new Uint8Array();\n\t}\n\tsetEntryInfo({\n\t\tsignature,\n\t\trawExtraFieldZip64,\n\t\tcompressedSize,\n\t\tuncompressedSize,\n\t\theaderInfo,\n\t\tdataDescriptorInfo\n\t}, options);\n\tif (dataDescriptor) {\n\t\tawait writeData(writable, dataDescriptorArray);\n\t}\n\tObject.assign(fileEntry, {\n\t\tuncompressedSize,\n\t\tcompressedSize,\n\t\tlastModDate,\n\t\trawLastModDate,\n\t\tcreationDate,\n\t\tlastAccessDate,\n\t\tencrypted,\n\t\tzipCrypto,\n\t\tsize: metadataSize + compressedSize,\n\t\tcompressionMethod,\n\t\tversion,\n\t\theaderArray,\n\t\tsignature,\n\t\trawExtraFieldZip64,\n\t\textraFieldExtendedTimestampFlag,\n\t\tzip64UncompressedSize,\n\t\tzip64CompressedSize,\n\t\tzip64Offset,\n\t\tzip64DiskNumberStart\n\t});\n\treturn fileEntry;\n}\n\nfunction getHeaderInfo(options) {\n\tconst {\n\t\trawFilename,\n\t\tlastModDate,\n\t\tlastAccessDate,\n\t\tcreationDate,\n\t\tlevel,\n\t\tzip64,\n\t\tzipCrypto,\n\t\tuseUnicodeFileNames,\n\t\tdataDescriptor,\n\t\tdirectory,\n\t\trawExtraField,\n\t\tencryptionStrength,\n\t\textendedTimestamp,\n\t\tencrypted\n\t} = options;\n\tlet { version, compressionMethod } = options;\n\tconst compressed = !directory && (level > 0 || (level === UNDEFINED_VALUE && compressionMethod !== 0));\n\tlet rawExtraFieldAES;\n\tif (encrypted && !zipCrypto) {\n\t\trawExtraFieldAES = new Uint8Array(getLength(EXTRAFIELD_DATA_AES) + 2);\n\t\tconst extraFieldAESView = getDataView(rawExtraFieldAES);\n\t\tsetUint16(extraFieldAESView, 0, EXTRAFIELD_TYPE_AES);\n\t\tarraySet(rawExtraFieldAES, EXTRAFIELD_DATA_AES, 2);\n\t\tsetUint8(extraFieldAESView, 8, encryptionStrength);\n\t} else {\n\t\trawExtraFieldAES = new Uint8Array();\n\t}\n\tlet rawExtraFieldNTFS;\n\tlet rawExtraFieldExtendedTimestamp;\n\tlet extraFieldExtendedTimestampFlag;\n\tif (extendedTimestamp) {\n\t\trawExtraFieldExtendedTimestamp = new Uint8Array(9 + (lastAccessDate ? 4 : 0) + (creationDate ? 4 : 0));\n\t\tconst extraFieldExtendedTimestampView = getDataView(rawExtraFieldExtendedTimestamp);\n\t\tsetUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);\n\t\tsetUint16(extraFieldExtendedTimestampView, 2, getLength(rawExtraFieldExtendedTimestamp) - 4);\n\t\textraFieldExtendedTimestampFlag = 0x1 + (lastAccessDate ? 0x2 : 0) + (creationDate ? 0x4 : 0);\n\t\tsetUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);\n\t\tlet offset = 5;\n\t\tsetUint32(extraFieldExtendedTimestampView, offset, Math.floor(lastModDate.getTime() / 1000));\n\t\toffset += 4;\n\t\tif (lastAccessDate) {\n\t\t\tsetUint32(extraFieldExtendedTimestampView, offset, Math.floor(lastAccessDate.getTime() / 1000));\n\t\t\toffset += 4;\n\t\t}\n\t\tif (creationDate) {\n\t\t\tsetUint32(extraFieldExtendedTimestampView, offset, Math.floor(creationDate.getTime() / 1000));\n\t\t}\n\t\ttry {\n\t\t\trawExtraFieldNTFS = new Uint8Array(36);\n\t\t\tconst extraFieldNTFSView = getDataView(rawExtraFieldNTFS);\n\t\t\tconst lastModTimeNTFS = getTimeNTFS(lastModDate);\n\t\t\tsetUint16(extraFieldNTFSView, 0, EXTRAFIELD_TYPE_NTFS);\n\t\t\tsetUint16(extraFieldNTFSView, 2, 32);\n\t\t\tsetUint16(extraFieldNTFSView, 8, EXTRAFIELD_TYPE_NTFS_TAG1);\n\t\t\tsetUint16(extraFieldNTFSView, 10, 24);\n\t\t\tsetBigUint64(extraFieldNTFSView, 12, lastModTimeNTFS);\n\t\t\tsetBigUint64(extraFieldNTFSView, 20, getTimeNTFS(lastAccessDate) || lastModTimeNTFS);\n\t\t\tsetBigUint64(extraFieldNTFSView, 28, getTimeNTFS(creationDate) || lastModTimeNTFS);\n\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t} catch (_) {\n\t\t\trawExtraFieldNTFS = new Uint8Array();\n\t\t}\n\t} else {\n\t\trawExtraFieldNTFS = rawExtraFieldExtendedTimestamp = new Uint8Array();\n\t}\n\tlet bitFlag = 0;\n\tif (useUnicodeFileNames) {\n\t\tbitFlag = bitFlag | BITFLAG_LANG_ENCODING_FLAG;\n\t}\n\tif (dataDescriptor) {\n\t\tbitFlag = bitFlag | BITFLAG_DATA_DESCRIPTOR;\n\t}\n\tif (compressionMethod === UNDEFINED_VALUE) {\n\t\tcompressionMethod = compressed ? COMPRESSION_METHOD_DEFLATE : COMPRESSION_METHOD_STORE;\n\t}\n\tif (compressionMethod == COMPRESSION_METHOD_DEFLATE) {\n\t\tif (level >= 1 && level < 3) {\n\t\t\tbitFlag = bitFlag | 0b110;\n\t\t}\n\t\tif (level >= 3 && level < 5) {\n\t\t\tbitFlag = bitFlag | 0b01;\n\t\t}\n\t\tif (level === 9) {\n\t\t\tbitFlag = bitFlag | 0b10;\n\t\t}\n\t}\n\tif (zip64) {\n\t\tversion = version > VERSION_ZIP64 ? version : VERSION_ZIP64;\n\t}\n\tif (encrypted) {\n\t\tbitFlag = bitFlag | BITFLAG_ENCRYPTED;\n\t\tif (!zipCrypto) {\n\t\t\tversion = version > VERSION_AES ? version : VERSION_AES;\n\t\t\trawExtraFieldAES[9] = compressionMethod;\n\t\t\tcompressionMethod = COMPRESSION_METHOD_AES;\n\t\t}\n\t}\n\tconst headerArray = new Uint8Array(26);\n\tconst headerView = getDataView(headerArray);\n\tsetUint16(headerView, 0, version);\n\tsetUint16(headerView, 2, bitFlag);\n\tsetUint16(headerView, 4, compressionMethod);\n\tconst dateArray = new Uint32Array(1);\n\tconst dateView = getDataView(dateArray);\n\tlet lastModDateMsDos;\n\tif (lastModDate < MIN_DATE) {\n\t\tlastModDateMsDos = MIN_DATE;\n\t} else if (lastModDate > MAX_DATE) {\n\t\tlastModDateMsDos = MAX_DATE;\n\t} else {\n\t\tlastModDateMsDos = lastModDate;\n\t}\n\tsetUint16(dateView, 0, (((lastModDateMsDos.getHours() << 6) | lastModDateMsDos.getMinutes()) << 5) | lastModDateMsDos.getSeconds() / 2);\n\tsetUint16(dateView, 2, ((((lastModDateMsDos.getFullYear() - 1980) << 4) | (lastModDateMsDos.getMonth() + 1)) << 5) | lastModDateMsDos.getDate());\n\tconst rawLastModDate = dateArray[0];\n\tsetUint32(headerView, 6, rawLastModDate);\n\tsetUint16(headerView, 22, getLength(rawFilename));\n\tconst extraFieldLength = getLength(rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraField);\n\tsetUint16(headerView, 24, extraFieldLength);\n\tconst localHeaderArray = new Uint8Array(30 + getLength(rawFilename) + extraFieldLength);\n\tconst localHeaderView = getDataView(localHeaderArray);\n\tsetUint32(localHeaderView, 0, LOCAL_FILE_HEADER_SIGNATURE);\n\tarraySet(localHeaderArray, headerArray, 4);\n\tarraySet(localHeaderArray, rawFilename, 30);\n\tarraySet(localHeaderArray, rawExtraFieldAES, 30 + getLength(rawFilename));\n\tarraySet(localHeaderArray, rawExtraFieldExtendedTimestamp, 30 + getLength(rawFilename, rawExtraFieldAES));\n\tarraySet(localHeaderArray, rawExtraFieldNTFS, 30 + getLength(rawFilename, rawExtraFieldAES, rawExtraFieldExtendedTimestamp));\n\tarraySet(localHeaderArray, rawExtraField, 30 + getLength(rawFilename, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS));\n\treturn {\n\t\tlocalHeaderArray,\n\t\theaderArray,\n\t\theaderView,\n\t\tlastModDate,\n\t\trawLastModDate,\n\t\tencrypted,\n\t\tcompressed,\n\t\tversion,\n\t\tcompressionMethod,\n\t\textraFieldExtendedTimestampFlag,\n\t\trawExtraFieldExtendedTimestamp,\n\t\trawExtraFieldNTFS,\n\t\trawExtraFieldAES,\n\t\textraFieldLength\n\t};\n}\n\nfunction appendExtraFieldUSDZ(entryInfo, zipWriterOffset) {\n\tconst { headerInfo } = entryInfo;\n\tlet { localHeaderArray, extraFieldLength } = headerInfo;\n\tlet localHeaderArrayView = getDataView(localHeaderArray);\n\tlet extraBytesLength = 64 - ((zipWriterOffset + getLength(localHeaderArray)) % 64);\n\tif (extraBytesLength < 4) {\n\t\textraBytesLength += 64;\n\t}\n\tconst rawExtraFieldUSDZ = new Uint8Array(extraBytesLength);\n\tconst extraFieldUSDZView = getDataView(rawExtraFieldUSDZ);\n\tsetUint16(extraFieldUSDZView, 0, EXTRAFIELD_TYPE_USDZ);\n\tsetUint16(extraFieldUSDZView, 2, extraBytesLength - 2);\n\tconst previousLocalHeaderArray = localHeaderArray;\n\theaderInfo.localHeaderArray = localHeaderArray = new Uint8Array(getLength(previousLocalHeaderArray) + extraBytesLength);\n\tarraySet(localHeaderArray, previousLocalHeaderArray);\n\tarraySet(localHeaderArray, rawExtraFieldUSDZ, getLength(previousLocalHeaderArray));\n\tlocalHeaderArrayView = getDataView(localHeaderArray);\n\tsetUint16(localHeaderArrayView, 28, extraFieldLength + extraBytesLength);\n\tentryInfo.metadataSize += extraBytesLength;\n}\n\nfunction getDataDescriptorInfo(options) {\n\tconst {\n\t\tzip64,\n\t\tdataDescriptor,\n\t\tdataDescriptorSignature\n\t} = options;\n\tlet dataDescriptorArray = new Uint8Array();\n\tlet dataDescriptorView, dataDescriptorOffset = 0;\n\tif (dataDescriptor) {\n\t\tdataDescriptorArray = new Uint8Array(zip64 ? (dataDescriptorSignature ? 24 : 20) : (dataDescriptorSignature ? 16 : 12));\n\t\tdataDescriptorView = getDataView(dataDescriptorArray);\n\t\tif (dataDescriptorSignature) {\n\t\t\tdataDescriptorOffset = 4;\n\t\t\tsetUint32(dataDescriptorView, 0, DATA_DESCRIPTOR_RECORD_SIGNATURE);\n\t\t}\n\t}\n\treturn {\n\t\tdataDescriptorArray,\n\t\tdataDescriptorView,\n\t\tdataDescriptorOffset\n\t};\n}\n\nfunction setEntryInfo(entryInfo, options) {\n\tconst {\n\t\tsignature,\n\t\trawExtraFieldZip64,\n\t\tcompressedSize,\n\t\tuncompressedSize,\n\t\theaderInfo,\n\t\tdataDescriptorInfo\n\t} = entryInfo;\n\tconst {\n\t\theaderView,\n\t\tencrypted\n\t} = headerInfo;\n\tconst {\n\t\tdataDescriptorView,\n\t\tdataDescriptorOffset\n\t} = dataDescriptorInfo;\n\tconst {\n\t\tzip64,\n\t\tzip64UncompressedSize,\n\t\tzip64CompressedSize,\n\t\tzipCrypto,\n\t\tdataDescriptor\n\t} = options;\n\tif ((!encrypted || zipCrypto) && signature !== UNDEFINED_VALUE) {\n\t\tsetUint32(headerView, 10, signature);\n\t\tif (dataDescriptor) {\n\t\t\tsetUint32(dataDescriptorView, dataDescriptorOffset, signature);\n\t\t}\n\t}\n\tif (zip64) {\n\t\tconst rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);\n\t\tsetUint16(rawExtraFieldZip64View, 0, EXTRAFIELD_TYPE_ZIP64);\n\t\tsetUint16(rawExtraFieldZip64View, 2, getLength(rawExtraFieldZip64) - 4);\n\t\tlet rawExtraFieldZip64Offset = 4;\n\t\tif (zip64UncompressedSize) {\n\t\t\tsetUint32(headerView, 18, MAX_32_BITS);\n\t\t\tsetBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(uncompressedSize));\n\t\t\trawExtraFieldZip64Offset += 8;\n\t\t}\n\t\tif (zip64CompressedSize) {\n\t\t\tsetUint32(headerView, 14, MAX_32_BITS);\n\t\t\tsetBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(compressedSize));\n\t\t}\n\t\tif (dataDescriptor) {\n\t\t\tsetBigUint64(dataDescriptorView, dataDescriptorOffset + 4, BigInt(compressedSize));\n\t\t\tsetBigUint64(dataDescriptorView, dataDescriptorOffset + 12, BigInt(uncompressedSize));\n\t\t}\n\t} else {\n\t\tsetUint32(headerView, 14, compressedSize);\n\t\tsetUint32(headerView, 18, uncompressedSize);\n\t\tif (dataDescriptor) {\n\t\t\tsetUint32(dataDescriptorView, dataDescriptorOffset + 4, compressedSize);\n\t\t\tsetUint32(dataDescriptorView, dataDescriptorOffset + 8, uncompressedSize);\n\t\t}\n\t}\n}\n\nasync function writeExtraHeaderInfo(fileEntry, entryData, writable, { zipCrypto }) {\n\tlet arrayBuffer;\n\tarrayBuffer = await entryData.slice(0, 26).arrayBuffer();\n\tif (arrayBuffer.byteLength != 26) {\n\t\tarrayBuffer = arrayBuffer.slice(0, 26);\n\t}\n\tconst arrayBufferView = new DataView(arrayBuffer);\n\tif (!fileEntry.encrypted || zipCrypto) {\n\t\tsetUint32(arrayBufferView, 14, fileEntry.signature);\n\t}\n\tif (fileEntry.zip64) {\n\t\tsetUint32(arrayBufferView, 18, MAX_32_BITS);\n\t\tsetUint32(arrayBufferView, 22, MAX_32_BITS);\n\t} else {\n\t\tsetUint32(arrayBufferView, 18, fileEntry.compressedSize);\n\t\tsetUint32(arrayBufferView, 22, fileEntry.uncompressedSize);\n\t}\n\tawait writeData(writable, new Uint8Array(arrayBuffer));\n\treturn entryData.slice(arrayBuffer.byteLength);\n}\n\nfunction setZip64ExtraInfo(fileEntry, options) {\n\tconst { rawExtraFieldZip64, offset, diskNumberStart } = fileEntry;\n\tconst { zip64UncompressedSize, zip64CompressedSize, zip64Offset, zip64DiskNumberStart } = options;\n\tconst rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);\n\tlet rawExtraFieldZip64Offset = 4;\n\tif (zip64UncompressedSize) {\n\t\trawExtraFieldZip64Offset += 8;\n\t}\n\tif (zip64CompressedSize) {\n\t\trawExtraFieldZip64Offset += 8;\n\t}\n\tif (zip64Offset) {\n\t\tsetBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(offset));\n\t\trawExtraFieldZip64Offset += 8;\n\t}\n\tif (zip64DiskNumberStart) {\n\t\tsetUint32(rawExtraFieldZip64View, rawExtraFieldZip64Offset, diskNumberStart);\n\t}\n}\n\nasync function closeFile(zipWriter, comment, options) {\n\tconst { files, writer } = zipWriter;\n\tconst { diskOffset, writable } = writer;\n\tlet { diskNumber } = writer;\n\tlet offset = 0;\n\tlet directoryDataLength = 0;\n\tlet directoryOffset = zipWriter.offset - diskOffset;\n\tlet filesLength = files.size;\n\tfor (const [, fileEntry] of files) {\n\t\tconst {\n\t\t\trawFilename,\n\t\t\trawExtraFieldZip64,\n\t\t\trawExtraFieldAES,\n\t\t\trawComment,\n\t\t\trawExtraFieldNTFS,\n\t\t\trawExtraField,\n\t\t\textendedTimestamp,\n\t\t\textraFieldExtendedTimestampFlag,\n\t\t\tlastModDate\n\t\t} = fileEntry;\n\t\tlet rawExtraFieldTimestamp;\n\t\tif (extendedTimestamp) {\n\t\t\trawExtraFieldTimestamp = new Uint8Array(9);\n\t\t\tconst extraFieldExtendedTimestampView = getDataView(rawExtraFieldTimestamp);\n\t\t\tsetUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);\n\t\t\tsetUint16(extraFieldExtendedTimestampView, 2, 5);\n\t\t\tsetUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);\n\t\t\tsetUint32(extraFieldExtendedTimestampView, 5, Math.floor(lastModDate.getTime() / 1000));\n\t\t} else {\n\t\t\trawExtraFieldTimestamp = new Uint8Array();\n\t\t}\n\t\tfileEntry.rawExtraFieldCDExtendedTimestamp = rawExtraFieldTimestamp;\n\t\tdirectoryDataLength += 46 +\n\t\t\tgetLength(\n\t\t\t\trawFilename,\n\t\t\t\trawComment,\n\t\t\t\trawExtraFieldZip64,\n\t\t\t\trawExtraFieldAES,\n\t\t\t\trawExtraFieldNTFS,\n\t\t\t\trawExtraFieldTimestamp,\n\t\t\t\trawExtraField);\n\t}\n\tconst directoryArray = new Uint8Array(directoryDataLength);\n\tconst directoryView = getDataView(directoryArray);\n\tawait initStream(writer);\n\tlet directoryDiskOffset = 0;\n\tfor (const [indexFileEntry, fileEntry] of Array.from(files.values()).entries()) {\n\t\tconst {\n\t\t\toffset: fileEntryOffset,\n\t\t\trawFilename,\n\t\t\trawExtraFieldZip64,\n\t\t\trawExtraFieldAES,\n\t\t\trawExtraFieldCDExtendedTimestamp,\n\t\t\trawExtraFieldNTFS,\n\t\t\trawExtraField,\n\t\t\trawComment,\n\t\t\tversionMadeBy,\n\t\t\theaderArray,\n\t\t\tzip64,\n\t\t\tzip64UncompressedSize,\n\t\t\tzip64CompressedSize,\n\t\t\tzip64DiskNumberStart,\n\t\t\tzip64Offset,\n\t\t\tinternalFileAttributes,\n\t\t\texternalFileAttributes,\n\t\t\tdiskNumberStart,\n\t\t\tuncompressedSize,\n\t\t\tcompressedSize\n\t\t} = fileEntry;\n\t\tconst extraFieldLength = getLength(rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldCDExtendedTimestamp, rawExtraFieldNTFS, rawExtraField);\n\t\tsetUint32(directoryView, offset, CENTRAL_FILE_HEADER_SIGNATURE);\n\t\tsetUint16(directoryView, offset + 4, versionMadeBy);\n\t\tconst headerView = getDataView(headerArray);\n\t\tif (!zip64UncompressedSize) {\n\t\t\tsetUint32(headerView, 18, uncompressedSize);\n\t\t}\n\t\tif (!zip64CompressedSize) {\n\t\t\tsetUint32(headerView, 14, compressedSize);\n\t\t}\n\t\tarraySet(directoryArray, headerArray, offset + 6);\n\t\tsetUint16(directoryView, offset + 30, extraFieldLength);\n\t\tsetUint16(directoryView, offset + 32, getLength(rawComment));\n\t\tsetUint16(directoryView, offset + 34, zip64 && zip64DiskNumberStart ? MAX_16_BITS : diskNumberStart);\n\t\tsetUint16(directoryView, offset + 36, internalFileAttributes);\n\t\tif (externalFileAttributes) {\n\t\t\tsetUint32(directoryView, offset + 38, externalFileAttributes);\n\t\t}\n\t\tsetUint32(directoryView, offset + 42, zip64 && zip64Offset ? MAX_32_BITS : fileEntryOffset);\n\t\tarraySet(directoryArray, rawFilename, offset + 46);\n\t\tarraySet(directoryArray, rawExtraFieldZip64, offset + 46 + getLength(rawFilename));\n\t\tarraySet(directoryArray, rawExtraFieldAES, offset + 46 + getLength(rawFilename, rawExtraFieldZip64));\n\t\tarraySet(directoryArray, rawExtraFieldCDExtendedTimestamp, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES));\n\t\tarraySet(directoryArray, rawExtraFieldNTFS, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldCDExtendedTimestamp));\n\t\tarraySet(directoryArray, rawExtraField, offset + 46 + getLength(rawFilename, rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldCDExtendedTimestamp, rawExtraFieldNTFS));\n\t\tarraySet(directoryArray, rawComment, offset + 46 + getLength(rawFilename) + extraFieldLength);\n\t\tconst directoryEntryLength = 46 + getLength(rawFilename, rawComment) + extraFieldLength;\n\t\tif (offset - directoryDiskOffset > writer.availableSize) {\n\t\t\twriter.availableSize = 0;\n\t\t\tawait writeData(writable, directoryArray.slice(directoryDiskOffset, offset));\n\t\t\tdirectoryDiskOffset = offset;\n\t\t}\n\t\toffset += directoryEntryLength;\n\t\tif (options.onprogress) {\n\t\t\ttry {\n\t\t\t\tawait options.onprogress(indexFileEntry + 1, files.size, new Entry(fileEntry));\n\t\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\t} catch (_) {\n\t\t\t\t// ignored\n\t\t\t}\n\t\t}\n\t}\n\tawait writeData(writable, directoryDiskOffset ? directoryArray.slice(directoryDiskOffset) : directoryArray);\n\tlet lastDiskNumber = writer.diskNumber;\n\tconst { availableSize } = writer;\n\tif (availableSize < END_OF_CENTRAL_DIR_LENGTH) {\n\t\tlastDiskNumber++;\n\t}\n\tlet zip64 = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIP64);\n\tif (directoryOffset > MAX_32_BITS || directoryDataLength > MAX_32_BITS || filesLength > MAX_16_BITS || lastDiskNumber > MAX_16_BITS) {\n\t\tif (zip64 === false) {\n\t\t\tthrow new Error(ERR_UNSUPPORTED_FORMAT);\n\t\t} else {\n\t\t\tzip64 = true;\n\t\t}\n\t}\n\tconst endOfdirectoryArray = new Uint8Array(zip64 ? ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH : END_OF_CENTRAL_DIR_LENGTH);\n\tconst endOfdirectoryView = getDataView(endOfdirectoryArray);\n\toffset = 0;\n\tif (zip64) {\n\t\tsetUint32(endOfdirectoryView, 0, ZIP64_END_OF_CENTRAL_DIR_SIGNATURE);\n\t\tsetBigUint64(endOfdirectoryView, 4, BigInt(44));\n\t\tsetUint16(endOfdirectoryView, 12, 45);\n\t\tsetUint16(endOfdirectoryView, 14, 45);\n\t\tsetUint32(endOfdirectoryView, 16, lastDiskNumber);\n\t\tsetUint32(endOfdirectoryView, 20, diskNumber);\n\t\tsetBigUint64(endOfdirectoryView, 24, BigInt(filesLength));\n\t\tsetBigUint64(endOfdirectoryView, 32, BigInt(filesLength));\n\t\tsetBigUint64(endOfdirectoryView, 40, BigInt(directoryDataLength));\n\t\tsetBigUint64(endOfdirectoryView, 48, BigInt(directoryOffset));\n\t\tsetUint32(endOfdirectoryView, 56, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE);\n\t\tsetBigUint64(endOfdirectoryView, 64, BigInt(directoryOffset) + BigInt(directoryDataLength));\n\t\tsetUint32(endOfdirectoryView, 72, lastDiskNumber + 1);\n\t\tconst supportZip64SplitFile = getOptionValue(zipWriter, options, \"supportZip64SplitFile\", true);\n\t\tif (supportZip64SplitFile) {\n\t\t\tlastDiskNumber = MAX_16_BITS;\n\t\t\tdiskNumber = MAX_16_BITS;\n\t\t}\n\t\tfilesLength = MAX_16_BITS;\n\t\tdirectoryOffset = MAX_32_BITS;\n\t\tdirectoryDataLength = MAX_32_BITS;\n\t\toffset += ZIP64_END_OF_CENTRAL_DIR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH;\n\t}\n\tsetUint32(endOfdirectoryView, offset, END_OF_CENTRAL_DIR_SIGNATURE);\n\tsetUint16(endOfdirectoryView, offset + 4, lastDiskNumber);\n\tsetUint16(endOfdirectoryView, offset + 6, diskNumber);\n\tsetUint16(endOfdirectoryView, offset + 8, filesLength);\n\tsetUint16(endOfdirectoryView, offset + 10, filesLength);\n\tsetUint32(endOfdirectoryView, offset + 12, directoryDataLength);\n\tsetUint32(endOfdirectoryView, offset + 16, directoryOffset);\n\tconst commentLength = getLength(comment);\n\tif (commentLength) {\n\t\tif (commentLength <= MAX_16_BITS) {\n\t\t\tsetUint16(endOfdirectoryView, offset + 20, commentLength);\n\t\t} else {\n\t\t\tthrow new Error(ERR_INVALID_COMMENT);\n\t\t}\n\t}\n\tawait writeData(writable, endOfdirectoryArray);\n\tif (commentLength) {\n\t\tawait writeData(writable, comment);\n\t}\n}\n\nasync function writeData(writable, array) {\n\tconst streamWriter = writable.getWriter();\n\ttry {\n\t\tawait streamWriter.ready;\n\t\twritable.size += getLength(array);\n\t\tawait streamWriter.write(array);\n\t} finally {\n\t\tstreamWriter.releaseLock();\n\t}\n}\n\nfunction getTimeNTFS(date) {\n\tif (date) {\n\t\treturn ((BigInt(date.getTime()) + BigInt(11644473600000)) * BigInt(10000));\n\t}\n}\n\nfunction getOptionValue(zipWriter, options, name, defaultValue) {\n\tconst result = options[name] === UNDEFINED_VALUE ? zipWriter.options[name] : options[name];\n\treturn result === UNDEFINED_VALUE ? defaultValue : result;\n}\n\nfunction getMaximumCompressedSize(uncompressedSize) {\n\treturn uncompressedSize + (5 * (Math.floor(uncompressedSize / 16383) + 1));\n}\n\nfunction setUint8(view, offset, value) {\n\tview.setUint8(offset, value);\n}\n\nfunction setUint16(view, offset, value) {\n\tview.setUint16(offset, value, true);\n}\n\nfunction setUint32(view, offset, value) {\n\tview.setUint32(offset, value, true);\n}\n\nfunction setBigUint64(view, offset, value) {\n\tview.setBigUint64(offset, value, true);\n}\n\nfunction arraySet(array, typedArray, offset) {\n\tarray.set(typedArray, offset);\n}\n\nfunction getDataView(array) {\n\treturn new DataView(array.buffer);\n}\n\nfunction getLength(...arrayLikes) {\n\tlet result = 0;\n\tarrayLikes.forEach(arrayLike => arrayLike && (result += arrayLike.length));\n\treturn result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}