{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { fromValues as e } from \"../../../../../../core/libs/gl-matrix-2/factories/vec2f64.js\";\nimport { PositionAttribute as o } from \"./PositionAttribute.glsl.js\";\nimport { Float2PassUniform as i } from \"../../shaderModules/Float2PassUniform.js\";\nimport { Float3PassUniform as r } from \"../../shaderModules/Float3PassUniform.js\";\nimport { Float4sPassUniform as t } from \"../../shaderModules/Float4sPassUniform.js\";\nimport { FloatsPassUniform as a } from \"../../shaderModules/FloatsPassUniform.js\";\nimport { glsl as l } from \"../../shaderModules/glsl.js\";\nimport { VertexAttribute as v } from \"../../../lib/VertexAttribute.js\";\nimport { vvColorNumber as s, VisualVariablePassParameters as c } from \"../../../materials/VisualVariablePassParameters.js\";\nconst p = 8;\nfunction f(e, c) {\n  const f = v.FEATUREVALUE;\n  e.attributes.add(f, \"vec4\");\n  const n = e.vertex;\n  n.code.add(l`\n  bool isCapVertex() {\n    return ${f}.w == 1.0;\n  }\n  `), n.uniforms.add(new i(\"size\", e => e.size)), c.vvSize ? (n.uniforms.add(new r(\"vvSizeMinSize\", e => e.vvSize.minSize), new r(\"vvSizeMaxSize\", e => e.vvSize.maxSize), new r(\"vvSizeOffset\", e => e.vvSize.offset), new r(\"vvSizeFactor\", e => e.vvSize.factor)), n.code.add(l`\n    vec2 getSize() {\n      return size * clamp(vvSizeOffset + ${f}.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).xz;\n    }\n    `)) : n.code.add(l`vec2 getSize(){\nreturn size;\n}`), c.vvOpacity ? (n.constants.add(\"vvOpacityNumber\", \"int\", p), n.uniforms.add(new a(\"vvOpacityValues\", e => e.vvOpacity.values, p), new a(\"vvOpacityOpacities\", e => e.vvOpacity.opacityValues, p)), n.code.add(l`\n    vec4 applyOpacity(vec4 color) {\n      float value = ${f}.z;\n      if (value <= vvOpacityValues[0]) {\n        return vec4( color.xyz, vvOpacityOpacities[0]);\n      }\n\n      for (int i = 1; i < vvOpacityNumber; ++i) {\n        if (vvOpacityValues[i] >= value) {\n          float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);\n          return vec4( color.xyz, mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f));\n        }\n      }\n\n      return vec4( color.xyz, vvOpacityOpacities[vvOpacityNumber - 1]);\n    }\n    `)) : n.code.add(l`vec4 applyOpacity(vec4 color){\nreturn color;\n}`), c.vvColor ? (n.constants.add(\"vvColorNumber\", \"int\", s), n.uniforms.add(new a(\"vvColorValues\", e => e.vvColor.values, s), new t(\"vvColorColors\", e => e.vvColor.colors, s)), n.code.add(l`\n    vec4 getColor() {\n      float value = ${f}.y;\n      if (value <= vvColorValues[0]) {\n        return applyOpacity(vvColorColors[0]);\n      }\n\n      for (int i = 1; i < vvColorNumber; ++i) {\n        if (vvColorValues[i] >= value) {\n          float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);\n          return applyOpacity(mix(vvColorColors[i-1], vvColorColors[i], f));\n        }\n      }\n\n      return applyOpacity(vvColorColors[vvColorNumber - 1]);\n    }\n    `)) : n.code.add(l`vec4 getColor(){\nreturn applyOpacity(vec4(1, 1, 1, 1));\n}`), e.include(o), e.attributes.add(v.PROFILERIGHT, \"vec4\"), e.attributes.add(v.PROFILEUP, \"vec4\"), e.attributes.add(v.PROFILEVERTEXANDNORMAL, \"vec4\"), n.code.add(l`vec3 calculateVPos() {\nvec2 size = getSize();\nvec3 origin = position;\nvec3 right = profileRight.xyz;\nvec3 up = profileUp.xyz;\nvec3 forward = cross(up, right);\nvec2 profileVertex = profileVertexAndNormal.xy * size;\nvec2 profileNormal = profileVertexAndNormal.zw;\nfloat positionOffsetAlongProfilePlaneNormal = 0.0;\nfloat normalOffsetAlongProfilePlaneNormal = 0.0;`), n.code.add(l`if(!isCapVertex()) {\nvec2 rotationRight = vec2(profileRight.w, profileUp.w);\nfloat maxDistance = length(rotationRight);`), n.code.add(l`rotationRight = maxDistance > 0.0 ? normalize(rotationRight) : vec2(0, 0);\nfloat rx = dot(profileVertex, rotationRight);\nif (abs(rx) > maxDistance) {\nvec2 rotationUp = vec2(-rotationRight.y, rotationRight.x);\nfloat ry = dot(profileVertex, rotationUp);\nprofileVertex = rotationRight * maxDistance * sign(rx) + rotationUp * ry;\n}\n}else{\npositionOffsetAlongProfilePlaneNormal = profileRight.w * size[0];\nnormalOffsetAlongProfilePlaneNormal = profileUp.w;\n}\nvec3 offset = right * profileVertex.x + up * profileVertex.y + forward * positionOffsetAlongProfilePlaneNormal;\nreturn origin + offset;\n}`), n.code.add(l`vec3 localNormal() {\nvec3 right = profileRight.xyz;\nvec3 up = profileUp.xyz;\nvec3 forward = cross(up, right);\nvec2 profileNormal = profileVertexAndNormal.zw;\nvec3 normal = right * profileNormal.x + up * profileNormal.y;\nif(isCapVertex()) {\nnormal += forward * profileUp.w;\n}\nreturn normal;\n}`);\n}\nclass n extends c {\n  constructor() {\n    super(...arguments), this.size = e(1, 1);\n  }\n}\nexport { f as PathVertexPosition, n as PathVertexPositionPassParameters };","map":{"version":3,"names":["fromValues","e","PositionAttribute","o","Float2PassUniform","i","Float3PassUniform","r","Float4sPassUniform","t","FloatsPassUniform","a","glsl","l","VertexAttribute","v","vvColorNumber","s","VisualVariablePassParameters","c","p","f","FEATUREVALUE","attributes","add","n","vertex","code","uniforms","size","vvSize","minSize","maxSize","offset","factor","vvOpacity","constants","values","opacityValues","vvColor","colors","include","PROFILERIGHT","PROFILEUP","PROFILEVERTEXANDNORMAL","constructor","arguments","PathVertexPosition","PathVertexPositionPassParameters"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PathVertexPosition.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{fromValues as e}from\"../../../../../../core/libs/gl-matrix-2/factories/vec2f64.js\";import{PositionAttribute as o}from\"./PositionAttribute.glsl.js\";import{Float2PassUniform as i}from\"../../shaderModules/Float2PassUniform.js\";import{Float3PassUniform as r}from\"../../shaderModules/Float3PassUniform.js\";import{Float4sPassUniform as t}from\"../../shaderModules/Float4sPassUniform.js\";import{FloatsPassUniform as a}from\"../../shaderModules/FloatsPassUniform.js\";import{glsl as l}from\"../../shaderModules/glsl.js\";import{VertexAttribute as v}from\"../../../lib/VertexAttribute.js\";import{vvColorNumber as s,VisualVariablePassParameters as c}from\"../../../materials/VisualVariablePassParameters.js\";const p=8;function f(e,c){const f=v.FEATUREVALUE;e.attributes.add(f,\"vec4\");const n=e.vertex;n.code.add(l`\n  bool isCapVertex() {\n    return ${f}.w == 1.0;\n  }\n  `),n.uniforms.add(new i(\"size\",(e=>e.size))),c.vvSize?(n.uniforms.add(new r(\"vvSizeMinSize\",(e=>e.vvSize.minSize)),new r(\"vvSizeMaxSize\",(e=>e.vvSize.maxSize)),new r(\"vvSizeOffset\",(e=>e.vvSize.offset)),new r(\"vvSizeFactor\",(e=>e.vvSize.factor))),n.code.add(l`\n    vec2 getSize() {\n      return size * clamp(vvSizeOffset + ${f}.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).xz;\n    }\n    `)):n.code.add(l`vec2 getSize(){\nreturn size;\n}`),c.vvOpacity?(n.constants.add(\"vvOpacityNumber\",\"int\",p),n.uniforms.add(new a(\"vvOpacityValues\",(e=>e.vvOpacity.values),p),new a(\"vvOpacityOpacities\",(e=>e.vvOpacity.opacityValues),p)),n.code.add(l`\n    vec4 applyOpacity(vec4 color) {\n      float value = ${f}.z;\n      if (value <= vvOpacityValues[0]) {\n        return vec4( color.xyz, vvOpacityOpacities[0]);\n      }\n\n      for (int i = 1; i < vvOpacityNumber; ++i) {\n        if (vvOpacityValues[i] >= value) {\n          float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);\n          return vec4( color.xyz, mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f));\n        }\n      }\n\n      return vec4( color.xyz, vvOpacityOpacities[vvOpacityNumber - 1]);\n    }\n    `)):n.code.add(l`vec4 applyOpacity(vec4 color){\nreturn color;\n}`),c.vvColor?(n.constants.add(\"vvColorNumber\",\"int\",s),n.uniforms.add(new a(\"vvColorValues\",(e=>e.vvColor.values),s),new t(\"vvColorColors\",(e=>e.vvColor.colors),s)),n.code.add(l`\n    vec4 getColor() {\n      float value = ${f}.y;\n      if (value <= vvColorValues[0]) {\n        return applyOpacity(vvColorColors[0]);\n      }\n\n      for (int i = 1; i < vvColorNumber; ++i) {\n        if (vvColorValues[i] >= value) {\n          float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);\n          return applyOpacity(mix(vvColorColors[i-1], vvColorColors[i], f));\n        }\n      }\n\n      return applyOpacity(vvColorColors[vvColorNumber - 1]);\n    }\n    `)):n.code.add(l`vec4 getColor(){\nreturn applyOpacity(vec4(1, 1, 1, 1));\n}`),e.include(o),e.attributes.add(v.PROFILERIGHT,\"vec4\"),e.attributes.add(v.PROFILEUP,\"vec4\"),e.attributes.add(v.PROFILEVERTEXANDNORMAL,\"vec4\"),n.code.add(l`vec3 calculateVPos() {\nvec2 size = getSize();\nvec3 origin = position;\nvec3 right = profileRight.xyz;\nvec3 up = profileUp.xyz;\nvec3 forward = cross(up, right);\nvec2 profileVertex = profileVertexAndNormal.xy * size;\nvec2 profileNormal = profileVertexAndNormal.zw;\nfloat positionOffsetAlongProfilePlaneNormal = 0.0;\nfloat normalOffsetAlongProfilePlaneNormal = 0.0;`),n.code.add(l`if(!isCapVertex()) {\nvec2 rotationRight = vec2(profileRight.w, profileUp.w);\nfloat maxDistance = length(rotationRight);`),n.code.add(l`rotationRight = maxDistance > 0.0 ? normalize(rotationRight) : vec2(0, 0);\nfloat rx = dot(profileVertex, rotationRight);\nif (abs(rx) > maxDistance) {\nvec2 rotationUp = vec2(-rotationRight.y, rotationRight.x);\nfloat ry = dot(profileVertex, rotationUp);\nprofileVertex = rotationRight * maxDistance * sign(rx) + rotationUp * ry;\n}\n}else{\npositionOffsetAlongProfilePlaneNormal = profileRight.w * size[0];\nnormalOffsetAlongProfilePlaneNormal = profileUp.w;\n}\nvec3 offset = right * profileVertex.x + up * profileVertex.y + forward * positionOffsetAlongProfilePlaneNormal;\nreturn origin + offset;\n}`),n.code.add(l`vec3 localNormal() {\nvec3 right = profileRight.xyz;\nvec3 up = profileUp.xyz;\nvec3 forward = cross(up, right);\nvec2 profileNormal = profileVertexAndNormal.zw;\nvec3 normal = right * profileNormal.x + up * profileNormal.y;\nif(isCapVertex()) {\nnormal += forward * profileUp.w;\n}\nreturn normal;\n}`)}class n extends c{constructor(){super(...arguments),this.size=e(1,1)}}export{f as PathVertexPosition,n as PathVertexPositionPassParameters};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}