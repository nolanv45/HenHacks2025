{"ast":null,"code":"/*\n Copyright (c) 2022 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* global Blob, atob, btoa, XMLHttpRequest, URL, fetch, ReadableStream, WritableStream, FileReader, TransformStream, Response */\n// deno-lint-ignore-file no-this-alias\n\nimport { UNDEFINED_VALUE, FUNCTION_TYPE, END_OF_CENTRAL_DIR_LENGTH } from \"./constants.js\";\nimport { getConfiguration } from \"./configuration.js\";\nconst ERR_HTTP_STATUS = \"HTTP error \";\nconst ERR_HTTP_RANGE = \"HTTP Range not supported\";\nconst ERR_ITERATOR_COMPLETED_TOO_SOON = \"Writer iterator completed too soon\";\nconst CONTENT_TYPE_TEXT_PLAIN = \"text/plain\";\nconst HTTP_HEADER_CONTENT_LENGTH = \"Content-Length\";\nconst HTTP_HEADER_CONTENT_RANGE = \"Content-Range\";\nconst HTTP_HEADER_ACCEPT_RANGES = \"Accept-Ranges\";\nconst HTTP_HEADER_RANGE = \"Range\";\nconst HTTP_HEADER_CONTENT_TYPE = \"Content-Type\";\nconst HTTP_METHOD_HEAD = \"HEAD\";\nconst HTTP_METHOD_GET = \"GET\";\nconst HTTP_RANGE_UNIT = \"bytes\";\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\nconst PROPERTY_NAME_WRITABLE = \"writable\";\nclass Stream {\n  constructor() {\n    this.size = 0;\n  }\n  init() {\n    this.initialized = true;\n  }\n}\nclass Reader extends Stream {\n  get readable() {\n    const reader = this;\n    const {\n      chunkSize = DEFAULT_CHUNK_SIZE\n    } = reader;\n    const readable = new ReadableStream({\n      start() {\n        this.chunkOffset = 0;\n      },\n      async pull(controller) {\n        const {\n          offset = 0,\n          size,\n          diskNumberStart\n        } = readable;\n        const {\n          chunkOffset\n        } = this;\n        controller.enqueue(await readUint8Array(reader, offset + chunkOffset, Math.min(chunkSize, size - chunkOffset), diskNumberStart));\n        if (chunkOffset + chunkSize > size) {\n          controller.close();\n        } else {\n          this.chunkOffset += chunkSize;\n        }\n      }\n    });\n    return readable;\n  }\n}\nclass Writer extends Stream {\n  constructor() {\n    super();\n    const writer = this;\n    const writable = new WritableStream({\n      write(chunk) {\n        return writer.writeUint8Array(chunk);\n      }\n    });\n    Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {\n      get() {\n        return writable;\n      }\n    });\n  }\n  writeUint8Array() {\n    // abstract\n  }\n}\nclass Data64URIReader extends Reader {\n  constructor(dataURI) {\n    super();\n    let dataEnd = dataURI.length;\n    while (dataURI.charAt(dataEnd - 1) == \"=\") {\n      dataEnd--;\n    }\n    const dataStart = dataURI.indexOf(\",\") + 1;\n    Object.assign(this, {\n      dataURI,\n      dataStart,\n      size: Math.floor((dataEnd - dataStart) * 0.75)\n    });\n  }\n  readUint8Array(offset, length) {\n    const {\n      dataStart,\n      dataURI\n    } = this;\n    const dataArray = new Uint8Array(length);\n    const start = Math.floor(offset / 3) * 4;\n    const bytes = atob(dataURI.substring(start + dataStart, Math.ceil((offset + length) / 3) * 4 + dataStart));\n    const delta = offset - Math.floor(start / 4) * 3;\n    for (let indexByte = delta; indexByte < delta + length; indexByte++) {\n      dataArray[indexByte - delta] = bytes.charCodeAt(indexByte);\n    }\n    return dataArray;\n  }\n}\nclass Data64URIWriter extends Writer {\n  constructor(contentType) {\n    super();\n    Object.assign(this, {\n      data: \"data:\" + (contentType || \"\") + \";base64,\",\n      pending: []\n    });\n  }\n  writeUint8Array(array) {\n    const writer = this;\n    let indexArray = 0;\n    let dataString = writer.pending;\n    const delta = writer.pending.length;\n    writer.pending = \"\";\n    for (indexArray = 0; indexArray < Math.floor((delta + array.length) / 3) * 3 - delta; indexArray++) {\n      dataString += String.fromCharCode(array[indexArray]);\n    }\n    for (; indexArray < array.length; indexArray++) {\n      writer.pending += String.fromCharCode(array[indexArray]);\n    }\n    if (dataString.length > 2) {\n      writer.data += btoa(dataString);\n    } else {\n      writer.pending = dataString;\n    }\n  }\n  getData() {\n    return this.data + btoa(this.pending);\n  }\n}\nclass BlobReader extends Reader {\n  constructor(blob) {\n    super();\n    Object.assign(this, {\n      blob,\n      size: blob.size\n    });\n  }\n  async readUint8Array(offset, length) {\n    const reader = this;\n    const offsetEnd = offset + length;\n    const blob = offset || offsetEnd < reader.size ? reader.blob.slice(offset, offsetEnd) : reader.blob;\n    let arrayBuffer = await blob.arrayBuffer();\n    if (arrayBuffer.byteLength > length) {\n      arrayBuffer = arrayBuffer.slice(offset, offsetEnd);\n    }\n    return new Uint8Array(arrayBuffer);\n  }\n}\nclass BlobWriter extends Stream {\n  constructor(contentType) {\n    super();\n    const writer = this;\n    const transformStream = new TransformStream();\n    const headers = [];\n    if (contentType) {\n      headers.push([HTTP_HEADER_CONTENT_TYPE, contentType]);\n    }\n    Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {\n      get() {\n        return transformStream.writable;\n      }\n    });\n    writer.blob = new Response(transformStream.readable, {\n      headers\n    }).blob();\n  }\n  getData() {\n    return this.blob;\n  }\n}\nclass TextReader extends BlobReader {\n  constructor(text) {\n    super(new Blob([text], {\n      type: CONTENT_TYPE_TEXT_PLAIN\n    }));\n  }\n}\nclass TextWriter extends BlobWriter {\n  constructor(encoding) {\n    super(encoding);\n    Object.assign(this, {\n      encoding,\n      utf8: !encoding || encoding.toLowerCase() == \"utf-8\"\n    });\n  }\n  async getData() {\n    const {\n      encoding,\n      utf8\n    } = this;\n    const blob = await super.getData();\n    if (blob.text && utf8) {\n      return blob.text();\n    } else {\n      const reader = new FileReader();\n      return new Promise((resolve, reject) => {\n        Object.assign(reader, {\n          onload: ({\n            target\n          }) => resolve(target.result),\n          onerror: () => reject(reader.error)\n        });\n        reader.readAsText(blob, encoding);\n      });\n    }\n  }\n}\nclass FetchReader extends Reader {\n  constructor(url, options) {\n    super();\n    createHttpReader(this, url, options);\n  }\n  async init() {\n    await initHttpReader(this, sendFetchRequest, getFetchRequestData);\n    super.init();\n  }\n  readUint8Array(index, length) {\n    return readUint8ArrayHttpReader(this, index, length, sendFetchRequest, getFetchRequestData);\n  }\n}\nclass XHRReader extends Reader {\n  constructor(url, options) {\n    super();\n    createHttpReader(this, url, options);\n  }\n  async init() {\n    await initHttpReader(this, sendXMLHttpRequest, getXMLHttpRequestData);\n    super.init();\n  }\n  readUint8Array(index, length) {\n    return readUint8ArrayHttpReader(this, index, length, sendXMLHttpRequest, getXMLHttpRequestData);\n  }\n}\nfunction createHttpReader(httpReader, url, options) {\n  const {\n    preventHeadRequest,\n    useRangeHeader,\n    forceRangeRequests,\n    combineSizeEocd\n  } = options;\n  options = Object.assign({}, options);\n  delete options.preventHeadRequest;\n  delete options.useRangeHeader;\n  delete options.forceRangeRequests;\n  delete options.combineSizeEocd;\n  delete options.useXHR;\n  Object.assign(httpReader, {\n    url,\n    options,\n    preventHeadRequest,\n    useRangeHeader,\n    forceRangeRequests,\n    combineSizeEocd\n  });\n}\nasync function initHttpReader(httpReader, sendRequest, getRequestData) {\n  const {\n    url,\n    preventHeadRequest,\n    useRangeHeader,\n    forceRangeRequests,\n    combineSizeEocd\n  } = httpReader;\n  if (isHttpFamily(url) && (useRangeHeader || forceRangeRequests) && (typeof preventHeadRequest == \"undefined\" || preventHeadRequest)) {\n    const response = await sendRequest(HTTP_METHOD_GET, httpReader, getRangeHeaders(httpReader, combineSizeEocd ? -END_OF_CENTRAL_DIR_LENGTH : undefined));\n    if (!forceRangeRequests && response.headers.get(HTTP_HEADER_ACCEPT_RANGES) != HTTP_RANGE_UNIT) {\n      throw new Error(ERR_HTTP_RANGE);\n    } else {\n      if (combineSizeEocd) {\n        httpReader.eocdCache = new Uint8Array(await response.arrayBuffer());\n      }\n      let contentSize;\n      const contentRangeHeader = response.headers.get(HTTP_HEADER_CONTENT_RANGE);\n      if (contentRangeHeader) {\n        const splitHeader = contentRangeHeader.trim().split(/\\s*\\/\\s*/);\n        if (splitHeader.length) {\n          const headerValue = splitHeader[1];\n          if (headerValue && headerValue != \"*\") {\n            contentSize = Number(headerValue);\n          }\n        }\n      }\n      if (contentSize === UNDEFINED_VALUE) {\n        await getContentLength(httpReader, sendRequest, getRequestData);\n      } else {\n        httpReader.size = contentSize;\n      }\n    }\n  } else {\n    await getContentLength(httpReader, sendRequest, getRequestData);\n  }\n}\nasync function readUint8ArrayHttpReader(httpReader, index, length, sendRequest, getRequestData) {\n  const {\n    useRangeHeader,\n    forceRangeRequests,\n    eocdCache,\n    size,\n    options\n  } = httpReader;\n  if (useRangeHeader || forceRangeRequests) {\n    if (eocdCache && index == size - END_OF_CENTRAL_DIR_LENGTH && length == END_OF_CENTRAL_DIR_LENGTH) {\n      return eocdCache;\n    }\n    const response = await sendRequest(HTTP_METHOD_GET, httpReader, getRangeHeaders(httpReader, index, length));\n    if (response.status != 206) {\n      throw new Error(ERR_HTTP_RANGE);\n    }\n    return new Uint8Array(await response.arrayBuffer());\n  } else {\n    const {\n      data\n    } = httpReader;\n    if (!data) {\n      await getRequestData(httpReader, options);\n    }\n    return new Uint8Array(httpReader.data.subarray(index, index + length));\n  }\n}\nfunction getRangeHeaders(httpReader, index = 0, length = 1) {\n  return Object.assign({}, getHeaders(httpReader), {\n    [HTTP_HEADER_RANGE]: HTTP_RANGE_UNIT + \"=\" + (index < 0 ? index : index + \"-\" + (index + length - 1))\n  });\n}\nfunction getHeaders({\n  options\n}) {\n  const {\n    headers\n  } = options;\n  if (headers) {\n    if (Symbol.iterator in headers) {\n      return Object.fromEntries(headers);\n    } else {\n      return headers;\n    }\n  }\n}\nasync function getFetchRequestData(httpReader) {\n  await getRequestData(httpReader, sendFetchRequest);\n}\nasync function getXMLHttpRequestData(httpReader) {\n  await getRequestData(httpReader, sendXMLHttpRequest);\n}\nasync function getRequestData(httpReader, sendRequest) {\n  const response = await sendRequest(HTTP_METHOD_GET, httpReader, getHeaders(httpReader));\n  httpReader.data = new Uint8Array(await response.arrayBuffer());\n  if (!httpReader.size) {\n    httpReader.size = httpReader.data.length;\n  }\n}\nasync function getContentLength(httpReader, sendRequest, getRequestData) {\n  if (httpReader.preventHeadRequest) {\n    await getRequestData(httpReader, httpReader.options);\n  } else {\n    const response = await sendRequest(HTTP_METHOD_HEAD, httpReader, getHeaders(httpReader));\n    const contentLength = response.headers.get(HTTP_HEADER_CONTENT_LENGTH);\n    if (contentLength) {\n      httpReader.size = Number(contentLength);\n    } else {\n      await getRequestData(httpReader, httpReader.options);\n    }\n  }\n}\nasync function sendFetchRequest(method, {\n  options,\n  url\n}, headers) {\n  const response = await fetch(url, Object.assign({}, options, {\n    method,\n    headers\n  }));\n  if (response.status < 400) {\n    return response;\n  } else {\n    throw response.status == 416 ? new Error(ERR_HTTP_RANGE) : new Error(ERR_HTTP_STATUS + (response.statusText || response.status));\n  }\n}\nfunction sendXMLHttpRequest(method, {\n  url\n}, headers) {\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest();\n    request.addEventListener(\"load\", () => {\n      if (request.status < 400) {\n        const headers = [];\n        request.getAllResponseHeaders().trim().split(/[\\r\\n]+/).forEach(header => {\n          const splitHeader = header.trim().split(/\\s*:\\s*/);\n          splitHeader[0] = splitHeader[0].trim().replace(/^[a-z]|-[a-z]/g, value => value.toUpperCase());\n          headers.push(splitHeader);\n        });\n        resolve({\n          status: request.status,\n          arrayBuffer: () => request.response,\n          headers: new Map(headers)\n        });\n      } else {\n        reject(request.status == 416 ? new Error(ERR_HTTP_RANGE) : new Error(ERR_HTTP_STATUS + (request.statusText || request.status)));\n      }\n    }, false);\n    request.addEventListener(\"error\", event => reject(event.detail ? event.detail.error : new Error(\"Network error\")), false);\n    request.open(method, url);\n    if (headers) {\n      for (const entry of Object.entries(headers)) {\n        request.setRequestHeader(entry[0], entry[1]);\n      }\n    }\n    request.responseType = \"arraybuffer\";\n    request.send();\n  });\n}\nclass HttpReader extends Reader {\n  constructor(url, options = {}) {\n    super();\n    Object.assign(this, {\n      url,\n      reader: options.useXHR ? new XHRReader(url, options) : new FetchReader(url, options)\n    });\n  }\n  set size(value) {\n    // ignored\n  }\n  get size() {\n    return this.reader.size;\n  }\n  async init() {\n    await this.reader.init();\n    super.init();\n  }\n  readUint8Array(index, length) {\n    return this.reader.readUint8Array(index, length);\n  }\n}\nclass HttpRangeReader extends HttpReader {\n  constructor(url, options = {}) {\n    options.useRangeHeader = true;\n    super(url, options);\n  }\n}\nclass Uint8ArrayReader extends Reader {\n  constructor(array) {\n    super();\n    Object.assign(this, {\n      array,\n      size: array.length\n    });\n  }\n  readUint8Array(index, length) {\n    return this.array.slice(index, index + length);\n  }\n}\nclass Uint8ArrayWriter extends Writer {\n  init(initSize = 0) {\n    Object.assign(this, {\n      offset: 0,\n      array: new Uint8Array(initSize)\n    });\n    super.init();\n  }\n  writeUint8Array(array) {\n    const writer = this;\n    if (writer.offset + array.length > writer.array.length) {\n      const previousArray = writer.array;\n      writer.array = new Uint8Array(previousArray.length + array.length);\n      writer.array.set(previousArray);\n    }\n    writer.array.set(array, writer.offset);\n    writer.offset += array.length;\n  }\n  getData() {\n    return this.array;\n  }\n}\nclass SplitDataReader extends Reader {\n  constructor(readers) {\n    super();\n    this.readers = readers;\n  }\n  async init() {\n    const reader = this;\n    const {\n      readers\n    } = reader;\n    reader.lastDiskNumber = 0;\n    reader.lastDiskOffset = 0;\n    await Promise.all(readers.map(async (diskReader, indexDiskReader) => {\n      await diskReader.init();\n      if (indexDiskReader != readers.length - 1) {\n        reader.lastDiskOffset += diskReader.size;\n      }\n      reader.size += diskReader.size;\n    }));\n    super.init();\n  }\n  async readUint8Array(offset, length, diskNumber = 0) {\n    const reader = this;\n    const {\n      readers\n    } = this;\n    let result;\n    let currentDiskNumber = diskNumber;\n    if (currentDiskNumber == -1) {\n      currentDiskNumber = readers.length - 1;\n    }\n    let currentReaderOffset = offset;\n    while (currentReaderOffset >= readers[currentDiskNumber].size) {\n      currentReaderOffset -= readers[currentDiskNumber].size;\n      currentDiskNumber++;\n    }\n    const currentReader = readers[currentDiskNumber];\n    const currentReaderSize = currentReader.size;\n    if (currentReaderOffset + length <= currentReaderSize) {\n      result = await readUint8Array(currentReader, currentReaderOffset, length);\n    } else {\n      const chunkLength = currentReaderSize - currentReaderOffset;\n      result = new Uint8Array(length);\n      result.set(await readUint8Array(currentReader, currentReaderOffset, chunkLength));\n      result.set(await reader.readUint8Array(offset + chunkLength, length - chunkLength, diskNumber), chunkLength);\n    }\n    reader.lastDiskNumber = Math.max(currentDiskNumber, reader.lastDiskNumber);\n    return result;\n  }\n}\nclass SplitDataWriter extends Stream {\n  constructor(writerGenerator, maxSize = 4294967295) {\n    super();\n    const writer = this;\n    Object.assign(writer, {\n      diskNumber: 0,\n      diskOffset: 0,\n      size: 0,\n      maxSize,\n      availableSize: maxSize\n    });\n    let diskSourceWriter, diskWritable, diskWriter;\n    const writable = new WritableStream({\n      async write(chunk) {\n        const {\n          availableSize\n        } = writer;\n        if (!diskWriter) {\n          const {\n            value,\n            done\n          } = await writerGenerator.next();\n          if (done && !value) {\n            throw new Error(ERR_ITERATOR_COMPLETED_TOO_SOON);\n          } else {\n            diskSourceWriter = value;\n            diskSourceWriter.size = 0;\n            if (diskSourceWriter.maxSize) {\n              writer.maxSize = diskSourceWriter.maxSize;\n            }\n            writer.availableSize = writer.maxSize;\n            await initStream(diskSourceWriter);\n            diskWritable = value.writable;\n            diskWriter = diskWritable.getWriter();\n          }\n          await this.write(chunk);\n        } else if (chunk.length >= availableSize) {\n          await writeChunk(chunk.slice(0, availableSize));\n          await closeDisk();\n          writer.diskOffset += diskSourceWriter.size;\n          writer.diskNumber++;\n          diskWriter = null;\n          await this.write(chunk.slice(availableSize));\n        } else {\n          await writeChunk(chunk);\n        }\n      },\n      async close() {\n        await diskWriter.ready;\n        await closeDisk();\n      }\n    });\n    Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {\n      get() {\n        return writable;\n      }\n    });\n    async function writeChunk(chunk) {\n      const chunkLength = chunk.length;\n      if (chunkLength) {\n        await diskWriter.ready;\n        await diskWriter.write(chunk);\n        diskSourceWriter.size += chunkLength;\n        writer.size += chunkLength;\n        writer.availableSize -= chunkLength;\n      }\n    }\n    async function closeDisk() {\n      diskWritable.size = diskSourceWriter.size;\n      await diskWriter.close();\n    }\n  }\n}\nfunction isHttpFamily(url) {\n  const {\n    baseURL\n  } = getConfiguration();\n  const {\n    protocol\n  } = new URL(url, baseURL);\n  return protocol == \"http:\" || protocol == \"https:\";\n}\nasync function initStream(stream, initSize) {\n  if (stream.init && !stream.initialized) {\n    await stream.init(initSize);\n  } else {\n    return Promise.resolve();\n  }\n}\nfunction initReader(reader) {\n  if (Array.isArray(reader)) {\n    reader = new SplitDataReader(reader);\n  }\n  if (reader instanceof ReadableStream) {\n    reader = {\n      readable: reader\n    };\n  }\n  return reader;\n}\nfunction initWriter(writer) {\n  if (writer.writable === UNDEFINED_VALUE && typeof writer.next == FUNCTION_TYPE) {\n    writer = new SplitDataWriter(writer);\n  }\n  if (writer instanceof WritableStream) {\n    writer = {\n      writable: writer\n    };\n  }\n  const {\n    writable\n  } = writer;\n  if (writable.size === UNDEFINED_VALUE) {\n    writable.size = 0;\n  }\n  if (!(writer instanceof SplitDataWriter)) {\n    Object.assign(writer, {\n      diskNumber: 0,\n      diskOffset: 0,\n      availableSize: Infinity,\n      maxSize: Infinity\n    });\n  }\n  return writer;\n}\nfunction readUint8Array(reader, offset, size, diskNumber) {\n  return reader.readUint8Array(offset, size, diskNumber);\n}\nconst SplitZipReader = SplitDataReader;\nconst SplitZipWriter = SplitDataWriter;\nexport { initStream, initReader, initWriter, readUint8Array, Reader, Writer, TextReader, TextWriter, Data64URIReader, Data64URIWriter, BlobReader, BlobWriter, Uint8ArrayReader, Uint8ArrayWriter, HttpReader, HttpRangeReader, SplitZipReader, SplitZipWriter, SplitDataReader, SplitDataWriter, ERR_HTTP_RANGE, ERR_ITERATOR_COMPLETED_TOO_SOON };","map":{"version":3,"names":["UNDEFINED_VALUE","FUNCTION_TYPE","END_OF_CENTRAL_DIR_LENGTH","getConfiguration","ERR_HTTP_STATUS","ERR_HTTP_RANGE","ERR_ITERATOR_COMPLETED_TOO_SOON","CONTENT_TYPE_TEXT_PLAIN","HTTP_HEADER_CONTENT_LENGTH","HTTP_HEADER_CONTENT_RANGE","HTTP_HEADER_ACCEPT_RANGES","HTTP_HEADER_RANGE","HTTP_HEADER_CONTENT_TYPE","HTTP_METHOD_HEAD","HTTP_METHOD_GET","HTTP_RANGE_UNIT","DEFAULT_CHUNK_SIZE","PROPERTY_NAME_WRITABLE","Stream","constructor","size","init","initialized","Reader","readable","reader","chunkSize","ReadableStream","start","chunkOffset","pull","controller","offset","diskNumberStart","enqueue","readUint8Array","Math","min","close","Writer","writer","writable","WritableStream","write","chunk","writeUint8Array","Object","defineProperty","get","Data64URIReader","dataURI","dataEnd","length","charAt","dataStart","indexOf","assign","floor","dataArray","Uint8Array","bytes","atob","substring","ceil","delta","indexByte","charCodeAt","Data64URIWriter","contentType","data","pending","array","indexArray","dataString","String","fromCharCode","btoa","getData","BlobReader","blob","offsetEnd","slice","arrayBuffer","byteLength","BlobWriter","transformStream","TransformStream","headers","push","Response","TextReader","text","Blob","type","TextWriter","encoding","utf8","toLowerCase","FileReader","Promise","resolve","reject","onload","target","result","onerror","error","readAsText","FetchReader","url","options","createHttpReader","initHttpReader","sendFetchRequest","getFetchRequestData","index","readUint8ArrayHttpReader","XHRReader","sendXMLHttpRequest","getXMLHttpRequestData","httpReader","preventHeadRequest","useRangeHeader","forceRangeRequests","combineSizeEocd","useXHR","sendRequest","getRequestData","isHttpFamily","response","getRangeHeaders","undefined","Error","eocdCache","contentSize","contentRangeHeader","splitHeader","trim","split","headerValue","Number","getContentLength","status","subarray","getHeaders","Symbol","iterator","fromEntries","contentLength","method","fetch","statusText","request","XMLHttpRequest","addEventListener","getAllResponseHeaders","forEach","header","replace","value","toUpperCase","Map","event","detail","open","entry","entries","setRequestHeader","responseType","send","HttpReader","HttpRangeReader","Uint8ArrayReader","Uint8ArrayWriter","initSize","previousArray","set","SplitDataReader","readers","lastDiskNumber","lastDiskOffset","all","map","diskReader","indexDiskReader","diskNumber","currentDiskNumber","currentReaderOffset","currentReader","currentReaderSize","chunkLength","max","SplitDataWriter","writerGenerator","maxSize","diskOffset","availableSize","diskSourceWriter","diskWritable","diskWriter","done","next","initStream","getWriter","writeChunk","closeDisk","ready","baseURL","protocol","URL","stream","initReader","Array","isArray","initWriter","Infinity","SplitZipReader","SplitZipWriter"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@zip.js/zip.js/lib/core/io.js"],"sourcesContent":["/*\n Copyright (c) 2022 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* global Blob, atob, btoa, XMLHttpRequest, URL, fetch, ReadableStream, WritableStream, FileReader, TransformStream, Response */\n// deno-lint-ignore-file no-this-alias\n\nimport {\n\tUNDEFINED_VALUE,\n\tFUNCTION_TYPE,\n\tEND_OF_CENTRAL_DIR_LENGTH\n} from \"./constants.js\";\nimport { getConfiguration } from \"./configuration.js\";\n\nconst ERR_HTTP_STATUS = \"HTTP error \";\nconst ERR_HTTP_RANGE = \"HTTP Range not supported\";\nconst ERR_ITERATOR_COMPLETED_TOO_SOON = \"Writer iterator completed too soon\";\n\nconst CONTENT_TYPE_TEXT_PLAIN = \"text/plain\";\nconst HTTP_HEADER_CONTENT_LENGTH = \"Content-Length\";\nconst HTTP_HEADER_CONTENT_RANGE = \"Content-Range\";\nconst HTTP_HEADER_ACCEPT_RANGES = \"Accept-Ranges\";\nconst HTTP_HEADER_RANGE = \"Range\";\nconst HTTP_HEADER_CONTENT_TYPE = \"Content-Type\";\nconst HTTP_METHOD_HEAD = \"HEAD\";\nconst HTTP_METHOD_GET = \"GET\";\nconst HTTP_RANGE_UNIT = \"bytes\";\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst PROPERTY_NAME_WRITABLE = \"writable\";\n\nclass Stream {\n\n\tconstructor() {\n\t\tthis.size = 0;\n\t}\n\n\tinit() {\n\t\tthis.initialized = true;\n\t}\n}\n\nclass Reader extends Stream {\n\n\tget readable() {\n\t\tconst reader = this;\n\t\tconst { chunkSize = DEFAULT_CHUNK_SIZE } = reader;\n\t\tconst readable = new ReadableStream({\n\t\t\tstart() {\n\t\t\t\tthis.chunkOffset = 0;\n\t\t\t},\n\t\t\tasync pull(controller) {\n\t\t\t\tconst { offset = 0, size, diskNumberStart } = readable;\n\t\t\t\tconst { chunkOffset } = this;\n\t\t\t\tcontroller.enqueue(await readUint8Array(reader, offset + chunkOffset, Math.min(chunkSize, size - chunkOffset), diskNumberStart));\n\t\t\t\tif (chunkOffset + chunkSize > size) {\n\t\t\t\t\tcontroller.close();\n\t\t\t\t} else {\n\t\t\t\t\tthis.chunkOffset += chunkSize;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn readable;\n\t}\n}\n\nclass Writer extends Stream {\n\n\tconstructor() {\n\t\tsuper();\n\t\tconst writer = this;\n\t\tconst writable = new WritableStream({\n\t\t\twrite(chunk) {\n\t\t\t\treturn writer.writeUint8Array(chunk);\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(writer, PROPERTY_NAME_WRITABLE, {\n\t\t\tget() {\n\t\t\t\treturn writable;\n\t\t\t}\n\t\t});\n\t}\n\n\twriteUint8Array() {\n\t\t// abstract\n\t}\n}\n\nclass Data64URIReader extends Reader {\n\n\tconstructor(dataURI) {\n\t\tsuper();\n\t\tlet dataEnd = dataURI.length;\n\t\twhile (dataURI.charAt(dataEnd - 1) == \"=\") {\n\t\t\tdataEnd--;\n\t\t}\n\t\tconst dataStart = dataURI.indexOf(\",\") + 1;\n\t\tObject.assign(this, {\n\t\t\tdataURI,\n\t\t\tdataStart,\n\t\t\tsize: Math.floor((dataEnd - dataStart) * 0.75)\n\t\t});\n\t}\n\n\treadUint8Array(offset, length) {\n\t\tconst {\n\t\t\tdataStart,\n\t\t\tdataURI\n\t\t} = this;\n\t\tconst dataArray = new Uint8Array(length);\n\t\tconst start = Math.floor(offset / 3) * 4;\n\t\tconst bytes = atob(dataURI.substring(start + dataStart, Math.ceil((offset + length) / 3) * 4 + dataStart));\n\t\tconst delta = offset - Math.floor(start / 4) * 3;\n\t\tfor (let indexByte = delta; indexByte < delta + length; indexByte++) {\n\t\t\tdataArray[indexByte - delta] = bytes.charCodeAt(indexByte);\n\t\t}\n\t\treturn dataArray;\n\t}\n}\n\nclass Data64URIWriter extends Writer {\n\n\tconstructor(contentType) {\n\t\tsuper();\n\t\tObject.assign(this, {\n\t\t\tdata: \"data:\" + (contentType || \"\") + \";base64,\",\n\t\t\tpending: []\n\t\t});\n\t}\n\n\twriteUint8Array(array) {\n\t\tconst writer = this;\n\t\tlet indexArray = 0;\n\t\tlet dataString = writer.pending;\n\t\tconst delta = writer.pending.length;\n\t\twriter.pending = \"\";\n\t\tfor (indexArray = 0; indexArray < (Math.floor((delta + array.length) / 3) * 3) - delta; indexArray++) {\n\t\t\tdataString += String.fromCharCode(array[indexArray]);\n\t\t}\n\t\tfor (; indexArray < array.length; indexArray++) {\n\t\t\twriter.pending += String.fromCharCode(array[indexArray]);\n\t\t}\n\t\tif (dataString.length > 2) {\n\t\t\twriter.data += btoa(dataString);\n\t\t} else {\n\t\t\twriter.pending = dataString;\n\t\t}\n\t}\n\n\tgetData() {\n\t\treturn this.data + btoa(this.pending);\n\t}\n}\n\nclass BlobReader extends Reader {\n\n\tconstructor(blob) {\n\t\tsuper();\n\t\tObject.assign(this, {\n\t\t\tblob,\n\t\t\tsize: blob.size\n\t\t});\n\t}\n\n\tasync readUint8Array(offset, length) {\n\t\tconst reader = this;\n\t\tconst offsetEnd = offset + length;\n\t\tconst blob = offset || offsetEnd < reader.size ? reader.blob.slice(offset, offsetEnd) : reader.blob;\n\t\tlet arrayBuffer = await blob.arrayBuffer();\n\t\tif (arrayBuffer.byteLength > length) {\n\t\t\tarrayBuffer = arrayBuffer.slice(offset, offsetEnd);\n\t\t}\n\t\treturn new Uint8Array(arrayBuffer);\n\t}\n}\n\nclass BlobWriter extends Stream {\n\n\tconstructor(contentType) {\n\t\tsuper();\n\t\tconst writer = this;\n\t\tconst transformStream = new TransformStream();\n\t\tconst headers = [];\n\t\tif (contentType) {\n\t\t\theaders.push([HTTP_HEADER_CONTENT_TYPE, contentType]);\n\t\t}\n\t\tObject.defineProperty(writer, PROPERTY_NAME_WRITABLE, {\n\t\t\tget() {\n\t\t\t\treturn transformStream.writable;\n\t\t\t}\n\t\t});\n\t\twriter.blob = new Response(transformStream.readable, { headers }).blob();\n\t}\n\n\tgetData() {\n\t\treturn this.blob;\n\t}\n}\n\nclass TextReader extends BlobReader {\n\n\tconstructor(text) {\n\t\tsuper(new Blob([text], { type: CONTENT_TYPE_TEXT_PLAIN }));\n\t}\n}\n\nclass TextWriter extends BlobWriter {\n\n\tconstructor(encoding) {\n\t\tsuper(encoding);\n\t\tObject.assign(this, {\n\t\t\tencoding,\n\t\t\tutf8: !encoding || encoding.toLowerCase() == \"utf-8\"\n\t\t});\n\t}\n\n\tasync getData() {\n\t\tconst {\n\t\t\tencoding,\n\t\t\tutf8\n\t\t} = this;\n\t\tconst blob = await super.getData();\n\t\tif (blob.text && utf8) {\n\t\t\treturn blob.text();\n\t\t} else {\n\t\t\tconst reader = new FileReader();\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tObject.assign(reader, {\n\t\t\t\t\tonload: ({ target }) => resolve(target.result),\n\t\t\t\t\tonerror: () => reject(reader.error)\n\t\t\t\t});\n\t\t\t\treader.readAsText(blob, encoding);\n\t\t\t});\n\t\t}\n\t}\n}\n\nclass FetchReader extends Reader {\n\n\tconstructor(url, options) {\n\t\tsuper();\n\t\tcreateHttpReader(this, url, options);\n\t}\n\n\tasync init() {\n\t\tawait initHttpReader(this, sendFetchRequest, getFetchRequestData);\n\t\tsuper.init();\n\t}\n\n\treadUint8Array(index, length) {\n\t\treturn readUint8ArrayHttpReader(this, index, length, sendFetchRequest, getFetchRequestData);\n\t}\n}\n\nclass XHRReader extends Reader {\n\n\tconstructor(url, options) {\n\t\tsuper();\n\t\tcreateHttpReader(this, url, options);\n\t}\n\n\tasync init() {\n\t\tawait initHttpReader(this, sendXMLHttpRequest, getXMLHttpRequestData);\n\t\tsuper.init();\n\t}\n\n\treadUint8Array(index, length) {\n\t\treturn readUint8ArrayHttpReader(this, index, length, sendXMLHttpRequest, getXMLHttpRequestData);\n\t}\n}\n\nfunction createHttpReader(httpReader, url, options) {\n\tconst {\n\t\tpreventHeadRequest,\n\t\tuseRangeHeader,\n\t\tforceRangeRequests,\n\t\tcombineSizeEocd\n\t} = options;\n\toptions = Object.assign({}, options);\n\tdelete options.preventHeadRequest;\n\tdelete options.useRangeHeader;\n\tdelete options.forceRangeRequests;\n\tdelete options.combineSizeEocd;\n\tdelete options.useXHR;\n\tObject.assign(httpReader, {\n\t\turl,\n\t\toptions,\n\t\tpreventHeadRequest,\n\t\tuseRangeHeader,\n\t\tforceRangeRequests,\n\t\tcombineSizeEocd\n\t});\n}\n\nasync function initHttpReader(httpReader, sendRequest, getRequestData) {\n\tconst {\n\t\turl,\n\t\tpreventHeadRequest,\n\t\tuseRangeHeader,\n\t\tforceRangeRequests,\n\t\tcombineSizeEocd\n\t} = httpReader;\n\tif (isHttpFamily(url) && (useRangeHeader || forceRangeRequests) && (typeof preventHeadRequest == \"undefined\" || preventHeadRequest)) {\n\t\tconst response = await sendRequest(HTTP_METHOD_GET, httpReader, getRangeHeaders(httpReader, combineSizeEocd ? -END_OF_CENTRAL_DIR_LENGTH : undefined));\n\t\tif (!forceRangeRequests && response.headers.get(HTTP_HEADER_ACCEPT_RANGES) != HTTP_RANGE_UNIT) {\n\t\t\tthrow new Error(ERR_HTTP_RANGE);\n\t\t} else {\n\t\t\tif (combineSizeEocd) {\n\t\t\t\thttpReader.eocdCache = new Uint8Array(await response.arrayBuffer());\n\t\t\t}\n\t\t\tlet contentSize;\n\t\t\tconst contentRangeHeader = response.headers.get(HTTP_HEADER_CONTENT_RANGE);\n\t\t\tif (contentRangeHeader) {\n\t\t\t\tconst splitHeader = contentRangeHeader.trim().split(/\\s*\\/\\s*/);\n\t\t\t\tif (splitHeader.length) {\n\t\t\t\t\tconst headerValue = splitHeader[1];\n\t\t\t\t\tif (headerValue && headerValue != \"*\") {\n\t\t\t\t\t\tcontentSize = Number(headerValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (contentSize === UNDEFINED_VALUE) {\n\t\t\t\tawait getContentLength(httpReader, sendRequest, getRequestData);\n\t\t\t} else {\n\t\t\t\thttpReader.size = contentSize;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tawait getContentLength(httpReader, sendRequest, getRequestData);\n\t}\n}\n\nasync function readUint8ArrayHttpReader(httpReader, index, length, sendRequest, getRequestData) {\n\tconst {\n\t\tuseRangeHeader,\n\t\tforceRangeRequests,\n\t\teocdCache,\n\t\tsize,\n\t\toptions\n\t} = httpReader;\n\tif (useRangeHeader || forceRangeRequests) {\n\t\tif (eocdCache && index == size - END_OF_CENTRAL_DIR_LENGTH && length == END_OF_CENTRAL_DIR_LENGTH) {\n\t\t\treturn eocdCache;\n\t\t}\n\t\tconst response = await sendRequest(HTTP_METHOD_GET, httpReader, getRangeHeaders(httpReader, index, length));\n\t\tif (response.status != 206) {\n\t\t\tthrow new Error(ERR_HTTP_RANGE);\n\t\t}\n\t\treturn new Uint8Array(await response.arrayBuffer());\n\t} else {\n\t\tconst { data } = httpReader;\n\t\tif (!data) {\n\t\t\tawait getRequestData(httpReader, options);\n\t\t}\n\t\treturn new Uint8Array(httpReader.data.subarray(index, index + length));\n\t}\n}\n\nfunction getRangeHeaders(httpReader, index = 0, length = 1) {\n\treturn Object.assign({}, getHeaders(httpReader), { [HTTP_HEADER_RANGE]: HTTP_RANGE_UNIT + \"=\" + (index < 0 ? index : index + \"-\" + (index + length - 1)) });\n}\n\nfunction getHeaders({ options }) {\n\tconst { headers } = options;\n\tif (headers) {\n\t\tif (Symbol.iterator in headers) {\n\t\t\treturn Object.fromEntries(headers);\n\t\t} else {\n\t\t\treturn headers;\n\t\t}\n\t}\n}\n\nasync function getFetchRequestData(httpReader) {\n\tawait getRequestData(httpReader, sendFetchRequest);\n}\n\nasync function getXMLHttpRequestData(httpReader) {\n\tawait getRequestData(httpReader, sendXMLHttpRequest);\n}\n\nasync function getRequestData(httpReader, sendRequest) {\n\tconst response = await sendRequest(HTTP_METHOD_GET, httpReader, getHeaders(httpReader));\n\thttpReader.data = new Uint8Array(await response.arrayBuffer());\n\tif (!httpReader.size) {\n\t\thttpReader.size = httpReader.data.length;\n\t}\n}\n\nasync function getContentLength(httpReader, sendRequest, getRequestData) {\n\tif (httpReader.preventHeadRequest) {\n\t\tawait getRequestData(httpReader, httpReader.options);\n\t} else {\n\t\tconst response = await sendRequest(HTTP_METHOD_HEAD, httpReader, getHeaders(httpReader));\n\t\tconst contentLength = response.headers.get(HTTP_HEADER_CONTENT_LENGTH);\n\t\tif (contentLength) {\n\t\t\thttpReader.size = Number(contentLength);\n\t\t} else {\n\t\t\tawait getRequestData(httpReader, httpReader.options);\n\t\t}\n\t}\n}\n\nasync function sendFetchRequest(method, { options, url }, headers) {\n\tconst response = await fetch(url, Object.assign({}, options, { method, headers }));\n\tif (response.status < 400) {\n\t\treturn response;\n\t} else {\n\t\tthrow response.status == 416 ? new Error(ERR_HTTP_RANGE) : new Error(ERR_HTTP_STATUS + (response.statusText || response.status));\n\t}\n}\n\nfunction sendXMLHttpRequest(method, { url }, headers) {\n\treturn new Promise((resolve, reject) => {\n\t\tconst request = new XMLHttpRequest();\n\t\trequest.addEventListener(\"load\", () => {\n\t\t\tif (request.status < 400) {\n\t\t\t\tconst headers = [];\n\t\t\t\trequest.getAllResponseHeaders().trim().split(/[\\r\\n]+/).forEach(header => {\n\t\t\t\t\tconst splitHeader = header.trim().split(/\\s*:\\s*/);\n\t\t\t\t\tsplitHeader[0] = splitHeader[0].trim().replace(/^[a-z]|-[a-z]/g, value => value.toUpperCase());\n\t\t\t\t\theaders.push(splitHeader);\n\t\t\t\t});\n\t\t\t\tresolve({\n\t\t\t\t\tstatus: request.status,\n\t\t\t\t\tarrayBuffer: () => request.response,\n\t\t\t\t\theaders: new Map(headers)\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treject(request.status == 416 ? new Error(ERR_HTTP_RANGE) : new Error(ERR_HTTP_STATUS + (request.statusText || request.status)));\n\t\t\t}\n\t\t}, false);\n\t\trequest.addEventListener(\"error\", event => reject(event.detail ? event.detail.error : new Error(\"Network error\")), false);\n\t\trequest.open(method, url);\n\t\tif (headers) {\n\t\t\tfor (const entry of Object.entries(headers)) {\n\t\t\t\trequest.setRequestHeader(entry[0], entry[1]);\n\t\t\t}\n\t\t}\n\t\trequest.responseType = \"arraybuffer\";\n\t\trequest.send();\n\t});\n}\n\nclass HttpReader extends Reader {\n\n\tconstructor(url, options = {}) {\n\t\tsuper();\n\t\tObject.assign(this, {\n\t\t\turl,\n\t\t\treader: options.useXHR ? new XHRReader(url, options) : new FetchReader(url, options)\n\t\t});\n\t}\n\n\tset size(value) {\n\t\t// ignored\n\t}\n\n\tget size() {\n\t\treturn this.reader.size;\n\t}\n\n\tasync init() {\n\t\tawait this.reader.init();\n\t\tsuper.init();\n\t}\n\n\treadUint8Array(index, length) {\n\t\treturn this.reader.readUint8Array(index, length);\n\t}\n}\n\nclass HttpRangeReader extends HttpReader {\n\n\tconstructor(url, options = {}) {\n\t\toptions.useRangeHeader = true;\n\t\tsuper(url, options);\n\t}\n}\n\n\nclass Uint8ArrayReader extends Reader {\n\n\tconstructor(array) {\n\t\tsuper();\n\t\tObject.assign(this, {\n\t\t\tarray,\n\t\t\tsize: array.length\n\t\t});\n\t}\n\n\treadUint8Array(index, length) {\n\t\treturn this.array.slice(index, index + length);\n\t}\n}\n\nclass Uint8ArrayWriter extends Writer {\n\n\tinit(initSize = 0) {\n\t\tObject.assign(this, {\n\t\t\toffset: 0,\n\t\t\tarray: new Uint8Array(initSize)\n\t\t});\n\t\tsuper.init();\n\t}\n\n\twriteUint8Array(array) {\n\t\tconst writer = this;\n\t\tif (writer.offset + array.length > writer.array.length) {\n\t\t\tconst previousArray = writer.array;\n\t\t\twriter.array = new Uint8Array(previousArray.length + array.length);\n\t\t\twriter.array.set(previousArray);\n\t\t}\n\t\twriter.array.set(array, writer.offset);\n\t\twriter.offset += array.length;\n\t}\n\n\tgetData() {\n\t\treturn this.array;\n\t}\n}\n\nclass SplitDataReader extends Reader {\n\n\tconstructor(readers) {\n\t\tsuper();\n\t\tthis.readers = readers;\n\t}\n\n\tasync init() {\n\t\tconst reader = this;\n\t\tconst { readers } = reader;\n\t\treader.lastDiskNumber = 0;\n\t\treader.lastDiskOffset = 0;\n\t\tawait Promise.all(readers.map(async (diskReader, indexDiskReader) => {\n\t\t\tawait diskReader.init();\n\t\t\tif (indexDiskReader != readers.length - 1) {\n\t\t\t\treader.lastDiskOffset += diskReader.size;\n\t\t\t}\n\t\t\treader.size += diskReader.size;\n\t\t}));\n\t\tsuper.init();\n\t}\n\n\tasync readUint8Array(offset, length, diskNumber = 0) {\n\t\tconst reader = this;\n\t\tconst { readers } = this;\n\t\tlet result;\n\t\tlet currentDiskNumber = diskNumber;\n\t\tif (currentDiskNumber == -1) {\n\t\t\tcurrentDiskNumber = readers.length - 1;\n\t\t}\n\t\tlet currentReaderOffset = offset;\n\t\twhile (currentReaderOffset >= readers[currentDiskNumber].size) {\n\t\t\tcurrentReaderOffset -= readers[currentDiskNumber].size;\n\t\t\tcurrentDiskNumber++;\n\t\t}\n\t\tconst currentReader = readers[currentDiskNumber];\n\t\tconst currentReaderSize = currentReader.size;\n\t\tif (currentReaderOffset + length <= currentReaderSize) {\n\t\t\tresult = await readUint8Array(currentReader, currentReaderOffset, length);\n\t\t} else {\n\t\t\tconst chunkLength = currentReaderSize - currentReaderOffset;\n\t\t\tresult = new Uint8Array(length);\n\t\t\tresult.set(await readUint8Array(currentReader, currentReaderOffset, chunkLength));\n\t\t\tresult.set(await reader.readUint8Array(offset + chunkLength, length - chunkLength, diskNumber), chunkLength);\n\t\t}\n\t\treader.lastDiskNumber = Math.max(currentDiskNumber, reader.lastDiskNumber);\n\t\treturn result;\n\t}\n}\n\nclass SplitDataWriter extends Stream {\n\n\tconstructor(writerGenerator, maxSize = 4294967295) {\n\t\tsuper();\n\t\tconst writer = this;\n\t\tObject.assign(writer, {\n\t\t\tdiskNumber: 0,\n\t\t\tdiskOffset: 0,\n\t\t\tsize: 0,\n\t\t\tmaxSize,\n\t\t\tavailableSize: maxSize\n\t\t});\n\t\tlet diskSourceWriter, diskWritable, diskWriter;\n\t\tconst writable = new WritableStream({\n\t\t\tasync write(chunk) {\n\t\t\t\tconst { availableSize } = writer;\n\t\t\t\tif (!diskWriter) {\n\t\t\t\t\tconst { value, done } = await writerGenerator.next();\n\t\t\t\t\tif (done && !value) {\n\t\t\t\t\t\tthrow new Error(ERR_ITERATOR_COMPLETED_TOO_SOON);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiskSourceWriter = value;\n\t\t\t\t\t\tdiskSourceWriter.size = 0;\n\t\t\t\t\t\tif (diskSourceWriter.maxSize) {\n\t\t\t\t\t\t\twriter.maxSize = diskSourceWriter.maxSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twriter.availableSize = writer.maxSize;\n\t\t\t\t\t\tawait initStream(diskSourceWriter);\n\t\t\t\t\t\tdiskWritable = value.writable;\n\t\t\t\t\t\tdiskWriter = diskWritable.getWriter();\n\t\t\t\t\t}\n\t\t\t\t\tawait this.write(chunk);\n\t\t\t\t} else if (chunk.length >= availableSize) {\n\t\t\t\t\tawait writeChunk(chunk.slice(0, availableSize));\n\t\t\t\t\tawait closeDisk();\n\t\t\t\t\twriter.diskOffset += diskSourceWriter.size;\n\t\t\t\t\twriter.diskNumber++;\n\t\t\t\t\tdiskWriter = null;\n\t\t\t\t\tawait this.write(chunk.slice(availableSize));\n\t\t\t\t} else {\n\t\t\t\t\tawait writeChunk(chunk);\n\t\t\t\t}\n\t\t\t},\n\t\t\tasync close() {\n\t\t\t\tawait diskWriter.ready;\n\t\t\t\tawait closeDisk();\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(writer, PROPERTY_NAME_WRITABLE, {\n\t\t\tget() {\n\t\t\t\treturn writable;\n\t\t\t}\n\t\t});\n\n\t\tasync function writeChunk(chunk) {\n\t\t\tconst chunkLength = chunk.length;\n\t\t\tif (chunkLength) {\n\t\t\t\tawait diskWriter.ready;\n\t\t\t\tawait diskWriter.write(chunk);\n\t\t\t\tdiskSourceWriter.size += chunkLength;\n\t\t\t\twriter.size += chunkLength;\n\t\t\t\twriter.availableSize -= chunkLength;\n\t\t\t}\n\t\t}\n\n\t\tasync function closeDisk() {\n\t\t\tdiskWritable.size = diskSourceWriter.size;\n\t\t\tawait diskWriter.close();\n\t\t}\n\t}\n}\n\nfunction isHttpFamily(url) {\n\tconst { baseURL } = getConfiguration();\n\tconst { protocol } = new URL(url, baseURL);\n\treturn protocol == \"http:\" || protocol == \"https:\";\n}\n\nasync function initStream(stream, initSize) {\n\tif (stream.init && !stream.initialized) {\n\t\tawait stream.init(initSize);\n\t} else {\n\t\treturn Promise.resolve();\n\t}\n}\n\nfunction initReader(reader) {\n\tif (Array.isArray(reader)) {\n\t\treader = new SplitDataReader(reader);\n\t}\n\tif (reader instanceof ReadableStream) {\n\t\treader = {\n\t\t\treadable: reader\n\t\t};\n\t}\n\treturn reader;\n}\n\nfunction initWriter(writer) {\n\tif (writer.writable === UNDEFINED_VALUE && typeof writer.next == FUNCTION_TYPE) {\n\t\twriter = new SplitDataWriter(writer);\n\t}\n\tif (writer instanceof WritableStream) {\n\t\twriter = {\n\t\t\twritable: writer\n\t\t};\n\t}\n\tconst { writable } = writer;\n\tif (writable.size === UNDEFINED_VALUE) {\n\t\twritable.size = 0;\n\t}\n\tif (!(writer instanceof SplitDataWriter)) {\n\t\tObject.assign(writer, {\n\t\t\tdiskNumber: 0,\n\t\t\tdiskOffset: 0,\n\t\t\tavailableSize: Infinity,\n\t\t\tmaxSize: Infinity\n\t\t});\n\t}\n\treturn writer;\n}\n\nfunction readUint8Array(reader, offset, size, diskNumber) {\n\treturn reader.readUint8Array(offset, size, diskNumber);\n}\n\nconst SplitZipReader = SplitDataReader;\nconst SplitZipWriter = SplitDataWriter;\n\nexport {\n\tinitStream,\n\tinitReader,\n\tinitWriter,\n\treadUint8Array,\n\tReader,\n\tWriter,\n\tTextReader,\n\tTextWriter,\n\tData64URIReader,\n\tData64URIWriter,\n\tBlobReader,\n\tBlobWriter,\n\tUint8ArrayReader,\n\tUint8ArrayWriter,\n\tHttpReader,\n\tHttpRangeReader,\n\tSplitZipReader,\n\tSplitZipWriter,\n\tSplitDataReader,\n\tSplitDataWriter,\n\tERR_HTTP_RANGE,\n\tERR_ITERATOR_COMPLETED_TOO_SOON\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}