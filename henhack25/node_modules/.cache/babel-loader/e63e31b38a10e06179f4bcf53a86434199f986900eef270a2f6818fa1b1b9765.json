{"ast":null,"code":"import { ContextRequestEvent as e } from \"./context-request-event.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nclass t {\n  constructor() {\n    this.pendingContextRequests = new Map(), this.onContextProvider = t => {\n      const s = this.pendingContextRequests.get(t.context);\n      if (void 0 === s) return;\n      this.pendingContextRequests.delete(t.context);\n      const {\n        requests: o\n      } = s;\n      for (const {\n        elementRef: s,\n        callbackRef: n\n      } of o) {\n        const o = s.deref(),\n          c = n.deref();\n        void 0 === o || void 0 === c || o.dispatchEvent(new e(t.context, o, c, !0));\n      }\n    }, this.onContextRequest = e => {\n      if (!0 !== e.subscribe) return;\n      const t = e.contextTarget ?? e.composedPath()[0],\n        s = e.callback;\n      let o = this.pendingContextRequests.get(e.context);\n      void 0 === o && this.pendingContextRequests.set(e.context, o = {\n        callbacks: new WeakMap(),\n        requests: []\n      });\n      let n = o.callbacks.get(t);\n      void 0 === n && o.callbacks.set(t, n = new WeakSet()), n.has(s) || (n.add(s), o.requests.push({\n        elementRef: new WeakRef(t),\n        callbackRef: new WeakRef(s)\n      }));\n    };\n  }\n  attach(e) {\n    e.addEventListener(\"context-request\", this.onContextRequest), e.addEventListener(\"context-provider\", this.onContextProvider);\n  }\n  detach(e) {\n    e.removeEventListener(\"context-request\", this.onContextRequest), e.removeEventListener(\"context-provider\", this.onContextProvider);\n  }\n}\nexport { t as ContextRoot };","map":{"version":3,"names":["t","constructor","pendingContextRequests","Map","onContextProvider","s","get","context","delete","requests","o","elementRef","callbackRef","n","deref","c","dispatchEvent","e","onContextRequest","subscribe","contextTarget","composedPath","callback","set","callbacks","WeakMap","WeakSet","has","add","push","WeakRef","attach","addEventListener","detach","removeEventListener","ContextRoot"],"sources":["C:\\Users\\nolan\\tasks\\HenHacks2025\\henhack25\\node_modules\\@lit\\context\\src\\lib\\context-root.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Context} from './create-context.js';\nimport {ContextCallback, ContextRequestEvent} from './context-request-event.js';\nimport {ContextProviderEvent} from './controllers/context-provider.js';\n\n/**\n * A ContextRoot can be used to gather unsatisfied context requests and\n * re-dispatch them when new providers which satisfy matching context keys are\n * available.\n *\n * This allows providers to be added to a DOM tree, or upgraded, after the\n * consumers.\n */\nexport class ContextRoot {\n  private pendingContextRequests = new Map<\n    Context<unknown, unknown>,\n    {\n      // The WeakMap lets us detect if we're seen an element/callback pair yet,\n      // without needing to iterate the `requests` array\n      callbacks: WeakMap<HTMLElement, WeakSet<ContextCallback<unknown>>>;\n\n      // Requests lets us iterate over every element/callback that we need to\n      // replay context events for\n      // Both the element and callback must be stored in WeakRefs because the\n      // callback most likely has a strong ref to the element.\n      requests: Array<{\n        elementRef: WeakRef<HTMLElement>;\n        callbackRef: WeakRef<ContextCallback<unknown>>;\n      }>;\n    }\n  >();\n\n  /**\n   * Attach the ContextRoot to a given element to intercept `context-request` and\n   * `context-provider` events.\n   *\n   * @param element an element to add event listeners to\n   */\n  attach(element: HTMLElement): void {\n    element.addEventListener('context-request', this.onContextRequest);\n    element.addEventListener('context-provider', this.onContextProvider);\n  }\n\n  /**\n   * Removes the ContextRoot event listeners from a given element.\n   *\n   * @param element an element from which to remove event listeners\n   */\n  detach(element: HTMLElement): void {\n    element.removeEventListener('context-request', this.onContextRequest);\n    element.removeEventListener('context-provider', this.onContextProvider);\n  }\n\n  private onContextProvider = (\n    event: ContextProviderEvent<Context<unknown, unknown>>\n  ) => {\n    const pendingRequestData = this.pendingContextRequests.get(event.context);\n    if (pendingRequestData === undefined) {\n      // No pending requests for this context at this time\n      return;\n    }\n\n    // Clear our list. Any still unsatisfied requests will re-add themselves\n    // when we dispatch the events below.\n    this.pendingContextRequests.delete(event.context);\n\n    // Loop over all pending requests and re-dispatch them from their source\n    const {requests} = pendingRequestData;\n    for (const {elementRef, callbackRef} of requests) {\n      const element = elementRef.deref();\n      const callback = callbackRef.deref();\n\n      if (element === undefined || callback === undefined) {\n        // The element was GC'ed. Do nothing.\n      } else {\n        // Re-dispatch if we still have the element and callback\n        element.dispatchEvent(\n          new ContextRequestEvent(event.context, element, callback, true)\n        );\n      }\n    }\n  };\n\n  private onContextRequest = (\n    event: ContextRequestEvent<Context<unknown, unknown>>\n  ) => {\n    // Events that are not subscribing should not be buffered\n    if (event.subscribe !== true) {\n      return;\n    }\n\n    // Note, it's important to use the initial target\n    // since that's the requesting element and the event may be re-targeted\n    // to an outer host element.\n    const element = (event.contextTarget ??\n      event.composedPath()[0]) as HTMLElement;\n    const callback = event.callback;\n\n    let pendingContextRequests = this.pendingContextRequests.get(event.context);\n    if (pendingContextRequests === undefined) {\n      this.pendingContextRequests.set(\n        event.context,\n        (pendingContextRequests = {\n          callbacks: new WeakMap(),\n          requests: [],\n        })\n      );\n    }\n\n    let callbacks = pendingContextRequests.callbacks.get(element);\n    if (callbacks === undefined) {\n      pendingContextRequests.callbacks.set(\n        element,\n        (callbacks = new WeakSet())\n      );\n    }\n\n    if (callbacks.has(callback)) {\n      // We're already tracking this element/callback pair\n      return;\n    }\n\n    callbacks.add(callback);\n    pendingContextRequests.requests.push({\n      elementRef: new WeakRef(element),\n      callbackRef: new WeakRef(callback),\n    });\n  };\n}\n"],"mappings":";;;;;;MAkBaA,CAAA;EAAbC,YAAA;IACU,KAAAC,sBAAA,GAAyB,IAAIC,GAAA,IAuC7B,KAAAC,iBAAA,GACNJ,CAAA;MAEA,MAAMK,CAAA,GAAqB,KAAKH,sBAAA,CAAuBI,GAAA,CAAIN,CAAA,CAAMO,OAAA;MACjE,SAA2B,MAAvBF,CAAA,EAEF;MAKF,KAAKH,sBAAA,CAAuBM,MAAA,CAAOR,CAAA,CAAMO,OAAA;MAGzC;QAAME,QAAA,EAACC;MAAA,IAAYL,CAAA;MACnB,KAAK;QAAMM,UAAA,EAACN,CAAA;QAAUO,WAAA,EAAEC;MAAA,KAAgBH,CAAA,EAAU;QAChD,MAAMA,CAAA,GAAUL,CAAA,CAAWS,KAAA;UACrBC,CAAA,GAAWF,CAAA,CAAYC,KAAA;QAAA,KAEb,MAAZJ,CAAA,SAAsC,MAAbK,CAAA,IAI3BL,CAAA,CAAQM,aAAA,CACN,IAAIC,CAAA,CAAoBjB,CAAA,CAAMO,OAAA,EAASG,CAAA,EAASK,CAAA,GAAU,GAG/D;MAAA;IAAA,GAGK,KAAAG,gBAAA,GACND,CAAA;MAGA,KAAwB,MAApBA,CAAA,CAAME,SAAA,EACR;MAMF,MAAMnB,CAAA,GAAWiB,CAAA,CAAMG,aAAA,IACrBH,CAAA,CAAMI,YAAA,GAAe;QACjBhB,CAAA,GAAWY,CAAA,CAAMK,QAAA;MAEvB,IAAIZ,CAAA,GAAyB,KAAKR,sBAAA,CAAuBI,GAAA,CAAIW,CAAA,CAAMV,OAAA;MAAA,KACpC,MAA3BG,CAAA,IACF,KAAKR,sBAAA,CAAuBqB,GAAA,CAC1BN,CAAA,CAAMV,OAAA,EACLG,CAAA,GAAyB;QACxBc,SAAA,EAAW,IAAIC,OAAA;QACfhB,QAAA,EAAU;MAAA;MAKhB,IAAII,CAAA,GAAYH,CAAA,CAAuBc,SAAA,CAAUlB,GAAA,CAAIN,CAAA;MAAA,KACnC,MAAda,CAAA,IACFH,CAAA,CAAuBc,SAAA,CAAUD,GAAA,CAC/BvB,CAAA,EACCa,CAAA,GAAY,IAAIa,OAAA,KAIjBb,CAAA,CAAUc,GAAA,CAAItB,CAAA,MAKlBQ,CAAA,CAAUe,GAAA,CAAIvB,CAAA,GACdK,CAAA,CAAuBD,QAAA,CAASoB,IAAA,CAAK;QACnClB,UAAA,EAAY,IAAImB,OAAA,CAAQ9B,CAAA;QACxBY,WAAA,EAAa,IAAIkB,OAAA,CAAQzB,CAAA;MAAA,GACzB;IAAA,CAEL;EAAA;EA1FC0B,OAAOd,CAAA;IACLA,CAAA,CAAQe,gBAAA,CAAiB,mBAAmB,KAAKd,gBAAA,GACjDD,CAAA,CAAQe,gBAAA,CAAiB,oBAAoB,KAAK5B,iBAAA,CACnD;EAAA;EAOD6B,OAAOhB,CAAA;IACLA,CAAA,CAAQiB,mBAAA,CAAoB,mBAAmB,KAAKhB,gBAAA,GACpDD,CAAA,CAAQiB,mBAAA,CAAoB,oBAAoB,KAAK9B,iBAAA,CACtD;EAAA;AAAA;AAAA,SAAAJ,CAAA,IAAAmC,WAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}