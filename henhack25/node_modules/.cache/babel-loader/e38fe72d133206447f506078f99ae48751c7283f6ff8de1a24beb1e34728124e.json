{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { ShaderOutput as e } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";\nimport { SliceDraw as i } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { ObjectAndLayerIdColor as t } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js\";\nimport { RibbonVertexPosition as n } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";\nimport { LineStipple as r, computePixelSize as o } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js\";\nimport { MarkerSizing as a } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MarkerSizing.glsl.js\";\nimport { PiUtils as s } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js\";\nimport { terrainDepthTest as l } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js\";\nimport { ColorConversion as d } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { addProjViewLocalOrigin as p, addPixelRatio as c } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float2BindUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";\nimport { Float4BindUniform as v } from \"../views/3d/webgl-engine/core/shaderModules/Float4BindUniform.js\";\nimport { Float4PassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatBindUniform as g } from \"../views/3d/webgl-engine/core/shaderModules/FloatBindUniform.js\";\nimport { FloatPassUniform as h } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as S } from \"../views/3d/webgl-engine/core/shaderModules/glsl.js\";\nimport { Matrix4BindUniform as u } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4BindUniform.js\";\nimport { VertexAttribute as D } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { LineMarkerSpace as x } from \"../views/3d/webgl-engine/shaders/LineMarkerTechniqueConfiguration.js\";\nimport { outputColorHighlightOID as L } from \"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js\";\nimport { CapType as w } from \"../views/3d/webgl-engine/shaders/RibbonLineTechniqueConfiguration.js\";\nimport { ShaderBuilder as b } from \"../views/webgl/ShaderBuilder.js\";\nimport { alphaCutoff as y } from \"../webscene/support/AlphaCutoff.js\";\nconst j = 1;\nfunction C(C) {\n  const F = new b(),\n    {\n      attributes: P,\n      varyings: R,\n      vertex: z,\n      fragment: A\n    } = F,\n    {\n      applyMarkerOffset: T,\n      draped: V,\n      output: O,\n      capType: W,\n      stippleEnabled: E,\n      falloffEnabled: I,\n      roundJoins: N,\n      wireframe: M,\n      innerColorEnabled: _\n    } = C;\n  F.include(s), F.include(n, C), F.include(r, C), F.include(t, C), F.include(l, C);\n  const k = T && !V;\n  k && (z.uniforms.add(new h(\"markerScale\", e => e.markerScale)), F.include(a, {\n    space: x.World\n  })), p(z, C), z.uniforms.add(new u(\"inverseProjectionMatrix\", e => e.camera.inverseProjectionMatrix), new m(\"nearFar\", e => e.camera.nearFar), new h(\"miterLimit\", e => \"miter\" !== e.join ? 0 : e.miterLimit), new v(\"viewport\", e => e.camera.fullViewport)), z.constants.add(\"LARGE_HALF_FLOAT\", \"float\", 65500), P.add(D.POSITION, \"vec3\"), P.add(D.PREVPOSITION, \"vec3\"), P.add(D.NEXTPOSITION, \"vec3\"), P.add(D.SUBDIVISIONFACTOR, \"float\"), P.add(D.UV0, \"vec2\"), R.add(\"vColor\", \"vec4\"), R.add(\"vpos\", \"vec3\"), R.add(\"vLineDistance\", \"float\"), R.add(\"vLineWidth\", \"float\");\n  const B = E;\n  B && R.add(\"vLineSizeInv\", \"float\");\n  const U = W === w.ROUND,\n    $ = E && U,\n    H = I || $;\n  H && R.add(\"vLineDistanceNorm\", \"float\"), U && (R.add(\"vSegmentSDF\", \"float\"), R.add(\"vReverseSegmentSDF\", \"float\")), z.code.add(S`vec2 perpendicular(vec2 v) {\nreturn vec2(v.y, -v.x);\n}\nfloat interp(float ncp, vec4 a, vec4 b) {\nreturn (-ncp - a.z) / (b.z - a.z);\n}\nvec2 rotate(vec2 v, float a) {\nfloat s = sin(a);\nfloat c = cos(a);\nmat2 m = mat2(c, -s, s, c);\nreturn m * v;\n}`), z.code.add(S`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`), z.code.add(S`void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\nfloat vnp = nearFar[0] * 0.99;\nif(pos.z > -nearFar[0]) {\nif (!isStartVertex) {\nif(prev.z < -nearFar[0]) {\npos = mix(prev, pos, interp(vnp, prev, pos));\nnext = pos;\n} else {\npos = vec4(0.0, 0.0, 0.0, 1.0);\n}\n} else {\nif(next.z < -nearFar[0]) {\npos = mix(pos, next, interp(vnp, pos, next));\nprev = pos;\n} else {\npos = vec4(0.0, 0.0, 0.0, 1.0);\n}\n}\n} else {\nif (prev.z > -nearFar[0]) {\nprev = mix(pos, prev, interp(vnp, pos, prev));\n}\nif (next.z > -nearFar[0]) {\nnext = mix(next, pos, interp(vnp, next, pos));\n}\n}\nforwardViewPosDepth(pos.xyz);\npos = projectAndScale(pos);\nnext = projectAndScale(next);\nprev = projectAndScale(prev);\n}`), c(z), z.constants.add(\"aaWidth\", \"float\", E ? 0 : 1).main.add(S`\n    // unpack values from uv0.y\n    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\n\n    float coverage = 1.0;\n\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      bool isJoin = abs(uv0.y) < 3.0;\n      float lineSize = getSize();\n\n      if (lineSize < 1.0) {\n        coverage = lineSize; // convert sub-pixel coverage to alpha\n        lineSize = 1.0;\n      }\n      lineSize += aaWidth;\n\n      float lineWidth = lineSize * pixelRatio;\n      vLineWidth = lineWidth;\n      ${B ? S`vLineSizeInv = 1.0 / lineSize;` : \"\"}\n\n      vec4 pos  = view * vec4(position, 1.0);\n      vec4 prev = view * vec4(prevPosition, 1.0);\n      vec4 next = view * vec4(nextPosition, 1.0);\n  `), k && z.main.add(S`vec4 other = isStartVertex ? next : prev;\nbool markersHidden = areWorldMarkersHidden(pos, other);\nif(!isJoin && !markersHidden) {\npos.xyz += normalize(other.xyz - pos.xyz) * getWorldMarkerSize(pos) * 0.5;\n}`), z.main.add(S`clipAndTransform(pos, prev, next, isStartVertex);\nvec2 left = (pos.xy - prev.xy);\nvec2 right = (next.xy - pos.xy);\nfloat leftLen = length(left);\nfloat rightLen = length(right);`);\n  (E || U) && z.main.add(S`\n      float isEndVertex = float(!isStartVertex);\n      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);\n      vec2 segment = mix(right, left, isEndVertex);\n      ${U ? S`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);` : \"\"}\n    `), z.main.add(S`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\nright = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\nvec2 capDisplacementDir = vec2(0, 0);\nvec2 joinDisplacementDir = vec2(0, 0);\nfloat displacementLen = lineWidth;\nif (isJoin) {\nbool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;\njoinDisplacementDir = normalize(left + right);\njoinDisplacementDir = perpendicular(joinDisplacementDir);\nif (leftLen > 0.001 && rightLen > 0.001) {\nfloat nDotSeg = dot(joinDisplacementDir, left);\ndisplacementLen /= length(nDotSeg * left - joinDisplacementDir);\nif (!isOutside) {\ndisplacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n}\n}\nif (isOutside && (displacementLen > miterLimit * lineWidth)) {`), N ? z.main.add(S`\n        vec2 startDir = leftLen < 0.001 ? right : left;\n        startDir = perpendicular(startDir);\n\n        vec2 endDir = rightLen < 0.001 ? left : right;\n        endDir = perpendicular(endDir);\n\n        float factor = ${E ? S`min(1.0, subdivisionFactor * ${S.float((j + 2) / (j + 1))})` : S`subdivisionFactor`};\n\n        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\n        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);\n      `) : z.main.add(S`if (leftLen < 0.001) {\njoinDisplacementDir = right;\n}\nelse if (rightLen < 0.001) {\njoinDisplacementDir = left;\n}\nelse {\njoinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;\n}\njoinDisplacementDir = perpendicular(joinDisplacementDir);`);\n  const J = W !== w.BUTT;\n  return z.main.add(S`\n        displacementLen = lineWidth;\n      }\n    } else {\n      // CAP handling ---------------------------------------------------\n      joinDisplacementDir = isStartVertex ? right : left;\n      joinDisplacementDir = perpendicular(joinDisplacementDir);\n\n      ${J ? S`capDisplacementDir = isStartVertex ? -right : left;` : \"\"}\n    }\n  `), z.main.add(S`\n    // Displacement (in pixels) caused by join/or cap\n    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;\n    float lineDistNorm = sign(uv0.y) * pos.w;\n\n    vLineDistance =  lineWidth * lineDistNorm;\n    ${H ? S`vLineDistanceNorm = lineDistNorm;` : \"\"}\n\n    pos.xy += dpos;\n  `), U && z.main.add(S`vec2 segmentDir = normalize(segment);\nvSegmentSDF = (isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir) * pos.w) ;\nvReverseSegmentSDF = (isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir) * pos.w);`), E && (V ? z.uniforms.add(new g(\"worldToScreenRatio\", e => 1 / e.screenToPCSRatio)) : z.main.add(S`vec3 segmentCenter = mix((nextPosition + position) * 0.5, (position + prevPosition) * 0.5, isEndVertex);\nfloat worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`), z.main.add(S`float segmentLengthScreenDouble = length(segment);\nfloat segmentLengthScreen = segmentLengthScreenDouble * 0.5;\nfloat discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);\nfloat segmentLengthRender = length(mix(nextPosition - position, position - prevPosition, isEndVertex));\nvStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`), V ? z.main.add(S`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;\nfloat startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`) : z.main.add(S`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;\nfloat segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`), z.uniforms.add(new h(\"stipplePatternPixelSize\", e => o(e))), z.main.add(S`float patternLength = lineSize * stipplePatternPixelSize;\nvStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);\nvStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);\nif (segmentLengthScreenDouble >= 0.001) {\nvec2 stippleDisplacement = pos.xy - segmentOrigin;\nfloat stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);\nvStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);\n}\nvStippleDistanceLimits *= pos.w;\nvStippleDistance *= pos.w;\nvStippleDistanceLimits = isJoin ?\nvStippleDistanceLimits :\nisStartVertex ?\nvec2(-1e34, vStippleDistanceLimits.y) :\nvec2(vStippleDistanceLimits.x, 1e34);`)), z.main.add(S`\n      // Convert back into NDC\n      pos.xy = (pos.xy / viewport.zw) * pos.w;\n\n      vColor = getColor();\n      vColor.a *= coverage;\n\n      ${M && !V ? \"pos.z -= 0.001 * pos.w;\" : \"\"}\n\n      // transform final position to camera space for slicing\n      vpos = (inverseProjectionMatrix * pos).xyz;\n      gl_Position = pos;\n      forwardObjectAndLayerIdColor();\n    }`), F.fragment.include(i, C), F.include(L, C), A.include(d), A.main.add(S`discardBySlice(vpos);\ndiscardByTerrainDepth();`), M ? A.main.add(S`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`) : (U && A.main.add(S`\n        float sdf = min(vSegmentSDF, vReverseSegmentSDF);\n        vec2 fragmentPosition = vec2(\n          min(sdf, 0.0),\n          vLineDistance\n        ) * gl_FragCoord.w;\n\n        float fragmentRadius = length(fragmentPosition);\n        float fragmentCapSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale\n        float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);\n\n        if (capCoverage < ${S.float(y)}) {\n          discard;\n        }\n      `), $ ? A.main.add(S`\n      vec2 stipplePosition = vec2(\n        min(getStippleSDF() * 2.0 - 1.0, 0.0),\n        vLineDistanceNorm * gl_FragCoord.w\n      );\n      float stippleRadius = length(stipplePosition * vLineWidth);\n      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale\n      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);\n      float stippleAlpha = step(${S.float(y)}, stippleCoverage);\n      `) : A.main.add(S`float stippleAlpha = getStippleAlpha();`), O !== e.ObjectAndLayerIdColor && A.main.add(S`discardByStippleAlpha(stippleAlpha, ${S.float(y)});`), A.uniforms.add(new f(\"intrinsicColor\", e => e.color)), A.main.add(S`vec4 color = intrinsicColor * vColor;`), _ && (A.uniforms.add(new f(\"innerColor\", e => e.innerColor ?? e.color), new h(\"innerWidth\", (e, i) => e.innerWidth * i.camera.pixelRatio)), A.main.add(S`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;\nfloat innerAA = clamp(0.5 - distToInner, 0.0, 1.0);\nfloat innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);\ncolor = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)), A.main.add(S`vec4 finalColor = blendStipple(color, stippleAlpha);`), I && (A.uniforms.add(new h(\"falloff\", e => e.falloff)), A.main.add(S`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`)), E || A.main.add(S`float featherStartDistance = max(vLineWidth - 2.0, 0.0);\nfloat value = abs(vLineDistance) * gl_FragCoord.w;\nfloat feather = (value - featherStartDistance) / (vLineWidth - featherStartDistance);\nfinalColor.a *= 1.0 - clamp(feather, 0.0, 1.0);`)), A.main.add(S`outputColorHighlightOID(finalColor, vpos);`), F;\n}\nconst F = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: C,\n  ribbonlineNumRoundJoinSubdivisions: j\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { F as R, C as b, j as r };","map":{"version":3,"names":["ShaderOutput","e","SliceDraw","i","ObjectAndLayerIdColor","t","RibbonVertexPosition","n","LineStipple","r","computePixelSize","o","MarkerSizing","a","PiUtils","s","terrainDepthTest","l","ColorConversion","d","addProjViewLocalOrigin","p","addPixelRatio","c","Float2BindUniform","m","Float4BindUniform","v","Float4PassUniform","f","FloatBindUniform","g","FloatPassUniform","h","glsl","S","Matrix4BindUniform","u","VertexAttribute","D","LineMarkerSpace","x","outputColorHighlightOID","L","CapType","w","ShaderBuilder","b","alphaCutoff","y","j","C","F","attributes","P","varyings","R","vertex","z","fragment","A","applyMarkerOffset","T","draped","V","output","O","capType","W","stippleEnabled","E","falloffEnabled","I","roundJoins","N","wireframe","M","innerColorEnabled","_","include","k","uniforms","add","markerScale","space","World","camera","inverseProjectionMatrix","nearFar","join","miterLimit","fullViewport","constants","POSITION","PREVPOSITION","NEXTPOSITION","SUBDIVISIONFACTOR","UV0","B","U","ROUND","$","H","code","main","float","J","BUTT","screenToPCSRatio","color","innerColor","innerWidth","pixelRatio","falloff","Object","freeze","defineProperty","__proto__","build","ribbonlineNumRoundJoinSubdivisions","Symbol","toStringTag","value"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/chunks/RibbonLine.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{ShaderOutput as e}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";import{SliceDraw as i}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{ObjectAndLayerIdColor as t}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js\";import{RibbonVertexPosition as n}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";import{LineStipple as r,computePixelSize as o}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js\";import{MarkerSizing as a}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MarkerSizing.glsl.js\";import{PiUtils as s}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js\";import{terrainDepthTest as l}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js\";import{ColorConversion as d}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{addProjViewLocalOrigin as p,addPixelRatio as c}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float2BindUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";import{Float4BindUniform as v}from\"../views/3d/webgl-engine/core/shaderModules/Float4BindUniform.js\";import{Float4PassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatBindUniform as g}from\"../views/3d/webgl-engine/core/shaderModules/FloatBindUniform.js\";import{FloatPassUniform as h}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as S}from\"../views/3d/webgl-engine/core/shaderModules/glsl.js\";import{Matrix4BindUniform as u}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4BindUniform.js\";import{VertexAttribute as D}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{LineMarkerSpace as x}from\"../views/3d/webgl-engine/shaders/LineMarkerTechniqueConfiguration.js\";import{outputColorHighlightOID as L}from\"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js\";import{CapType as w}from\"../views/3d/webgl-engine/shaders/RibbonLineTechniqueConfiguration.js\";import{ShaderBuilder as b}from\"../views/webgl/ShaderBuilder.js\";import{alphaCutoff as y}from\"../webscene/support/AlphaCutoff.js\";const j=1;function C(C){const F=new b,{attributes:P,varyings:R,vertex:z,fragment:A}=F,{applyMarkerOffset:T,draped:V,output:O,capType:W,stippleEnabled:E,falloffEnabled:I,roundJoins:N,wireframe:M,innerColorEnabled:_}=C;F.include(s),F.include(n,C),F.include(r,C),F.include(t,C),F.include(l,C);const k=T&&!V;k&&(z.uniforms.add(new h(\"markerScale\",(e=>e.markerScale))),F.include(a,{space:x.World})),p(z,C),z.uniforms.add(new u(\"inverseProjectionMatrix\",(e=>e.camera.inverseProjectionMatrix)),new m(\"nearFar\",(e=>e.camera.nearFar)),new h(\"miterLimit\",(e=>\"miter\"!==e.join?0:e.miterLimit)),new v(\"viewport\",(e=>e.camera.fullViewport))),z.constants.add(\"LARGE_HALF_FLOAT\",\"float\",65500),P.add(D.POSITION,\"vec3\"),P.add(D.PREVPOSITION,\"vec3\"),P.add(D.NEXTPOSITION,\"vec3\"),P.add(D.SUBDIVISIONFACTOR,\"float\"),P.add(D.UV0,\"vec2\"),R.add(\"vColor\",\"vec4\"),R.add(\"vpos\",\"vec3\"),R.add(\"vLineDistance\",\"float\"),R.add(\"vLineWidth\",\"float\");const B=E;B&&R.add(\"vLineSizeInv\",\"float\");const U=W===w.ROUND,$=E&&U,H=I||$;H&&R.add(\"vLineDistanceNorm\",\"float\"),U&&(R.add(\"vSegmentSDF\",\"float\"),R.add(\"vReverseSegmentSDF\",\"float\")),z.code.add(S`vec2 perpendicular(vec2 v) {\nreturn vec2(v.y, -v.x);\n}\nfloat interp(float ncp, vec4 a, vec4 b) {\nreturn (-ncp - a.z) / (b.z - a.z);\n}\nvec2 rotate(vec2 v, float a) {\nfloat s = sin(a);\nfloat c = cos(a);\nmat2 m = mat2(c, -s, s, c);\nreturn m * v;\n}`),z.code.add(S`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`),z.code.add(S`void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\nfloat vnp = nearFar[0] * 0.99;\nif(pos.z > -nearFar[0]) {\nif (!isStartVertex) {\nif(prev.z < -nearFar[0]) {\npos = mix(prev, pos, interp(vnp, prev, pos));\nnext = pos;\n} else {\npos = vec4(0.0, 0.0, 0.0, 1.0);\n}\n} else {\nif(next.z < -nearFar[0]) {\npos = mix(pos, next, interp(vnp, pos, next));\nprev = pos;\n} else {\npos = vec4(0.0, 0.0, 0.0, 1.0);\n}\n}\n} else {\nif (prev.z > -nearFar[0]) {\nprev = mix(pos, prev, interp(vnp, pos, prev));\n}\nif (next.z > -nearFar[0]) {\nnext = mix(next, pos, interp(vnp, next, pos));\n}\n}\nforwardViewPosDepth(pos.xyz);\npos = projectAndScale(pos);\nnext = projectAndScale(next);\nprev = projectAndScale(prev);\n}`),c(z),z.constants.add(\"aaWidth\",\"float\",E?0:1).main.add(S`\n    // unpack values from uv0.y\n    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\n\n    float coverage = 1.0;\n\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      bool isJoin = abs(uv0.y) < 3.0;\n      float lineSize = getSize();\n\n      if (lineSize < 1.0) {\n        coverage = lineSize; // convert sub-pixel coverage to alpha\n        lineSize = 1.0;\n      }\n      lineSize += aaWidth;\n\n      float lineWidth = lineSize * pixelRatio;\n      vLineWidth = lineWidth;\n      ${B?S`vLineSizeInv = 1.0 / lineSize;`:\"\"}\n\n      vec4 pos  = view * vec4(position, 1.0);\n      vec4 prev = view * vec4(prevPosition, 1.0);\n      vec4 next = view * vec4(nextPosition, 1.0);\n  `),k&&z.main.add(S`vec4 other = isStartVertex ? next : prev;\nbool markersHidden = areWorldMarkersHidden(pos, other);\nif(!isJoin && !markersHidden) {\npos.xyz += normalize(other.xyz - pos.xyz) * getWorldMarkerSize(pos) * 0.5;\n}`),z.main.add(S`clipAndTransform(pos, prev, next, isStartVertex);\nvec2 left = (pos.xy - prev.xy);\nvec2 right = (next.xy - pos.xy);\nfloat leftLen = length(left);\nfloat rightLen = length(right);`);(E||U)&&z.main.add(S`\n      float isEndVertex = float(!isStartVertex);\n      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);\n      vec2 segment = mix(right, left, isEndVertex);\n      ${U?S`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);`:\"\"}\n    `),z.main.add(S`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\nright = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\nvec2 capDisplacementDir = vec2(0, 0);\nvec2 joinDisplacementDir = vec2(0, 0);\nfloat displacementLen = lineWidth;\nif (isJoin) {\nbool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;\njoinDisplacementDir = normalize(left + right);\njoinDisplacementDir = perpendicular(joinDisplacementDir);\nif (leftLen > 0.001 && rightLen > 0.001) {\nfloat nDotSeg = dot(joinDisplacementDir, left);\ndisplacementLen /= length(nDotSeg * left - joinDisplacementDir);\nif (!isOutside) {\ndisplacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n}\n}\nif (isOutside && (displacementLen > miterLimit * lineWidth)) {`),N?z.main.add(S`\n        vec2 startDir = leftLen < 0.001 ? right : left;\n        startDir = perpendicular(startDir);\n\n        vec2 endDir = rightLen < 0.001 ? left : right;\n        endDir = perpendicular(endDir);\n\n        float factor = ${E?S`min(1.0, subdivisionFactor * ${S.float((j+2)/(j+1))})`:S`subdivisionFactor`};\n\n        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\n        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);\n      `):z.main.add(S`if (leftLen < 0.001) {\njoinDisplacementDir = right;\n}\nelse if (rightLen < 0.001) {\njoinDisplacementDir = left;\n}\nelse {\njoinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;\n}\njoinDisplacementDir = perpendicular(joinDisplacementDir);`);const J=W!==w.BUTT;return z.main.add(S`\n        displacementLen = lineWidth;\n      }\n    } else {\n      // CAP handling ---------------------------------------------------\n      joinDisplacementDir = isStartVertex ? right : left;\n      joinDisplacementDir = perpendicular(joinDisplacementDir);\n\n      ${J?S`capDisplacementDir = isStartVertex ? -right : left;`:\"\"}\n    }\n  `),z.main.add(S`\n    // Displacement (in pixels) caused by join/or cap\n    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;\n    float lineDistNorm = sign(uv0.y) * pos.w;\n\n    vLineDistance =  lineWidth * lineDistNorm;\n    ${H?S`vLineDistanceNorm = lineDistNorm;`:\"\"}\n\n    pos.xy += dpos;\n  `),U&&z.main.add(S`vec2 segmentDir = normalize(segment);\nvSegmentSDF = (isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir) * pos.w) ;\nvReverseSegmentSDF = (isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir) * pos.w);`),E&&(V?z.uniforms.add(new g(\"worldToScreenRatio\",(e=>1/e.screenToPCSRatio))):z.main.add(S`vec3 segmentCenter = mix((nextPosition + position) * 0.5, (position + prevPosition) * 0.5, isEndVertex);\nfloat worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),z.main.add(S`float segmentLengthScreenDouble = length(segment);\nfloat segmentLengthScreen = segmentLengthScreenDouble * 0.5;\nfloat discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);\nfloat segmentLengthRender = length(mix(nextPosition - position, position - prevPosition, isEndVertex));\nvStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`),V?z.main.add(S`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;\nfloat startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`):z.main.add(S`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;\nfloat segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),z.uniforms.add(new h(\"stipplePatternPixelSize\",(e=>o(e)))),z.main.add(S`float patternLength = lineSize * stipplePatternPixelSize;\nvStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);\nvStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);\nif (segmentLengthScreenDouble >= 0.001) {\nvec2 stippleDisplacement = pos.xy - segmentOrigin;\nfloat stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);\nvStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);\n}\nvStippleDistanceLimits *= pos.w;\nvStippleDistance *= pos.w;\nvStippleDistanceLimits = isJoin ?\nvStippleDistanceLimits :\nisStartVertex ?\nvec2(-1e34, vStippleDistanceLimits.y) :\nvec2(vStippleDistanceLimits.x, 1e34);`)),z.main.add(S`\n      // Convert back into NDC\n      pos.xy = (pos.xy / viewport.zw) * pos.w;\n\n      vColor = getColor();\n      vColor.a *= coverage;\n\n      ${M&&!V?\"pos.z -= 0.001 * pos.w;\":\"\"}\n\n      // transform final position to camera space for slicing\n      vpos = (inverseProjectionMatrix * pos).xyz;\n      gl_Position = pos;\n      forwardObjectAndLayerIdColor();\n    }`),F.fragment.include(i,C),F.include(L,C),A.include(d),A.main.add(S`discardBySlice(vpos);\ndiscardByTerrainDepth();`),M?A.main.add(S`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`):(U&&A.main.add(S`\n        float sdf = min(vSegmentSDF, vReverseSegmentSDF);\n        vec2 fragmentPosition = vec2(\n          min(sdf, 0.0),\n          vLineDistance\n        ) * gl_FragCoord.w;\n\n        float fragmentRadius = length(fragmentPosition);\n        float fragmentCapSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale\n        float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);\n\n        if (capCoverage < ${S.float(y)}) {\n          discard;\n        }\n      `),$?A.main.add(S`\n      vec2 stipplePosition = vec2(\n        min(getStippleSDF() * 2.0 - 1.0, 0.0),\n        vLineDistanceNorm * gl_FragCoord.w\n      );\n      float stippleRadius = length(stipplePosition * vLineWidth);\n      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale\n      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);\n      float stippleAlpha = step(${S.float(y)}, stippleCoverage);\n      `):A.main.add(S`float stippleAlpha = getStippleAlpha();`),O!==e.ObjectAndLayerIdColor&&A.main.add(S`discardByStippleAlpha(stippleAlpha, ${S.float(y)});`),A.uniforms.add(new f(\"intrinsicColor\",(e=>e.color))),A.main.add(S`vec4 color = intrinsicColor * vColor;`),_&&(A.uniforms.add(new f(\"innerColor\",(e=>e.innerColor??e.color)),new h(\"innerWidth\",((e,i)=>e.innerWidth*i.camera.pixelRatio))),A.main.add(S`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;\nfloat innerAA = clamp(0.5 - distToInner, 0.0, 1.0);\nfloat innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);\ncolor = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)),A.main.add(S`vec4 finalColor = blendStipple(color, stippleAlpha);`),I&&(A.uniforms.add(new h(\"falloff\",(e=>e.falloff))),A.main.add(S`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`)),E||A.main.add(S`float featherStartDistance = max(vLineWidth - 2.0, 0.0);\nfloat value = abs(vLineDistance) * gl_FragCoord.w;\nfloat feather = (value - featherStartDistance) / (vLineWidth - featherStartDistance);\nfinalColor.a *= 1.0 - clamp(feather, 0.0, 1.0);`)),A.main.add(S`outputColorHighlightOID(finalColor, vpos);`),F}const F=Object.freeze(Object.defineProperty({__proto__:null,build:C,ribbonlineNumRoundJoinSubdivisions:j},Symbol.toStringTag,{value:\"Module\"}));export{F as R,C as b,j as r};\n"],"mappings":"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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACZ,CAAC,CAACmC,CAAC,CAAC,EAACA,CAAC,CAACkC,SAAS,CAACV,GAAG,CAAC,SAAS,EAAC,OAAO,EAACZ,CAAC,GAAC,CAAC,GAAC,CAAC,CAAC,CAACkC,IAAI,CAACtB,GAAG,CAAC/C,CAAC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ+D,CAAC,GAAC/D,CAAC,gCAAgC,GAAC,EAAE;AAC9C;AACA;AACA;AACA;AACA,GAAG,CAAC,EAAC6C,CAAC,IAAEtB,CAAC,CAAC8C,IAAI,CAACtB,GAAG,CAAC/C,CAAC;AACpB;AACA;AACA;AACA,EAAE,CAAC,EAACuB,CAAC,CAAC8C,IAAI,CAACtB,GAAG,CAAC/C,CAAC;AAChB;AACA;AACA;AACA,gCAAgC,CAAC;EAAC,CAACmC,CAAC,IAAE6B,CAAC,KAAGzC,CAAC,CAAC8C,IAAI,CAACtB,GAAG,CAAC/C,CAAC;AACtD;AACA;AACA;AACA,QAAQgE,CAAC,GAAChE,CAAC,sDAAsD,GAAC,EAAE;AACpE,KAAK,CAAC,EAACuB,CAAC,CAAC8C,IAAI,CAACtB,GAAG,CAAC/C,CAAC;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,CAAC,EAACuC,CAAC,GAAChB,CAAC,CAAC8C,IAAI,CAACtB,GAAG,CAAC/C,CAAC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyBmC,CAAC,GAACnC,CAAC,gCAAgCA,CAAC,CAACsE,KAAK,CAAC,CAACvD,CAAC,GAAC,CAAC,KAAGA,CAAC,GAAC,CAAC,CAAC,CAAC,GAAG,GAACf,CAAC,mBAAmB;AACxG;AACA;AACA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}