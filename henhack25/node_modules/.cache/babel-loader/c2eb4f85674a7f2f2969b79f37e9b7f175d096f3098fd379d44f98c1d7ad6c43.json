{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { addVerticalOffset as e } from \"../attributes/VerticalOffset.glsl.js\";\nimport { ScreenSizePerspective as t, addScreenSizePerspectiveAlignment as o } from \"../util/ScreenSizePerspective.glsl.js\";\nimport { addProjViewLocalOrigin as a, addCameraPosition as s, addViewNormal as i, addPixelRatio as r } from \"../util/View.glsl.js\";\nimport { Float4BindUniform as n } from \"../../shaderModules/Float4BindUniform.js\";\nimport { FloatBindUniform as l } from \"../../shaderModules/FloatBindUniform.js\";\nimport { FloatPassUniform as f } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as c } from \"../../shaderModules/glsl.js\";\nimport { VertexAttribute as p } from \"../../../lib/VertexAttribute.js\";\nconst d = .5;\nfunction u(u, v) {\n  u.include(t), u.attributes.add(p.POSITION, \"vec3\"), u.attributes.add(p.NORMAL, \"vec3\"), u.attributes.add(p.CENTEROFFSETANDDISTANCE, \"vec4\");\n  const m = u.vertex;\n  a(m, v), s(m, v), m.uniforms.add(new n(\"viewport\", e => e.camera.fullViewport), new f(\"polygonOffset\", e => e.shaderPolygonOffset), new l(\"cameraGroundRelative\", e => e.camera.aboveGround ? 1 : -1)), v.hasVerticalOffset && e(m), m.constants.add(\"smallOffsetAngle\", \"float\", .984807753012208), m.code.add(c`struct ProjectHUDAux {\nvec3 posModel;\nvec3 posView;\nvec3 vnormal;\nfloat distanceToCamera;\nfloat absCosAngle;\n};`), m.code.add(c`\n    float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\n      float pointGroundSign = ${v.terrainDepthTest ? c.float(0) : c`sign(pointGroundDistance)`};\n      if (pointGroundSign == 0.0) {\n        pointGroundSign = cameraGroundRelative;\n      }\n\n      // cameraGroundRelative is -1 if camera is below ground, 1 if above ground\n      // groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise\n      float groundRelative = cameraGroundRelative * pointGroundSign;\n\n      // view angle dependent part of polygon offset emulation: we take the absolute value because the sign that is\n      // dropped is instead introduced using the ground-relative position of the symbol and the camera\n      if (polygonOffset > .0) {\n        float cosAlpha = clamp(absCosAngle, 0.01, 1.0);\n        float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\n        float factor = (1.0 - tanAlpha / viewport[2]);\n\n        // same side of the terrain\n        if (groundRelative > 0.0) {\n          posView *= factor;\n        }\n        // opposite sides of the terrain\n        else {\n          posView /= factor;\n        }\n      }\n\n      return groundRelative;\n    }\n  `), v.draped && !v.hasVerticalOffset || i(m), v.draped || (m.uniforms.add(new l(\"perDistancePixelRatio\", e => Math.tan(e.camera.fovY / 2) / (e.camera.fullViewport[2] / 2))), m.code.add(c`\n    void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {\n      float distanceToCamera = length(posView);\n\n      // Compute offset in world units for a half pixel shift\n      float pixelOffset = distanceToCamera * perDistancePixelRatio * ${c.float(d)};\n\n      // Apply offset along normal in the direction away from the ground surface\n      vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;\n\n      // Apply the same offset also on the view space position\n      vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n\n      posModel += modelOffset;\n      posView += viewOffset;\n    }\n  `)), v.screenCenterOffsetUnitsEnabled && r(m), v.hasScreenSizePerspective && o(m), m.code.add(c`\n    vec4 projectPositionHUD(out ProjectHUDAux aux) {\n      vec3 centerOffset = centerOffsetAndDistance.xyz;\n      float pointGroundDistance = centerOffsetAndDistance.w;\n\n      aux.posModel = position;\n      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;\n      aux.vnormal = normal;\n      ${v.draped ? \"\" : \"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);\"}\n\n      // Screen sized offset in world space, used for example for line callouts\n      // Note: keep this implementation in sync with the CPU implementation, see\n      //   - MaterialUtil.verticalOffsetAtDistance\n      //   - HUDMaterial.applyVerticalOffsetTransformation\n\n      aux.distanceToCamera = length(aux.posView);\n\n      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);\n      float cosAngle = dot(aux.vnormal, viewDirObjSpace);\n\n      aux.absCosAngle = abs(cosAngle);\n\n      ${v.hasScreenSizePerspective && (v.hasVerticalOffset || v.screenCenterOffsetUnitsEnabled) ? \"vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);\" : \"\"}\n\n      ${v.hasVerticalOffset ? v.hasScreenSizePerspective ? \"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);\" : \"float verticalOffsetScreenHeight = verticalOffset.x;\" : \"\"}\n\n      ${v.hasVerticalOffset ? c`\n            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\n            vec3 modelOffset = aux.vnormal * worldOffset;\n            aux.posModel += modelOffset;\n            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n            aux.posView += viewOffset;\n            // Since we elevate the object, we need to take that into account\n            // in the distance to ground\n            pointGroundDistance += worldOffset;` : \"\"}\n\n      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\n\n      ${v.screenCenterOffsetUnitsEnabled ? \"\" : c`\n            // Apply x/y in view space, but z in screen space (i.e. along posView direction)\n            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);\n\n            // Same material all have same z != 0.0 condition so should not lead to\n            // branch fragmentation and will save a normalization if it's not needed\n            if (centerOffset.z != 0.0) {\n              aux.posView -= normalize(aux.posView) * centerOffset.z;\n            }\n          `}\n\n      vec4 posProj = proj * vec4(aux.posView, 1.0);\n\n      ${v.screenCenterOffsetUnitsEnabled ? v.hasScreenSizePerspective ? \"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);\" : \"float centerOffsetY = centerOffset.y;\" : \"\"}\n\n      ${v.screenCenterOffsetUnitsEnabled ? \"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;\" : \"\"}\n\n      // constant part of polygon offset emulation\n      posProj.z -= groundRelative * polygonOffset * posProj.w;\n      return posProj;\n    }\n  `);\n}\nexport { u as HUD, d as HUDVerticalPixelOffset };","map":{"version":3,"names":["addVerticalOffset","e","ScreenSizePerspective","t","addScreenSizePerspectiveAlignment","o","addProjViewLocalOrigin","a","addCameraPosition","s","addViewNormal","i","addPixelRatio","r","Float4BindUniform","n","FloatBindUniform","l","FloatPassUniform","f","glsl","c","VertexAttribute","p","d","u","v","include","attributes","add","POSITION","NORMAL","CENTEROFFSETANDDISTANCE","m","vertex","uniforms","camera","fullViewport","shaderPolygonOffset","aboveGround","hasVerticalOffset","constants","code","terrainDepthTest","float","draped","Math","tan","fovY","screenCenterOffsetUnitsEnabled","hasScreenSizePerspective","HUD","HUDVerticalPixelOffset"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{addVerticalOffset as e}from\"../attributes/VerticalOffset.glsl.js\";import{ScreenSizePerspective as t,addScreenSizePerspectiveAlignment as o}from\"../util/ScreenSizePerspective.glsl.js\";import{addProjViewLocalOrigin as a,addCameraPosition as s,addViewNormal as i,addPixelRatio as r}from\"../util/View.glsl.js\";import{Float4BindUniform as n}from\"../../shaderModules/Float4BindUniform.js\";import{FloatBindUniform as l}from\"../../shaderModules/FloatBindUniform.js\";import{FloatPassUniform as f}from\"../../shaderModules/FloatPassUniform.js\";import{glsl as c}from\"../../shaderModules/glsl.js\";import{VertexAttribute as p}from\"../../../lib/VertexAttribute.js\";const d=.5;function u(u,v){u.include(t),u.attributes.add(p.POSITION,\"vec3\"),u.attributes.add(p.NORMAL,\"vec3\"),u.attributes.add(p.CENTEROFFSETANDDISTANCE,\"vec4\");const m=u.vertex;a(m,v),s(m,v),m.uniforms.add(new n(\"viewport\",(e=>e.camera.fullViewport)),new f(\"polygonOffset\",(e=>e.shaderPolygonOffset)),new l(\"cameraGroundRelative\",(e=>e.camera.aboveGround?1:-1))),v.hasVerticalOffset&&e(m),m.constants.add(\"smallOffsetAngle\",\"float\",.984807753012208),m.code.add(c`struct ProjectHUDAux {\nvec3 posModel;\nvec3 posView;\nvec3 vnormal;\nfloat distanceToCamera;\nfloat absCosAngle;\n};`),m.code.add(c`\n    float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\n      float pointGroundSign = ${v.terrainDepthTest?c.float(0):c`sign(pointGroundDistance)`};\n      if (pointGroundSign == 0.0) {\n        pointGroundSign = cameraGroundRelative;\n      }\n\n      // cameraGroundRelative is -1 if camera is below ground, 1 if above ground\n      // groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise\n      float groundRelative = cameraGroundRelative * pointGroundSign;\n\n      // view angle dependent part of polygon offset emulation: we take the absolute value because the sign that is\n      // dropped is instead introduced using the ground-relative position of the symbol and the camera\n      if (polygonOffset > .0) {\n        float cosAlpha = clamp(absCosAngle, 0.01, 1.0);\n        float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\n        float factor = (1.0 - tanAlpha / viewport[2]);\n\n        // same side of the terrain\n        if (groundRelative > 0.0) {\n          posView *= factor;\n        }\n        // opposite sides of the terrain\n        else {\n          posView /= factor;\n        }\n      }\n\n      return groundRelative;\n    }\n  `),v.draped&&!v.hasVerticalOffset||i(m),v.draped||(m.uniforms.add(new l(\"perDistancePixelRatio\",(e=>Math.tan(e.camera.fovY/2)/(e.camera.fullViewport[2]/2)))),m.code.add(c`\n    void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {\n      float distanceToCamera = length(posView);\n\n      // Compute offset in world units for a half pixel shift\n      float pixelOffset = distanceToCamera * perDistancePixelRatio * ${c.float(d)};\n\n      // Apply offset along normal in the direction away from the ground surface\n      vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;\n\n      // Apply the same offset also on the view space position\n      vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n\n      posModel += modelOffset;\n      posView += viewOffset;\n    }\n  `)),v.screenCenterOffsetUnitsEnabled&&r(m),v.hasScreenSizePerspective&&o(m),m.code.add(c`\n    vec4 projectPositionHUD(out ProjectHUDAux aux) {\n      vec3 centerOffset = centerOffsetAndDistance.xyz;\n      float pointGroundDistance = centerOffsetAndDistance.w;\n\n      aux.posModel = position;\n      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;\n      aux.vnormal = normal;\n      ${v.draped?\"\":\"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);\"}\n\n      // Screen sized offset in world space, used for example for line callouts\n      // Note: keep this implementation in sync with the CPU implementation, see\n      //   - MaterialUtil.verticalOffsetAtDistance\n      //   - HUDMaterial.applyVerticalOffsetTransformation\n\n      aux.distanceToCamera = length(aux.posView);\n\n      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);\n      float cosAngle = dot(aux.vnormal, viewDirObjSpace);\n\n      aux.absCosAngle = abs(cosAngle);\n\n      ${v.hasScreenSizePerspective&&(v.hasVerticalOffset||v.screenCenterOffsetUnitsEnabled)?\"vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);\":\"\"}\n\n      ${v.hasVerticalOffset?v.hasScreenSizePerspective?\"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);\":\"float verticalOffsetScreenHeight = verticalOffset.x;\":\"\"}\n\n      ${v.hasVerticalOffset?c`\n            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\n            vec3 modelOffset = aux.vnormal * worldOffset;\n            aux.posModel += modelOffset;\n            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n            aux.posView += viewOffset;\n            // Since we elevate the object, we need to take that into account\n            // in the distance to ground\n            pointGroundDistance += worldOffset;`:\"\"}\n\n      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\n\n      ${v.screenCenterOffsetUnitsEnabled?\"\":c`\n            // Apply x/y in view space, but z in screen space (i.e. along posView direction)\n            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);\n\n            // Same material all have same z != 0.0 condition so should not lead to\n            // branch fragmentation and will save a normalization if it's not needed\n            if (centerOffset.z != 0.0) {\n              aux.posView -= normalize(aux.posView) * centerOffset.z;\n            }\n          `}\n\n      vec4 posProj = proj * vec4(aux.posView, 1.0);\n\n      ${v.screenCenterOffsetUnitsEnabled?v.hasScreenSizePerspective?\"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);\":\"float centerOffsetY = centerOffset.y;\":\"\"}\n\n      ${v.screenCenterOffsetUnitsEnabled?\"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;\":\"\"}\n\n      // constant part of polygon offset emulation\n      posProj.z -= groundRelative * polygonOffset * posProj.w;\n      return posProj;\n    }\n  `)}export{u as HUD,d as HUDVerticalPixelOffset};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}