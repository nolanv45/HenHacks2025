{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { HighlightReadBitmap as i } from \"../HighlightReadBitmap.glsl.js\";\nimport { ShaderOutput as t } from \"../ShaderOutput.js\";\nimport { glsl as e } from \"../../shaderModules/glsl.js\";\nimport { Integer2BindUniform as l } from \"../../shaderModules/Integer2BindUniform.js\";\nimport { IntegerBindUniform as h } from \"../../shaderModules/IntegerBindUniform.js\";\nimport { Texture2DBindUniform as g } from \"../../shaderModules/Texture2DBindUniform.js\";\nfunction d(d, u) {\n  const {\n    fragment: o\n  } = d;\n  u.output === t.Highlight ? (o.uniforms.add(new g(\"depthTexture\", i => i.mainDepth), new g(\"highlightTexture\", i => i.highlightMixTexture), new h(\"highlightLevel\", i => i.highlightLevel ?? 0), new l(\"highlightMixOrigin\", i => i.highlightMixOrigin)), d.outputs.add(\"fragHighlight\", \"vec2\", 0), d.include(i), o.code.add(e`vec2 getAccumulatedHighlight() {\nreturn texelFetch(highlightTexture, ivec2(gl_FragCoord.xy) - highlightMixOrigin, 0).rg;\n}\nvoid outputHighlight(bool occluded) {\nif (highlightLevel == 0) {\nuint bits = occluded ? 3u : 1u;\nfragHighlight = vec2(float(bits) / 255.0, 0.0);\n} else {\nint ll = (highlightLevel & 3) << 1;\nint li = (highlightLevel >> 2) & 3;\nuint bits;\nif (occluded) {\nbits = 3u << ll;\n} else {\nbits = 1u << ll;\n}\nvec2 combinedHighlight = getAccumulatedHighlight();\nuint accumulatedI = uint(combinedHighlight[li] * 255.0);\ncombinedHighlight[li] = float(bits | accumulatedI) / 255.0;\nfragHighlight = combinedHighlight;\n}\n}\nbool isHighlightOccluded() {\nfloat sceneDepth = texelFetch(depthTexture, ivec2(gl_FragCoord.xy), 0).x;\nreturn gl_FragCoord.z > sceneDepth + 5e-7;\n}\nvoid calculateOcclusionAndOutputHighlight() {\noutputHighlight(isHighlightOccluded());\n}`), u.canHaveOverlay && o.code.add(e`void calculateOcclusionAndOutputHighlightOverlay(vec2 highlightToAdd) {\nuint levelBits = readLevelBits(highlightToAdd, highlightLevel);\nif ((levelBits & 1u) == 0u) { discard; }\noutputHighlight(isHighlightOccluded());\n}`)) : o.code.add(e`void calculateOcclusionAndOutputHighlight() {}`);\n}\nexport { d as OutputHighlight };","map":{"version":3,"names":["HighlightReadBitmap","i","ShaderOutput","t","glsl","e","Integer2BindUniform","l","IntegerBindUniform","h","Texture2DBindUniform","g","d","u","fragment","o","output","Highlight","uniforms","add","mainDepth","highlightMixTexture","highlightLevel","highlightMixOrigin","outputs","include","code","canHaveOverlay","OutputHighlight"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{HighlightReadBitmap as i}from\"../HighlightReadBitmap.glsl.js\";import{ShaderOutput as t}from\"../ShaderOutput.js\";import{glsl as e}from\"../../shaderModules/glsl.js\";import{Integer2BindUniform as l}from\"../../shaderModules/Integer2BindUniform.js\";import{IntegerBindUniform as h}from\"../../shaderModules/IntegerBindUniform.js\";import{Texture2DBindUniform as g}from\"../../shaderModules/Texture2DBindUniform.js\";function d(d,u){const{fragment:o}=d;u.output===t.Highlight?(o.uniforms.add(new g(\"depthTexture\",(i=>i.mainDepth)),new g(\"highlightTexture\",(i=>i.highlightMixTexture)),new h(\"highlightLevel\",(i=>i.highlightLevel??0)),new l(\"highlightMixOrigin\",(i=>i.highlightMixOrigin))),d.outputs.add(\"fragHighlight\",\"vec2\",0),d.include(i),o.code.add(e`vec2 getAccumulatedHighlight() {\nreturn texelFetch(highlightTexture, ivec2(gl_FragCoord.xy) - highlightMixOrigin, 0).rg;\n}\nvoid outputHighlight(bool occluded) {\nif (highlightLevel == 0) {\nuint bits = occluded ? 3u : 1u;\nfragHighlight = vec2(float(bits) / 255.0, 0.0);\n} else {\nint ll = (highlightLevel & 3) << 1;\nint li = (highlightLevel >> 2) & 3;\nuint bits;\nif (occluded) {\nbits = 3u << ll;\n} else {\nbits = 1u << ll;\n}\nvec2 combinedHighlight = getAccumulatedHighlight();\nuint accumulatedI = uint(combinedHighlight[li] * 255.0);\ncombinedHighlight[li] = float(bits | accumulatedI) / 255.0;\nfragHighlight = combinedHighlight;\n}\n}\nbool isHighlightOccluded() {\nfloat sceneDepth = texelFetch(depthTexture, ivec2(gl_FragCoord.xy), 0).x;\nreturn gl_FragCoord.z > sceneDepth + 5e-7;\n}\nvoid calculateOcclusionAndOutputHighlight() {\noutputHighlight(isHighlightOccluded());\n}`),u.canHaveOverlay&&o.code.add(e`void calculateOcclusionAndOutputHighlightOverlay(vec2 highlightToAdd) {\nuint levelBits = readLevelBits(highlightToAdd, highlightLevel);\nif ((levelBits & 1u) == 0u) { discard; }\noutputHighlight(isHighlightOccluded());\n}`)):o.code.add(e`void calculateOcclusionAndOutputHighlight() {}`)}export{d as OutputHighlight};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,mBAAmB,IAAIC,CAAC,QAAK,gCAAgC;AAAC,SAAOC,YAAY,IAAIC,CAAC,QAAK,oBAAoB;AAAC,SAAOC,IAAI,IAAIC,CAAC,QAAK,6BAA6B;AAAC,SAAOC,mBAAmB,IAAIC,CAAC,QAAK,4CAA4C;AAAC,SAAOC,kBAAkB,IAAIC,CAAC,QAAK,2CAA2C;AAAC,SAAOC,oBAAoB,IAAIC,CAAC,QAAK,6CAA6C;AAAC,SAASC,CAACA,CAACA,CAAC,EAACC,CAAC,EAAC;EAAC,MAAK;IAACC,QAAQ,EAACC;EAAC,CAAC,GAACH,CAAC;EAACC,CAAC,CAACG,MAAM,KAAGb,CAAC,CAACc,SAAS,IAAEF,CAAC,CAACG,QAAQ,CAACC,GAAG,CAAC,IAAIR,CAAC,CAAC,cAAc,EAAEV,CAAC,IAAEA,CAAC,CAACmB,SAAU,CAAC,EAAC,IAAIT,CAAC,CAAC,kBAAkB,EAAEV,CAAC,IAAEA,CAAC,CAACoB,mBAAoB,CAAC,EAAC,IAAIZ,CAAC,CAAC,gBAAgB,EAAER,CAAC,IAAEA,CAAC,CAACqB,cAAc,IAAE,CAAE,CAAC,EAAC,IAAIf,CAAC,CAAC,oBAAoB,EAAEN,CAAC,IAAEA,CAAC,CAACsB,kBAAmB,CAAC,CAAC,EAACX,CAAC,CAACY,OAAO,CAACL,GAAG,CAAC,eAAe,EAAC,MAAM,EAAC,CAAC,CAAC,EAACP,CAAC,CAACa,OAAO,CAACxB,CAAC,CAAC,EAACc,CAAC,CAACW,IAAI,CAACP,GAAG,CAACd,CAAC;AAC7uB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACQ,CAAC,CAACc,cAAc,IAAEZ,CAAC,CAACW,IAAI,CAACP,GAAG,CAACd,CAAC;AAClC;AACA;AACA;AACA,EAAE,CAAC,IAAEU,CAAC,CAACW,IAAI,CAACP,GAAG,CAACd,CAAC,gDAAgD,CAAC;AAAA;AAAC,SAAOO,CAAC,IAAIgB,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}