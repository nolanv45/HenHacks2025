{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { translate as e } from \"../core/libs/gl-matrix-2/math/mat4.js\";\nimport { create as t } from \"../core/libs/gl-matrix-2/factories/mat4f64.js\";\nimport { set as o } from \"../core/libs/gl-matrix-2/math/vec2.js\";\nimport { create as r } from \"../core/libs/gl-matrix-2/factories/vec2f64.js\";\nimport { Laserline as a } from \"../views/3d/webgl-engine/core/shaderLibrary/Laserline.glsl.js\";\nimport { Float2BindUniform as i } from \"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";\nimport { FloatBindUniform as n } from \"../views/3d/webgl-engine/core/shaderModules/FloatBindUniform.js\";\nimport { FloatPassUniform as s } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as l, If as d } from \"../views/3d/webgl-engine/core/shaderModules/glsl.js\";\nimport { Matrix4BindUniform as c } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4BindUniform.js\";\nimport { Matrix4PassUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { VertexAttribute as v } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { ShaderBuilder as p } from \"../views/webgl/ShaderBuilder.js\";\nfunction w(t) {\n  const r = new p();\n  r.include(a, t);\n  const {\n    vertex: w,\n    fragment: u\n  } = r;\n  w.uniforms.add(new m(\"modelView\", (t, {\n    camera: o\n  }) => e(f, o.viewMatrix, t.origin)), new c(\"proj\", ({\n    camera: e\n  }) => e.projectionMatrix), new s(\"glowWidth\", (e, {\n    camera: t\n  }) => e.glowWidth * t.pixelRatio), new i(\"pixelToNDC\", ({\n    camera: e\n  }) => o(g, 2 / e.fullViewport[2], 2 / e.fullViewport[3]))), r.attributes.add(v.START, \"vec3\"), r.attributes.add(v.END, \"vec3\"), t.spherical && (r.attributes.add(v.START_UP, \"vec3\"), r.attributes.add(v.END_UP, \"vec3\")), r.attributes.add(v.EXTRUDE, \"vec2\"), r.varyings.add(\"uv\", \"vec2\"), r.varyings.add(\"vViewStart\", \"vec3\"), r.varyings.add(\"vViewEnd\", \"vec3\"), r.varyings.add(\"vViewSegmentNormal\", \"vec3\"), r.varyings.add(\"vViewStartNormal\", \"vec3\"), r.varyings.add(\"vViewEndNormal\", \"vec3\");\n  const h = !t.spherical;\n  return w.main.add(l`\n    vec3 pos = mix(start, end, extrude.x);\n\n    vec4 viewPos = modelView * vec4(pos, 1);\n    vec4 projPos = proj * viewPos;\n    vec2 ndcPos = projPos.xy / projPos.w;\n\n    // in planar we hardcode the up vectors to be Z-up */\n    ${d(h, l`vec3 startUp = vec3(0, 0, 1);`)}\n    ${d(h, l`vec3 endUp = vec3(0, 0, 1);`)}\n\n    // up vector corresponding to the location of the vertex, selecting either startUp or endUp */\n    vec3 up = extrude.y * mix(startUp, endUp, extrude.x);\n    vec3 viewUp = (modelView * vec4(up, 0)).xyz;\n\n    vec4 projPosUp = proj * vec4(viewPos.xyz + viewUp, 1);\n    vec2 projUp = normalize(projPosUp.xy / projPosUp.w - ndcPos);\n\n    // extrude ndcPos along projUp to the edge of the screen\n    vec2 lxy = abs(sign(projUp) - ndcPos);\n    ndcPos += length(lxy) * projUp;\n\n    vViewStart = (modelView * vec4(start, 1)).xyz;\n    vViewEnd = (modelView * vec4(end, 1)).xyz;\n\n    vec3 viewStartEndDir = vViewEnd - vViewStart;\n\n    vec3 viewStartUp = (modelView * vec4(startUp, 0)).xyz;\n\n    // the normal of the plane that aligns with the segment and the up vector\n    vViewSegmentNormal = normalize(cross(viewStartUp, viewStartEndDir));\n\n    // the normal orthogonal to the segment normal and the start up vector\n    vViewStartNormal = -normalize(cross(vViewSegmentNormal, viewStartUp));\n\n    // the normal orthogonal to the segment normal and the end up vector\n    vec3 viewEndUp = (modelView * vec4(endUp, 0)).xyz;\n    vViewEndNormal = normalize(cross(vViewSegmentNormal, viewEndUp));\n\n    // Add enough padding in the X screen space direction for \"glow\"\n    float xPaddingPixels = sign(dot(vViewSegmentNormal, viewPos.xyz)) * (extrude.x * 2.0 - 1.0) * glowWidth;\n    ndcPos.x += xPaddingPixels * pixelToNDC.x;\n\n    // uv is used to read back depth to reconstruct the position at the fragment\n    uv = ndcPos * 0.5 + 0.5;\n\n    gl_Position = vec4(ndcPos, 0, 1);\n  `), u.uniforms.add(new n(\"perScreenPixelRatio\", e => e.camera.perScreenPixelRatio)), u.code.add(l`float planeDistance(vec3 planeNormal, vec3 planeOrigin, vec3 pos) {\nreturn dot(planeNormal, pos - planeOrigin);\n}\nfloat segmentDistancePixels(vec3 segmentNormal, vec3 startNormal, vec3 endNormal, vec3 pos, vec3 start, vec3 end) {\nfloat distSegmentPlane = planeDistance(segmentNormal, start, pos);\nfloat distStartPlane = planeDistance(startNormal, start, pos);\nfloat distEndPlane = planeDistance(endNormal, end, pos);\nfloat dist = max(max(distStartPlane, distEndPlane), abs(distSegmentPlane));\nfloat width = fwidth(distSegmentPlane);\nfloat maxPixelDistance = length(pos) * perScreenPixelRatio * 2.0;\nfloat pixelDist = dist / min(width, maxPixelDistance);\nreturn abs(pixelDist);\n}`), u.main.add(l`fragColor = vec4(0.0);\nvec3 dEndStart = vViewEnd - vViewStart;\nif (dot(dEndStart, dEndStart) < 1e-5) {\nreturn;\n}\nvec3 pos;\nvec3 normal;\nfloat angleCutoffAdjust;\nfloat depthDiscontinuityAlpha;\nif (!laserlineReconstructFromDepth(pos, normal, angleCutoffAdjust, depthDiscontinuityAlpha)) {\nreturn;\n}\nfloat distance = segmentDistancePixels(\nvViewSegmentNormal,\nvViewStartNormal,\nvViewEndNormal,\npos,\nvViewStart,\nvViewEnd\n);\nvec4 color = laserlineProfile(distance);\nfloat alpha = (1.0 - smoothstep(0.995 - angleCutoffAdjust, 0.999 - angleCutoffAdjust, abs(dot(normal, vViewSegmentNormal))));\nfragColor = laserlineOutput(color * alpha * depthDiscontinuityAlpha);`), r;\n}\nconst g = r(),\n  f = t(),\n  u = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    build: w\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { u as L, w as b };","map":{"version":3,"names":["translate","e","create","t","set","o","r","Laserline","a","Float2BindUniform","i","FloatBindUniform","n","FloatPassUniform","s","glsl","l","If","d","Matrix4BindUniform","c","Matrix4PassUniform","m","VertexAttribute","v","ShaderBuilder","p","w","include","vertex","fragment","u","uniforms","add","camera","f","viewMatrix","origin","projectionMatrix","glowWidth","pixelRatio","g","fullViewport","attributes","START","END","spherical","START_UP","END_UP","EXTRUDE","varyings","h","main","perScreenPixelRatio","code","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value","L","b"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/chunks/LaserlinePath.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{translate as e}from\"../core/libs/gl-matrix-2/math/mat4.js\";import{create as t}from\"../core/libs/gl-matrix-2/factories/mat4f64.js\";import{set as o}from\"../core/libs/gl-matrix-2/math/vec2.js\";import{create as r}from\"../core/libs/gl-matrix-2/factories/vec2f64.js\";import{Laserline as a}from\"../views/3d/webgl-engine/core/shaderLibrary/Laserline.glsl.js\";import{Float2BindUniform as i}from\"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";import{FloatBindUniform as n}from\"../views/3d/webgl-engine/core/shaderModules/FloatBindUniform.js\";import{FloatPassUniform as s}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as l,If as d}from\"../views/3d/webgl-engine/core/shaderModules/glsl.js\";import{Matrix4BindUniform as c}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4BindUniform.js\";import{Matrix4PassUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{VertexAttribute as v}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{ShaderBuilder as p}from\"../views/webgl/ShaderBuilder.js\";function w(t){const r=new p;r.include(a,t);const{vertex:w,fragment:u}=r;w.uniforms.add(new m(\"modelView\",((t,{camera:o})=>e(f,o.viewMatrix,t.origin))),new c(\"proj\",(({camera:e})=>e.projectionMatrix)),new s(\"glowWidth\",((e,{camera:t})=>e.glowWidth*t.pixelRatio)),new i(\"pixelToNDC\",(({camera:e})=>o(g,2/e.fullViewport[2],2/e.fullViewport[3])))),r.attributes.add(v.START,\"vec3\"),r.attributes.add(v.END,\"vec3\"),t.spherical&&(r.attributes.add(v.START_UP,\"vec3\"),r.attributes.add(v.END_UP,\"vec3\")),r.attributes.add(v.EXTRUDE,\"vec2\"),r.varyings.add(\"uv\",\"vec2\"),r.varyings.add(\"vViewStart\",\"vec3\"),r.varyings.add(\"vViewEnd\",\"vec3\"),r.varyings.add(\"vViewSegmentNormal\",\"vec3\"),r.varyings.add(\"vViewStartNormal\",\"vec3\"),r.varyings.add(\"vViewEndNormal\",\"vec3\");const h=!t.spherical;return w.main.add(l`\n    vec3 pos = mix(start, end, extrude.x);\n\n    vec4 viewPos = modelView * vec4(pos, 1);\n    vec4 projPos = proj * viewPos;\n    vec2 ndcPos = projPos.xy / projPos.w;\n\n    // in planar we hardcode the up vectors to be Z-up */\n    ${d(h,l`vec3 startUp = vec3(0, 0, 1);`)}\n    ${d(h,l`vec3 endUp = vec3(0, 0, 1);`)}\n\n    // up vector corresponding to the location of the vertex, selecting either startUp or endUp */\n    vec3 up = extrude.y * mix(startUp, endUp, extrude.x);\n    vec3 viewUp = (modelView * vec4(up, 0)).xyz;\n\n    vec4 projPosUp = proj * vec4(viewPos.xyz + viewUp, 1);\n    vec2 projUp = normalize(projPosUp.xy / projPosUp.w - ndcPos);\n\n    // extrude ndcPos along projUp to the edge of the screen\n    vec2 lxy = abs(sign(projUp) - ndcPos);\n    ndcPos += length(lxy) * projUp;\n\n    vViewStart = (modelView * vec4(start, 1)).xyz;\n    vViewEnd = (modelView * vec4(end, 1)).xyz;\n\n    vec3 viewStartEndDir = vViewEnd - vViewStart;\n\n    vec3 viewStartUp = (modelView * vec4(startUp, 0)).xyz;\n\n    // the normal of the plane that aligns with the segment and the up vector\n    vViewSegmentNormal = normalize(cross(viewStartUp, viewStartEndDir));\n\n    // the normal orthogonal to the segment normal and the start up vector\n    vViewStartNormal = -normalize(cross(vViewSegmentNormal, viewStartUp));\n\n    // the normal orthogonal to the segment normal and the end up vector\n    vec3 viewEndUp = (modelView * vec4(endUp, 0)).xyz;\n    vViewEndNormal = normalize(cross(vViewSegmentNormal, viewEndUp));\n\n    // Add enough padding in the X screen space direction for \"glow\"\n    float xPaddingPixels = sign(dot(vViewSegmentNormal, viewPos.xyz)) * (extrude.x * 2.0 - 1.0) * glowWidth;\n    ndcPos.x += xPaddingPixels * pixelToNDC.x;\n\n    // uv is used to read back depth to reconstruct the position at the fragment\n    uv = ndcPos * 0.5 + 0.5;\n\n    gl_Position = vec4(ndcPos, 0, 1);\n  `),u.uniforms.add(new n(\"perScreenPixelRatio\",(e=>e.camera.perScreenPixelRatio))),u.code.add(l`float planeDistance(vec3 planeNormal, vec3 planeOrigin, vec3 pos) {\nreturn dot(planeNormal, pos - planeOrigin);\n}\nfloat segmentDistancePixels(vec3 segmentNormal, vec3 startNormal, vec3 endNormal, vec3 pos, vec3 start, vec3 end) {\nfloat distSegmentPlane = planeDistance(segmentNormal, start, pos);\nfloat distStartPlane = planeDistance(startNormal, start, pos);\nfloat distEndPlane = planeDistance(endNormal, end, pos);\nfloat dist = max(max(distStartPlane, distEndPlane), abs(distSegmentPlane));\nfloat width = fwidth(distSegmentPlane);\nfloat maxPixelDistance = length(pos) * perScreenPixelRatio * 2.0;\nfloat pixelDist = dist / min(width, maxPixelDistance);\nreturn abs(pixelDist);\n}`),u.main.add(l`fragColor = vec4(0.0);\nvec3 dEndStart = vViewEnd - vViewStart;\nif (dot(dEndStart, dEndStart) < 1e-5) {\nreturn;\n}\nvec3 pos;\nvec3 normal;\nfloat angleCutoffAdjust;\nfloat depthDiscontinuityAlpha;\nif (!laserlineReconstructFromDepth(pos, normal, angleCutoffAdjust, depthDiscontinuityAlpha)) {\nreturn;\n}\nfloat distance = segmentDistancePixels(\nvViewSegmentNormal,\nvViewStartNormal,\nvViewEndNormal,\npos,\nvViewStart,\nvViewEnd\n);\nvec4 color = laserlineProfile(distance);\nfloat alpha = (1.0 - smoothstep(0.995 - angleCutoffAdjust, 0.999 - angleCutoffAdjust, abs(dot(normal, vViewSegmentNormal))));\nfragColor = laserlineOutput(color * alpha * depthDiscontinuityAlpha);`),r}const g=r(),f=t(),u=Object.freeze(Object.defineProperty({__proto__:null,build:w},Symbol.toStringTag,{value:\"Module\"}));export{u as L,w as b};\n"],"mappings":"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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC,EAACe,CAAC,CAACC,QAAQ,CAACC,GAAG,CAAC,IAAIrB,CAAC,CAAC,qBAAqB,EAAEX,CAAC,IAAEA,CAAC,CAACiC,MAAM,CAACmB,mBAAoB,CAAC,CAAC,EAACtB,CAAC,CAACuB,IAAI,CAACrB,GAAG,CAACjB,CAAC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,EAACe,CAAC,CAACqB,IAAI,CAACnB,GAAG,CAACjB,CAAC;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,CAAC,EAACV,CAAC;AAAA;AAAC,MAAMmC,CAAC,GAACnC,CAAC,CAAC,CAAC;EAAC6B,CAAC,GAAChC,CAAC,CAAC,CAAC;EAAC4B,CAAC,GAACwB,MAAM,CAACC,MAAM,CAACD,MAAM,CAACE,cAAc,CAAC;IAACC,SAAS,EAAC,IAAI;IAACC,KAAK,EAAChC;EAAC,CAAC,EAACiC,MAAM,CAACC,WAAW,EAAC;IAACC,KAAK,EAAC;EAAQ,CAAC,CAAC,CAAC;AAAC,SAAO/B,CAAC,IAAIgC,CAAC,EAACpC,CAAC,IAAIqC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}