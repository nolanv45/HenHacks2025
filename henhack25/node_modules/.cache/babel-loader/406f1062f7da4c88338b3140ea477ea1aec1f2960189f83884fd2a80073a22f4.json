{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { set as e } from \"../core/libs/gl-matrix-2/math/vec2.js\";\nimport { create as i } from \"../core/libs/gl-matrix-2/factories/vec2f64.js\";\nimport { ZEROS as r } from \"../core/libs/gl-matrix-2/factories/vec4f64.js\";\nimport { RejectBySlice as o } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { AlignPixel as t } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js\";\nimport { HUD as n } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js\";\nimport { HUDVisibility as a } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/HUDVisibility.glsl.js\";\nimport { multipassGeometryTest as l } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js\";\nimport { addScreenSizePerspectiveAlignment as d } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js\";\nimport { Float2BindUniform as s } from \"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";\nimport { Float2PassUniform as c } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float4BindUniform as p } from \"../views/3d/webgl-engine/core/shaderModules/Float4BindUniform.js\";\nimport { Float4PassUniform as g } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as v, If as S } from \"../views/3d/webgl-engine/core/shaderModules/glsl.js\";\nimport { VertexAttribute as m } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { ShaderBuilder as w } from \"../views/webgl/ShaderBuilder.js\";\nfunction h(i) {\n  const h = new w(),\n    {\n      vertex: b,\n      fragment: z\n    } = h,\n    {\n      terrainDepthTest: x\n    } = i;\n  return b.include(t), h.include(n, i), h.vertex.include(o, i), h.attributes.add(m.UV0, \"vec2\"), b.uniforms.add(new p(\"viewport\", e => e.camera.fullViewport), new f(\"lineSize\", (e, i) => e.size > 0 ? Math.max(1, e.size) * i.camera.pixelRatio : 0), new s(\"pixelToNDC\", i => e(u, 2 / i.camera.fullViewport[2], 2 / i.camera.fullViewport[3])), new f(\"borderSize\", (e, i) => e.borderColor ? i.camera.pixelRatio : 0), new c(\"screenOffset\", (i, r) => e(u, i.horizontalScreenOffset * r.camera.pixelRatio, 0))), h.varyings.add(\"coverageSampling\", \"vec4\"), h.varyings.add(\"lineSizes\", \"vec2\"), x && h.varyings.add(\"depth\", \"float\"), i.occlusionTestEnabled && h.include(a), i.hasScreenSizePerspective && d(b), b.main.add(v`\n    ProjectHUDAux projectAux;\n    vec4 endPoint = projectPositionHUD(projectAux);\n\n    vec3 vpos = projectAux.posModel;\n    if (rejectBySlice(vpos)) {\n      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n      return;\n    }\n    ${S(i.occlusionTestEnabled, v`if (!testHUDVisibility(endPoint)) {\n             gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n             return;\n           }`)}\n\n    ${i.hasScreenSizePerspective ? v`vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n               vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);` : \"vec2 screenOffsetScaled = screenOffset;\"}\n    // Add view dependent polygon offset to get exact same original starting point. This is mostly used to get the\n    // correct depth value\n    vec3 posView = (view * vec4(position, 1.0)).xyz;\n    ${S(x, \"depth = posView.z;\")}\n\n    applyHUDViewDependentPolygonOffset(centerOffsetAndDistance.w, projectAux.absCosAngle, posView);\n    vec4 startPoint = proj * vec4(posView, 1.0);\n\n    // Apply screen offset to both start and end point\n    vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n    startPoint.xy += screenOffsetNorm * startPoint.w;\n    endPoint.xy += screenOffsetNorm * endPoint.w;\n\n    // Align start and end to pixel origin\n    vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n    vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n    ${S(i.hudDepth, i.hudDepthAlignStart ? \"endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);\" : \"startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);\")}\n    vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n\n    // The direction of the line in screen space\n    vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n    vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n    ${i.hasScreenSizePerspective ? v`float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n               float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);` : v`float lineSizeScaled = lineSize;\n               float borderSizeScaled = borderSize;`}\n    float halfPixelSize = lineSizeScaled * 0.5;\n\n    // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\n    float padding = 1.0 + borderSizeScaled;\n    vec2 ndcOffset = (-halfPixelSize - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n\n    // Offset x/y from the center of the line in screen space\n    projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n\n    // Compute a coverage varying which we can use in the fragment shader to determine\n    // how much a pixel is actually covered by the line (i.e. to anti alias the line).\n    // This works by computing two coordinates that can be linearly interpolated and then\n    // subtracted to find out how far away from the line edge we are.\n    float edgeDirection = (uv0.x * 2.0 - 1.0);\n\n    float halfBorderSize = 0.5 * borderSizeScaled;\n    float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n    float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n\n    float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n\n    coverageSampling = vec4(\n      // Edge coordinate\n      outerEdgeCoverageSampler,\n\n      // Border edge coordinate\n      outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n\n      // Line offset\n      halfPixelSize - 0.5,\n\n      // Border offset\n      halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n    );\n\n    lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n    gl_Position = projectedPosition;`), z.uniforms.add(new g(\"uColor\", e => e.color ?? r), new g(\"borderColor\", e => e.borderColor ?? r)), x && (z.include(l, i), z.uniforms.add(new s(\"inverseViewport\", e => e.inverseViewport))), z.main.add(v`\n    ${S(x, \"if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }\")}\n\n    vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n\n    float borderAlpha = uColor.a * borderColor.a * coverage.y;\n    float colorAlpha = uColor.a * coverage.x;\n\n    float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n    ${S(!i.hudDepth, v`vec3 finalRgb = mix(borderColor.rgb * borderAlpha, uColor.rgb, colorAlpha);\n           fragColor = vec4(finalRgb, finalAlpha);`)}`), h;\n}\nconst u = i(),\n  b = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    build: h\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { b as L, h as b };","map":{"version":3,"names":["set","e","create","i","ZEROS","r","RejectBySlice","o","AlignPixel","t","HUD","n","HUDVisibility","a","multipassGeometryTest","l","addScreenSizePerspectiveAlignment","d","Float2BindUniform","s","Float2PassUniform","c","Float4BindUniform","p","Float4PassUniform","g","FloatPassUniform","f","glsl","v","If","S","VertexAttribute","m","ShaderBuilder","w","h","vertex","b","fragment","z","terrainDepthTest","x","include","attributes","add","UV0","uniforms","camera","fullViewport","size","Math","max","pixelRatio","u","borderColor","horizontalScreenOffset","varyings","occlusionTestEnabled","hasScreenSizePerspective","main","hudDepth","hudDepthAlignStart","color","inverseViewport","Object","freeze","defineProperty","__proto__","build","Symbol","toStringTag","value","L"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/chunks/LineCallout.glsl.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{set as e}from\"../core/libs/gl-matrix-2/math/vec2.js\";import{create as i}from\"../core/libs/gl-matrix-2/factories/vec2f64.js\";import{ZEROS as r}from\"../core/libs/gl-matrix-2/factories/vec4f64.js\";import{RejectBySlice as o}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{AlignPixel as t}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js\";import{HUD as n}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js\";import{HUDVisibility as a}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/HUDVisibility.glsl.js\";import{multipassGeometryTest as l}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js\";import{addScreenSizePerspectiveAlignment as d}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js\";import{Float2BindUniform as s}from\"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";import{Float2PassUniform as c}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4BindUniform as p}from\"../views/3d/webgl-engine/core/shaderModules/Float4BindUniform.js\";import{Float4PassUniform as g}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as v,If as S}from\"../views/3d/webgl-engine/core/shaderModules/glsl.js\";import{VertexAttribute as m}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{ShaderBuilder as w}from\"../views/webgl/ShaderBuilder.js\";function h(i){const h=new w,{vertex:b,fragment:z}=h,{terrainDepthTest:x}=i;return b.include(t),h.include(n,i),h.vertex.include(o,i),h.attributes.add(m.UV0,\"vec2\"),b.uniforms.add(new p(\"viewport\",(e=>e.camera.fullViewport)),new f(\"lineSize\",((e,i)=>e.size>0?Math.max(1,e.size)*i.camera.pixelRatio:0)),new s(\"pixelToNDC\",(i=>e(u,2/i.camera.fullViewport[2],2/i.camera.fullViewport[3]))),new f(\"borderSize\",((e,i)=>e.borderColor?i.camera.pixelRatio:0)),new c(\"screenOffset\",((i,r)=>e(u,i.horizontalScreenOffset*r.camera.pixelRatio,0)))),h.varyings.add(\"coverageSampling\",\"vec4\"),h.varyings.add(\"lineSizes\",\"vec2\"),x&&h.varyings.add(\"depth\",\"float\"),i.occlusionTestEnabled&&h.include(a),i.hasScreenSizePerspective&&d(b),b.main.add(v`\n    ProjectHUDAux projectAux;\n    vec4 endPoint = projectPositionHUD(projectAux);\n\n    vec3 vpos = projectAux.posModel;\n    if (rejectBySlice(vpos)) {\n      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n      return;\n    }\n    ${S(i.occlusionTestEnabled,v`if (!testHUDVisibility(endPoint)) {\n             gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n             return;\n           }`)}\n\n    ${i.hasScreenSizePerspective?v`vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n               vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);`:\"vec2 screenOffsetScaled = screenOffset;\"}\n    // Add view dependent polygon offset to get exact same original starting point. This is mostly used to get the\n    // correct depth value\n    vec3 posView = (view * vec4(position, 1.0)).xyz;\n    ${S(x,\"depth = posView.z;\")}\n\n    applyHUDViewDependentPolygonOffset(centerOffsetAndDistance.w, projectAux.absCosAngle, posView);\n    vec4 startPoint = proj * vec4(posView, 1.0);\n\n    // Apply screen offset to both start and end point\n    vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n    startPoint.xy += screenOffsetNorm * startPoint.w;\n    endPoint.xy += screenOffsetNorm * endPoint.w;\n\n    // Align start and end to pixel origin\n    vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n    vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n    ${S(i.hudDepth,i.hudDepthAlignStart?\"endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);\":\"startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);\")}\n    vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n\n    // The direction of the line in screen space\n    vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n    vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n    ${i.hasScreenSizePerspective?v`float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n               float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);`:v`float lineSizeScaled = lineSize;\n               float borderSizeScaled = borderSize;`}\n    float halfPixelSize = lineSizeScaled * 0.5;\n\n    // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\n    float padding = 1.0 + borderSizeScaled;\n    vec2 ndcOffset = (-halfPixelSize - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n\n    // Offset x/y from the center of the line in screen space\n    projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n\n    // Compute a coverage varying which we can use in the fragment shader to determine\n    // how much a pixel is actually covered by the line (i.e. to anti alias the line).\n    // This works by computing two coordinates that can be linearly interpolated and then\n    // subtracted to find out how far away from the line edge we are.\n    float edgeDirection = (uv0.x * 2.0 - 1.0);\n\n    float halfBorderSize = 0.5 * borderSizeScaled;\n    float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n    float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n\n    float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n\n    coverageSampling = vec4(\n      // Edge coordinate\n      outerEdgeCoverageSampler,\n\n      // Border edge coordinate\n      outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n\n      // Line offset\n      halfPixelSize - 0.5,\n\n      // Border offset\n      halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n    );\n\n    lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n    gl_Position = projectedPosition;`),z.uniforms.add(new g(\"uColor\",(e=>e.color??r)),new g(\"borderColor\",(e=>e.borderColor??r))),x&&(z.include(l,i),z.uniforms.add(new s(\"inverseViewport\",(e=>e.inverseViewport)))),z.main.add(v`\n    ${S(x,\"if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }\")}\n\n    vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n\n    float borderAlpha = uColor.a * borderColor.a * coverage.y;\n    float colorAlpha = uColor.a * coverage.x;\n\n    float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n    ${S(!i.hudDepth,v`vec3 finalRgb = mix(borderColor.rgb * borderAlpha, uColor.rgb, colorAlpha);\n           fragColor = vec4(finalRgb, finalAlpha);`)}`),h}const u=i(),b=Object.freeze(Object.defineProperty({__proto__:null,build:h},Symbol.toStringTag,{value:\"Module\"}));export{b as L,h as b};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}