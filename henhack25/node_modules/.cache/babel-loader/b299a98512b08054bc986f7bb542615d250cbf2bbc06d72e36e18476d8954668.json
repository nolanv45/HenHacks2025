{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport { createProgramTemplate as r } from \"./shaders/MaterialPrograms.js\";\nclass e {\n  constructor(r) {\n    this._rctx = r, this._programByKey = new Map();\n  }\n  dispose() {\n    this._programByKey.forEach(r => r.dispose()), this._programByKey.clear();\n  }\n  getProgram(e, t = []) {\n    const a = e.vsPath + \".\" + e.fsPath + JSON.stringify(t);\n    if (this._programByKey.has(a)) return this._programByKey.get(a);\n    const s = {\n        ...t.map(r => \"string\" == typeof r ? {\n          name: r,\n          value: !0\n        } : r).reduce((r, e) => ({\n          ...r,\n          [e.name]: e.value\n        }), {})\n      },\n      {\n        vsPath: o,\n        fsPath: h,\n        attributes: i\n      } = e,\n      g = r(o, h, i, s),\n      m = this._rctx.programCache.acquire(g.shaders.vertexShader, g.shaders.fragmentShader, g.attributes);\n    if (!m) throw new Error(\"Unable to get program for key: ${key}\");\n    return this._programByKey.set(a, m), m;\n  }\n}\nexport { e as default };","map":{"version":3,"names":["createProgramTemplate","r","e","constructor","_rctx","_programByKey","Map","dispose","forEach","clear","getProgram","t","a","vsPath","fsPath","JSON","stringify","has","get","s","map","name","value","reduce","o","h","attributes","i","g","m","programCache","acquire","shaders","vertexShader","fragmentShader","Error","set","default"],"sources":["C:/Users/nolan/tasks/HenHacks2025/henhack25/node_modules/@arcgis/core/views/2d/engine/webgl/MaterialManager.js"],"sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.32/esri/copyright.txt for details.\n*/\nimport{createProgramTemplate as r}from\"./shaders/MaterialPrograms.js\";class e{constructor(r){this._rctx=r,this._programByKey=new Map}dispose(){this._programByKey.forEach((r=>r.dispose())),this._programByKey.clear()}getProgram(e,t=[]){const a=e.vsPath+\".\"+e.fsPath+JSON.stringify(t);if(this._programByKey.has(a))return this._programByKey.get(a);const s={...t.map((r=>\"string\"==typeof r?{name:r,value:!0}:r)).reduce(((r,e)=>({...r,[e.name]:e.value})),{})},{vsPath:o,fsPath:h,attributes:i}=e,g=r(o,h,i,s),m=this._rctx.programCache.acquire(g.shaders.vertexShader,g.shaders.fragmentShader,g.attributes);if(!m)throw new Error(\"Unable to get program for key: ${key}\");return this._programByKey.set(a,m),m}}export{e as default};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,qBAAqB,IAAIC,CAAC,QAAK,+BAA+B;AAAC,MAAMC,CAAC;EAACC,WAAWA,CAACF,CAAC,EAAC;IAAC,IAAI,CAACG,KAAK,GAACH,CAAC,EAAC,IAAI,CAACI,aAAa,GAAC,IAAIC,GAAG,CAAD,CAAC;EAAA;EAACC,OAAOA,CAAA,EAAE;IAAC,IAAI,CAACF,aAAa,CAACG,OAAO,CAAEP,CAAC,IAAEA,CAAC,CAACM,OAAO,CAAC,CAAE,CAAC,EAAC,IAAI,CAACF,aAAa,CAACI,KAAK,CAAC,CAAC;EAAA;EAACC,UAAUA,CAACR,CAAC,EAACS,CAAC,GAAC,EAAE,EAAC;IAAC,MAAMC,CAAC,GAACV,CAAC,CAACW,MAAM,GAAC,GAAG,GAACX,CAAC,CAACY,MAAM,GAACC,IAAI,CAACC,SAAS,CAACL,CAAC,CAAC;IAAC,IAAG,IAAI,CAACN,aAAa,CAACY,GAAG,CAACL,CAAC,CAAC,EAAC,OAAO,IAAI,CAACP,aAAa,CAACa,GAAG,CAACN,CAAC,CAAC;IAAC,MAAMO,CAAC,GAAC;QAAC,GAAGR,CAAC,CAACS,GAAG,CAAEnB,CAAC,IAAE,QAAQ,IAAE,OAAOA,CAAC,GAAC;UAACoB,IAAI,EAACpB,CAAC;UAACqB,KAAK,EAAC,CAAC;QAAC,CAAC,GAACrB,CAAE,CAAC,CAACsB,MAAM,CAAE,CAACtB,CAAC,EAACC,CAAC,MAAI;UAAC,GAAGD,CAAC;UAAC,CAACC,CAAC,CAACmB,IAAI,GAAEnB,CAAC,CAACoB;QAAK,CAAC,CAAC,EAAE,CAAC,CAAC;MAAC,CAAC;MAAC;QAACT,MAAM,EAACW,CAAC;QAACV,MAAM,EAACW,CAAC;QAACC,UAAU,EAACC;MAAC,CAAC,GAACzB,CAAC;MAAC0B,CAAC,GAAC3B,CAAC,CAACuB,CAAC,EAACC,CAAC,EAACE,CAAC,EAACR,CAAC,CAAC;MAACU,CAAC,GAAC,IAAI,CAACzB,KAAK,CAAC0B,YAAY,CAACC,OAAO,CAACH,CAAC,CAACI,OAAO,CAACC,YAAY,EAACL,CAAC,CAACI,OAAO,CAACE,cAAc,EAACN,CAAC,CAACF,UAAU,CAAC;IAAC,IAAG,CAACG,CAAC,EAAC,MAAM,IAAIM,KAAK,CAAC,uCAAuC,CAAC;IAAC,OAAO,IAAI,CAAC9B,aAAa,CAAC+B,GAAG,CAACxB,CAAC,EAACiB,CAAC,CAAC,EAACA,CAAC;EAAA;AAAC;AAAC,SAAO3B,CAAC,IAAImC,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}